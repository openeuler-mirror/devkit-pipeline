<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kunpeng DevKit</title>
    <script>
        const full_pages = ['report', 'trend', 'git', 'chart'];
        const valid_pages = ['report', 'trend', 'git', 'chart'];
        const pipelineData = {
            report: {
                report_tb_cols: 2,
                report_tb_data: ['IP', 'User Name', '10.175.119.223', 'devadmin'],
            },
            trend: {
                trend_tb_cols: 4,
                trend_tb_data: ['TimeStamp', 'Elapsed', 'label', 'responseCode', '1234567', '7524', 'home_page', 'Non HTTP response code: java.net.SocketException', '2345678', '13369', 'home_page', 'Non HTTP response code: java.net.SocketException'],
                trend_chart_labels: ['TimeStamp', 'Elapsed'], // must be countable, idx_0 represents x-axis
            },
            git: {
                git_tb_cols: 2,
                git_tb_data: ['Key', 'Value', 'commit', '478ea28ce27fdc003334c6f', 'author', 'huxiongbin 00637742', 'author_email', 'huxiongbin3@huawei.com', 'date', 'Wed Nov 22 11:14:15 2023 +0800', 'message', 'merge-master-into-master'],
            },
            chart: {
                chart_json: {
                    'sys': {
                        'cpu': {
                            'user': [111, 222, 333, 444],
                            'system': [321, 432, 321, 432]
                        }
                    }
                },
            },
        }
    </script>
    <!-- chart.js -->
    <script>
        /** * Skipped minification because the original files appears to be already minified. * Original file: /npm/chart.js@4.4.2/dist/chart.umd.js * * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files */ /*! * Chart.js v4.4.2 * https://www.chartjs.org * (c) 2024 Chart.js Contributors * Released under the MIT License */ ! function(t, e) {
            "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e()
        }(this, (function() {
            "use strict";
            var t = Object.freeze({
                __proto__: null,
                get Colors() {
                    return Go
                },
                get Decimation() {
                    return Qo
                },
                get Filler() {
                    return ma
                },
                get Legend() {
                    return ya
                },
                get SubTitle() {
                    return ka
                },
                get Title() {
                    return Ma
                },
                get Tooltip() {
                    return Ba
                }
            });

            function e() {}
            const i = (() => {
                let t = 0;
                return () => t++
            })();

            function s(t) {
                return null == t
            }

            function n(t) {
                if (Array.isArray && Array.isArray(t)) return !0;
                const e = Object.prototype.toString.call(t);
                return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6)
            }

            function o(t) {
                return null !== t && "[object Object]" === Object.prototype.toString.call(t)
            }

            function a(t) {
                return ("number" == typeof t || t instanceof Number) && isFinite(+t)
            }

            function r(t, e) {
                return a(t) ? t : e
            }

            function l(t, e) {
                return void 0 === t ? e : t
            }
            const h = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : +t / e,
                c = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;

            function d(t, e, i) {
                if (t && "function" == typeof t.call) return t.apply(i, e)
            }

            function u(t, e, i, s) {
                let a, r, l;
                if (n(t))
                    if (r = t.length, s)
                        for (a = r - 1; a >= 0; a--) e.call(i, t[a], a);
                    else
                        for (a = 0; a < r; a++) e.call(i, t[a], a);
                else if (o(t))
                    for (l = Object.keys(t), r = l.length, a = 0; a < r; a++) e.call(i, t[l[a]], l[a])
            }

            function f(t, e) {
                let i, s, n, o;
                if (!t || !e || t.length !== e.length) return !1;
                for (i = 0, s = t.length; i < s; ++i)
                    if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;
                return !0
            }

            function g(t) {
                if (n(t)) return t.map(g);
                if (o(t)) {
                    const e = Object.create(null),
                        i = Object.keys(t),
                        s = i.length;
                    let n = 0;
                    for (; n < s; ++n) e[i[n]] = g(t[i[n]]);
                    return e
                }
                return t
            }

            function p(t) {
                return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
            }

            function m(t, e, i, s) {
                if (!p(t)) return;
                const n = e[t],
                    a = i[t];
                o(n) && o(a) ? b(n, a, s) : e[t] = g(a)
            }

            function b(t, e, i) {
                const s = n(e) ? e : [e],
                    a = s.length;
                if (!o(t)) return t;
                const r = (i = i || {}).merger || m;
                let l;
                for (let e = 0; e < a; ++e) {
                    if (l = s[e], !o(l)) continue;
                    const n = Object.keys(l);
                    for (let e = 0, s = n.length; e < s; ++e) r(n[e], t, l, i)
                }
                return t
            }

            function x(t, e) {
                return b(t, e, {
                    merger: _
                })
            }

            function _(t, e, i) {
                if (!p(t)) return;
                const s = e[t],
                    n = i[t];
                o(s) && o(n) ? x(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n))
            }
            const y = {
                "": t => t,
                x: t => t.x,
                y: t => t.y
            };

            function v(t) {
                const e = t.split("."),
                    i = [];
                let s = "";
                for (const t of e) s += t, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (i.push(s), s = "");
                return i
            }

            function M(t, e) {
                const i = y[e] || (y[e] = function(t) {
                    const e = v(t);
                    return t => {
                        for (const i of e) {
                            if ("" === i) break;
                            t = t && t[i]
                        }
                        return t
                    }
                }(e));
                return i(t)
            }

            function w(t) {
                return t.charAt(0).toUpperCase() + t.slice(1)
            }
            const k = t => void 0 !== t,
                S = t => "function" == typeof t,
                P = (t, e) => {
                    if (t.size !== e.size) return !1;
                    for (const i of t)
                        if (!e.has(i)) return !1;
                    return !0
                };

            function D(t) {
                return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type
            }
            const C = Math.PI,
                O = 2 * C,
                A = O + C,
                T = Number.POSITIVE_INFINITY,
                L = C / 180,
                E = C / 2,
                R = C / 4,
                I = 2 * C / 3,
                z = Math.log10,
                F = Math.sign;

            function V(t, e, i) {
                return Math.abs(t - e) < i
            }

            function B(t) {
                const e = Math.round(t);
                t = V(t, e, t / 1e3) ? e : t;
                const i = Math.pow(10, Math.floor(z(t))),
                    s = t / i;
                return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i
            }

            function W(t) {
                const e = [],
                    i = Math.sqrt(t);
                let s;
                for (s = 1; s < i; s++) t % s == 0 && (e.push(s), e.push(t / s));
                return i === (0 | i) && e.push(i), e.sort(((t, e) => t - e)).pop(), e
            }

            function N(t) {
                return !isNaN(parseFloat(t)) && isFinite(t)
            }

            function H(t, e) {
                const i = Math.round(t);
                return i - e <= t && i + e >= t
            }

            function j(t, e, i) {
                let s, n, o;
                for (s = 0, n = t.length; s < n; s++) o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o))
            }

            function $(t) {
                return t * (C / 180)
            }

            function Y(t) {
                return t * (180 / C)
            }

            function U(t) {
                if (!a(t)) return;
                let e = 1,
                    i = 0;
                for (; Math.round(t * e) / e !== t;) e *= 10, i++;
                return i
            }

            function X(t, e) {
                const i = e.x - t.x,
                    s = e.y - t.y,
                    n = Math.sqrt(i * i + s * s);
                let o = Math.atan2(s, i);
                return o < -.5 * C && (o += O), {
                    angle: o,
                    distance: n
                }
            }

            function q(t, e) {
                return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
            }

            function K(t, e) {
                return (t - e + A) % O - C
            }

            function G(t) {
                return (t % O + O) % O
            }

            function Z(t, e, i, s) {
                const n = G(t),
                    o = G(e),
                    a = G(i),
                    r = G(o - n),
                    l = G(a - n),
                    h = G(n - o),
                    c = G(n - a);
                return n === o || n === a || s && o === a || r > l && h < c
            }

            function J(t, e, i) {
                return Math.max(e, Math.min(i, t))
            }

            function Q(t) {
                return J(t, -32768, 32767)
            }

            function tt(t, e, i, s = 1e-6) {
                return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s
            }

            function et(t, e, i) {
                i = i || (i => t[i] < e);
                let s, n = t.length - 1,
                    o = 0;
                for (; n - o > 1;) s = o + n >> 1, i(s) ? o = s : n = s;
                return {
                    lo: o,
                    hi: n
                }
            }
            const it = (t, e, i, s) => et(t, i, s ? s => {
                    const n = t[s][e];
                    return n < i || n === i && t[s + 1][e] === i
                } : s => t[s][e] < i),
                st = (t, e, i) => et(t, i, (s => t[s][e] >= i));

            function nt(t, e, i) {
                let s = 0,
                    n = t.length;
                for (; s < n && t[s] < e;) s++;
                for (; n > s && t[n - 1] > i;) n--;
                return s > 0 || n < t.length ? t.slice(s, n) : t
            }
            const ot = ["push", "pop", "shift", "splice", "unshift"];

            function at(t, e) {
                t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
                    configurable: !0,
                    enumerable: !1,
                    value: {
                        listeners: [e]
                    }
                }), ot.forEach((e => {
                    const i = "_onData" + w(e),
                        s = t[e];
                    Object.defineProperty(t, e, {
                        configurable: !0,
                        enumerable: !1,
                        value(...e) {
                            const n = s.apply(this, e);
                            return t._chartjs.listeners.forEach((t => {
                                "function" == typeof t[i] && t[i](...e)
                            })), n
                        }
                    })
                })))
            }

            function rt(t, e) {
                const i = t._chartjs;
                if (!i) return;
                const s = i.listeners,
                    n = s.indexOf(e); - 1 !== n && s.splice(n, 1), s.length > 0 || (ot.forEach((e => {
                    delete t[e]
                })), delete t._chartjs)
            }

            function lt(t) {
                const e = new Set(t);
                return e.size === t.length ? t : Array.from(e)
            }
            const ht = "undefined" == typeof window ? function(t) {
                return t()
            } : window.requestAnimationFrame;

            function ct(t, e) {
                let i = [],
                    s = !1;
                return function(...n) {
                    i = n, s || (s = !0, ht.call(window, (() => {
                        s = !1, t.apply(e, i)
                    })))
                }
            }

            function dt(t, e) {
                let i;
                return function(...s) {
                    return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e
                }
            }
            const ut = t => "start" === t ? "left" : "end" === t ? "right" : "center",
                ft = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2,
                gt = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e;

            function pt(t, e, i) {
                const s = e.length;
                let n = 0,
                    o = s;
                if (t._sorted) {
                    const {
                        iScale: a,
                        _parsed: r
                    } = t, l = a.axis, {
                        min: h,
                        max: c,
                        minDefined: d,
                        maxDefined: u
                    } = a.getUserBounds();
                    d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n
                }
                return {
                    start: n,
                    count: o
                }
            }

            function mt(t) {
                const {
                    xScale: e,
                    yScale: i,
                    _scaleRanges: s
                } = t, n = {
                    xmin: e.min,
                    xmax: e.max,
                    ymin: i.min,
                    ymax: i.max
                };
                if (!s) return t._scaleRanges = n, !0;
                const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;
                return Object.assign(s, n), o
            }
            class bt {
                constructor() {
                    this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
                }
                _notify(t, e, i, s) {
                    const n = e.listeners[s],
                        o = e.duration;
                    n.forEach((s => s({
                        chart: t,
                        initial: e.initial,
                        numSteps: o,
                        currentStep: Math.min(i - e.start, o)
                    })))
                }
                _refresh() {
                    this._request || (this._running = !0, this._request = ht.call(window, (() => {
                        this._update(), this._request = null, this._running && this._refresh()
                    })))
                }
                _update(t = Date.now()) {
                    let e = 0;
                    this._charts.forEach(((i, s) => {
                        if (!i.running || !i.items.length) return;
                        const n = i.items;
                        let o, a = n.length - 1,
                            r = !1;
                        for (; a >= 0; --a) o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());
                        r && (s.draw(), this._notify(s, i, t, "progress")), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length
                    })), this._lastDate = t, 0 === e && (this._running = !1)
                }
                _getAnims(t) {
                    const e = this._charts;
                    let i = e.get(t);
                    return i || (i = {
                        running: !1,
                        initial: !0,
                        items: [],
                        listeners: {
                            complete: [],
                            progress: []
                        }
                    }, e.set(t, i)), i
                }
                listen(t, e, i) {
                    this._getAnims(t).listeners[e].push(i)
                }
                add(t, e) {
                    e && e.length && this._getAnims(t).items.push(...e)
                }
                has(t) {
                    return this._getAnims(t).items.length > 0
                }
                start(t) {
                    const e = this._charts.get(t);
                    e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh())
                }
                running(t) {
                    if (!this._running) return !1;
                    const e = this._charts.get(t);
                    return !!(e && e.running && e.items.length)
                }
                stop(t) {
                    const e = this._charts.get(t);
                    if (!e || !e.items.length) return;
                    const i = e.items;
                    let s = i.length - 1;
                    for (; s >= 0; --s) i[s].cancel();
                    e.items = [], this._notify(t, e, Date.now(), "complete")
                }
                remove(t) {
                    return this._charts.delete(t)
                }
            }
            var xt = new bt; /*! * @kurkle/color v0.3.2 * https://github.com/kurkle/color#readme * (c) 2023 Jukka Kurkela * Released under the MIT License */
            function _t(t) {
                return t + .5 | 0
            }
            const yt = (t, e, i) => Math.max(Math.min(t, i), e);

            function vt(t) {
                return yt(_t(2.55 * t), 0, 255)
            }

            function Mt(t) {
                return yt(_t(255 * t), 0, 255)
            }

            function wt(t) {
                return yt(_t(t / 2.55) / 100, 0, 1)
            }

            function kt(t) {
                return yt(_t(100 * t), 0, 100)
            }
            const St = {
                    0: 0,
                    1: 1,
                    2: 2,
                    3: 3,
                    4: 4,
                    5: 5,
                    6: 6,
                    7: 7,
                    8: 8,
                    9: 9,
                    A: 10,
                    B: 11,
                    C: 12,
                    D: 13,
                    E: 14,
                    F: 15,
                    a: 10,
                    b: 11,
                    c: 12,
                    d: 13,
                    e: 14,
                    f: 15
                },
                Pt = [...
                    "0123456789ABCDEF"
                ],
                Dt = t => Pt[15 & t],
                Ct = t => Pt[(240 & t) >> 4] + Pt[15 & t],
                Ot = t => (240 & t) >> 4 == (15 & t);

            function At(t) {
                var e = (t => Ot(t.r) && Ot(t.g) && Ot(t.b) && Ot(t.a))(t) ? Dt : Ct;
                return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0
            }
            const Tt = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

            function Lt(t, e, i) {
                const s = e * Math.min(i, 1 - i),
                    n = (e, n = (e + t / 30) % 12) => i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);
                return [n(0), n(8), n(4)]
            }

            function Et(t, e, i) {
                const s = (s, n = (s + t / 60) % 6) => i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);
                return [s(5), s(3), s(1)]
            }

            function Rt(t, e, i) {
                const s = Lt(t, 1, .5);
                let n;
                for (e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++) s[n] *= 1 - e - i, s[n] += e;
                return s
            }

            function It(t) {
                const e = t.r / 255,
                    i = t.g / 255,
                    s = t.b / 255,
                    n = Math.max(e, i, s),
                    o = Math.min(e, i, s),
                    a = (n + o) / 2;
                let r, l, h;
                return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function(t, e, i, s, n) {
                    return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4
                }(e, i, s, h, n), r = 60 * r + .5), [0 | r, l || 0, a]
            }

            function zt(t, e, i, s) {
                return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt)
            }

            function Ft(t, e, i) {
                return zt(Lt, t, e, i)
            }

            function Vt(t) {
                return (t % 360 + 360) % 360
            }

            function Bt(t) {
                const e = Tt.exec(t);
                let i, s = 255;
                if (!e) return;
                e[5] !== i && (s = e[6] ? vt(+e[5]) : Mt(+e[5]));
                const n = Vt(+e[2]),
                    o = +e[3] / 100,
                    a = +e[4] / 100;
                return i = "hwb" === e[1] ? function(t, e, i) {
                    return zt(Rt, t, e, i)
                }(n, o, a) : "hsv" === e[1] ? function(t, e, i) {
                    return zt(Et, t, e, i)
                }(n, o, a) : Ft(n, o, a), {
                    r: i[0],
                    g: i[1],
                    b: i[2],
                    a: s
                }
            }
            const Wt = {
                    x: "dark",
                    Z: "light",
                    Y: "re",
                    X: "blu",
                    W: "gr",
                    V: "medium",
                    U: "slate",
                    A: "ee",
                    T: "ol",
                    S: "or",
                    B: "ra",
                    C: "lateg",
                    D: "ights",
                    R: "in",
                    Q: "turquois",
                    E: "hi",
                    P: "ro",
                    O: "al",
                    N: "le",
                    M: "de",
                    L: "yello",
                    F: "en",
                    K: "ch",
                    G: "arks",
                    H: "ea",
                    I: "ightg",
                    J: "wh"
                },
                Nt = {
                    OiceXe: "f0f8ff",
                    antiquewEte: "faebd7",
                    aqua: "ffff",
                    aquamarRe: "7fffd4",
                    azuY: "f0ffff",
                    beige: "f5f5dc",
                    bisque: "ffe4c4",
                    black: "0",
                    blanKedOmond: "ffebcd",
                    Xe: "ff",
                    XeviTet: "8a2be2",
                    bPwn: "a52a2a",
                    burlywood: "deb887",
                    caMtXe: "5f9ea0",
                    KartYuse: "7fff00",
                    KocTate: "d2691e",
                    cSO: "ff7f50",
                    cSnflowerXe: "6495ed",
                    cSnsilk: "fff8dc",
                    crimson: "dc143c",
                    cyan: "ffff",
                    xXe: "8b",
                    xcyan: "8b8b",
                    xgTMnPd: "b8860b",
                    xWay: "a9a9a9",
                    xgYF: "6400",
                    xgYy: "a9a9a9",
                    xkhaki: "bdb76b",
                    xmagFta: "8b008b",
                    xTivegYF: "556b2f",
                    xSange: "ff8c00",
                    xScEd: "9932cc",
                    xYd: "8b0000",
                    xsOmon: "e9967a",
                    xsHgYF: "8fbc8f",
                    xUXe: "483d8b",
                    xUWay: "2f4f4f",
                    xUgYy: "2f4f4f",
                    xQe: "ced1",
                    xviTet: "9400d3",
                    dAppRk: "ff1493",
                    dApskyXe: "bfff",
                    dimWay: "696969",
                    dimgYy: "696969",
                    dodgerXe: "1e90ff",
                    fiYbrick: "b22222",
                    flSOwEte: "fffaf0",
                    foYstWAn: "228b22",
                    fuKsia: "ff00ff",
                    gaRsbSo: "dcdcdc",
                    ghostwEte: "f8f8ff",
                    gTd: "ffd700",
                    gTMnPd: "daa520",
                    Way: "808080",
                    gYF: "8000",
                    gYFLw: "adff2f",
                    gYy: "808080",
                    honeyMw: "f0fff0",
                    hotpRk: "ff69b4",
                    RdianYd: "cd5c5c",
                    Rdigo: "4b0082",
                    ivSy: "fffff0",
                    khaki: "f0e68c",
                    lavFMr: "e6e6fa",
                    lavFMrXsh: "fff0f5",
                    lawngYF: "7cfc00",
                    NmoncEffon: "fffacd",
                    ZXe: "add8e6",
                    ZcSO: "f08080",
                    Zcyan: "e0ffff",
                    ZgTMnPdLw: "fafad2",
                    ZWay: "d3d3d3",
                    ZgYF: "90ee90",
                    ZgYy: "d3d3d3",
                    ZpRk: "ffb6c1",
                    ZsOmon: "ffa07a",
                    ZsHgYF: "20b2aa",
                    ZskyXe: "87cefa",
                    ZUWay: "778899",
                    ZUgYy: "778899",
                    ZstAlXe: "b0c4de",
                    ZLw: "ffffe0",
                    lime: "ff00",
                    limegYF: "32cd32",
                    lRF: "faf0e6",
                    magFta: "ff00ff",
                    maPon: "800000",
                    VaquamarRe: "66cdaa",
                    VXe: "cd",
                    VScEd: "ba55d3",
                    VpurpN: "9370db",
                    VsHgYF: "3cb371",
                    VUXe: "7b68ee",
                    VsprRggYF: "fa9a",
                    VQe: "48d1cc",
                    VviTetYd: "c71585",
                    midnightXe: "191970",
                    mRtcYam: "f5fffa",
                    mistyPse: "ffe4e1",
                    moccasR: "ffe4b5",
                    navajowEte: "ffdead",
                    navy: "80",
                    Tdlace: "fdf5e6",
                    Tive: "808000",
                    TivedBb: "6b8e23",
                    Sange: "ffa500",
                    SangeYd: "ff4500",
                    ScEd: "da70d6",
                    pOegTMnPd: "eee8aa",
                    pOegYF: "98fb98",
                    pOeQe: "afeeee",
                    pOeviTetYd: "db7093",
                    papayawEp: "ffefd5",
                    pHKpuff: "ffdab9",
                    peru: "cd853f",
                    pRk: "ffc0cb",
                    plum: "dda0dd",
                    powMrXe: "b0e0e6",
                    purpN: "800080",
                    YbeccapurpN: "663399",
                    Yd: "ff0000",
                    Psybrown: "bc8f8f",
                    PyOXe: "4169e1",
                    saddNbPwn: "8b4513",
                    sOmon: "fa8072",
                    sandybPwn: "f4a460",
                    sHgYF: "2e8b57",
                    sHshell: "fff5ee",
                    siFna: "a0522d",
                    silver: "c0c0c0",
                    skyXe: "87ceeb",
                    UXe: "6a5acd",
                    UWay: "708090",
                    UgYy: "708090",
                    snow: "fffafa",
                    sprRggYF: "ff7f",
                    stAlXe: "4682b4",
                    tan: "d2b48c",
                    teO: "8080",
                    tEstN: "d8bfd8",
                    tomato: "ff6347",
                    Qe: "40e0d0",
                    viTet: "ee82ee",
                    JHt: "f5deb3",
                    wEte: "ffffff",
                    wEtesmoke: "f5f5f5",
                    Lw: "ffff00",
                    LwgYF: "9acd32"
                };
            let Ht;

            function jt(t) {
                Ht || (Ht = function() {
                    const t = {},
                        e = Object.keys(Nt),
                        i = Object.keys(Wt);
                    let s, n, o, a, r;
                    for (s = 0; s < e.length; s++) {
                        for (a = r = e[s], n = 0; n < i.length; n++) o = i[n], r = r.replace(o, Wt[o]);
                        o = parseInt(Nt[a], 16), t[r] = [o >> 16 & 255, o >> 8 & 255, 255 & o]
                    }
                    return t
                }(), Ht.transparent = [0, 0, 0, 0]);
                const e = Ht[t.toLowerCase()];
                return e && {
                    r: e[0],
                    g: e[1],
                    b: e[2],
                    a: 4 === e.length ? e[3] : 255
                }
            }
            const $t = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
            const Yt = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055,
                Ut = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);

            function Xt(t, e, i) {
                if (t) {
                    let s = It(t);
                    s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = Ft(s), t.r = s[0], t.g = s[1], t.b = s[2]
                }
            }

            function qt(t, e) {
                return t ? Object.assign(e || {}, t) : t
            }

            function Kt(t) {
                var e = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 255
                };
                return Array.isArray(t) ? t.length >= 3 && (e = {
                    r: t[0],
                    g: t[1],
                    b: t[2],
                    a: 255
                }, t.length > 3 && (e.a = Mt(t[3]))) : (e = qt(t, {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                })).a = Mt(e.a), e
            }

            function Gt(t) {
                return "r" === t.charAt(0) ? function(t) {
                    const e = $t.exec(t);
                    let i, s, n, o = 255;
                    if (e) {
                        if (e[7] !== i) {
                            const t = +e[7];
                            o = e[8] ? vt(t) : yt(255 * t, 0, 255)
                        }
                        return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? vt(i) : yt(i, 0, 255)), s = 255 & (e[4] ? vt(s) : yt(s, 0, 255)), n = 255 & (e[6] ? vt(n) : yt(n, 0, 255)), {
                            r: i,
                            g: s,
                            b: n,
                            a: o
                        }
                    }
                }(t) : Bt(t)
            }
            class Zt {
                constructor(t) {
                    if (t instanceof Zt) return t;
                    const e = typeof t;
                    let i;
                    var s, n, o;
                    "object" === e ? i = Kt(t) : "string" === e && (o = (s = t).length, "#" === s[0] && (4 === o || 5 === o ? n = {
                        r: 255 & 17 * St[s[1]],
                        g: 255 & 17 * St[s[2]],
                        b: 255 & 17 * St[s[3]],
                        a: 5 === o ? 17 * St[s[4]] : 255
                    } : 7 !== o && 9 !== o || (n = {
                        r: St[s[1]] << 4 | St[s[2]],
                        g: St[s[3]] << 4 | St[s[4]],
                        b: St[s[5]] << 4 | St[s[6]],
                        a: 9 === o ? St[s[7]] << 4 | St[s[8]] : 255
                    })), i = n || jt(t) || Gt(t)), this._rgb = i, this._valid = !!i
                }
                get valid() {
                    return this._valid
                }
                get rgb() {
                    var t = qt(this._rgb);
                    return t && (t.a = wt(t.a)), t
                }
                set rgb(t) {
                    this._rgb = Kt(t)
                }
                rgbString() {
                    return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;
                    var t
                }
                hexString() {
                    return this._valid ? At(this._rgb) : void 0
                }
                hslString() {
                    return this._valid ? function(t) {
                        if (!t) return;
                        const e = It(t),
                            i = e[0],
                            s = kt(e[1]),
                            n = kt(e[2]);
                        return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`
                    }(this._rgb) : void 0
                }
                mix(t, e) {
                    if (t) {
                        const i = this.rgb,
                            s = t.rgb;
                        let n;
                        const o = e === n ? .5 : e,
                            a = 2 * o - 1,
                            r = i.a - s.a,
                            l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;
                        n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i
                    }
                    return this
                }
                interpolate(t, e) {
                    return t && (this._rgb = function(t, e, i) {
                        const s = Ut(wt(t.r)),
                            n = Ut(wt(t.g)),
                            o = Ut(wt(t.b));
                        return {
                            r: Mt(Yt(s + i * (Ut(wt(e.r)) - s))),
                            g: Mt(Yt(n + i * (Ut(wt(e.g)) - n))),
                            b: Mt(Yt(o + i * (Ut(wt(e.b)) - o))),
                            a: t.a + i * (e.a - t.a)
                        }
                    }(this._rgb, t._rgb, e)), this
                }
                clone() {
                    return new Zt(this.rgb)
                }
                alpha(t) {
                    return this._rgb.a = Mt(t), this
                }
                clearer(t) {
                    return this._rgb.a *= 1 - t, this
                }
                greyscale() {
                    const t = this._rgb,
                        e = _t(.3 * t.r + .59 * t.g + .11 * t.b);
                    return t.r = t.g = t.b = e, this
                }
                opaquer(t) {
                    return this._rgb.a *= 1 + t, this
                }
                negate() {
                    const t = this._rgb;
                    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this
                }
                lighten(t) {
                    return Xt(this._rgb, 2, t), this
                }
                darken(t) {
                    return Xt(this._rgb, 2, -t), this
                }
                saturate(t) {
                    return Xt(this._rgb, 1, t), this
                }
                desaturate(t) {
                    return Xt(this._rgb, 1, -t), this
                }
                rotate(t) {
                    return function(t, e) {
                        var i = It(t);
                        i[0] = Vt(i[0] + e), i = Ft(i), t.r = i[0], t.g = i[1], t.b = i[2]
                    }(this._rgb, t), this
                }
            }

            function Jt(t) {
                if (t && "object" == typeof t) {
                    const e = t.toString();
                    return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e
                }
                return !1
            }

            function Qt(t) {
                return Jt(t) ? t : new Zt(t)
            }

            function te(t) {
                return Jt(t) ? t : new Zt(t).saturate(.5).darken(.1).hexString()
            }
            const ee = ["x", "y", "borderWidth", "radius", "tension"],
                ie = ["color", "borderColor", "backgroundColor"];
            const se = new Map;

            function ne(t, e, i) {
                return function(t, e) {
                    e = e || {};
                    const i = t + JSON.stringify(e);
                    let s = se.get(i);
                    return s || (s = new Intl.NumberFormat(t, e), se.set(i, s)), s
                }(e, i).format(t)
            }
            const oe = {
                values: t => n(t) ? t : "" + t,
                numeric(t, e, i) {
                    if (0 === t) return "0";
                    const s = this.chart.options.locale;
                    let n, o = t;
                    if (i.length > 1) {
                        const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
                        (e < 1e-4 || e > 1e15) && (n = "scientific"), o = function(t, e) {
                            let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
                            Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));
                            return i
                        }(t, i)
                    }
                    const a = z(Math.abs(o)),
                        r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0),
                        l = {
                            notation: n,
                            minimumFractionDigits: r,
                            maximumFractionDigits: r
                        };
                    return Object.assign(l, this.options.ticks.format), ne(t, s, l)
                },
                logarithmic(t, e, i) {
                    if (0 === t) return "0";
                    const s = i[e].significand || t / Math.pow(10, Math.floor(z(t)));
                    return [1, 2, 3, 5, 10, 15].includes(s) || e > .8 * i.length ? oe.numeric.call(this, t, e, i) : ""
                }
            };
            var ae = {
                formatters: oe
            };
            const re = Object.create(null),
                le = Object.create(null);

            function he(t, e) {
                if (!e) return t;
                const i = e.split(".");
                for (let e = 0, s = i.length; e < s; ++e) {
                    const s = i[e];
                    t = t[s] || (t[s] = Object.create(null))
                }
                return t
            }

            function ce(t, e, i) {
                return "string" == typeof e ? b(he(t, e), i) : b(he(t, ""), e)
            }
            class de {
                constructor(t, e) {
                    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
                        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                        size: 12,
                        style: "normal",
                        lineHeight: 1.2,
                        weight: null
                    }, this.hover = {}, this.hoverBackgroundColor = (t, e) => te(e.backgroundColor), this.hoverBorderColor = (t, e) => te(e.borderColor), this.hoverColor = (t, e) => te(e.color), this.indexAxis = "x", this.interaction = {
                        mode: "nearest",
                        intersect: !0,
                        includeInvisible: !1
                    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e)
                }
                set(t, e) {
                    return ce(this, t, e)
                }
                get(t) {
                    return he(this, t)
                }
                describe(t, e) {
                    return ce(le, t, e)
                }
                override(t, e) {
                    return ce(re, t, e)
                }
                route(t, e, i, s) {
                    const n = he(this, t),
                        a = he(this, i),
                        r = "_" + e;
                    Object.defineProperties(n, {
                        [r]: {
                            value: n[e],
                            writable: !0
                        },
                        [e]: {
                            enumerable: !0,
                            get() {
                                const t = this[r],
                                    e = a[s];
                                return o(t) ? Object.assign({}, e, t) : l(t, e)
                            },
                            set(t) {
                                this[r] = t
                            }
                        }
                    })
                }
                apply(t) {
                    t.forEach((t => t(this)))
                }
            }
            var ue = new de({
                _scriptable: t => !t.startsWith("on"),
                _indexable: t => "events" !== t,
                hover: {
                    _fallback: "interaction"
                },
                interaction: {
                    _scriptable: !1,
                    _indexable: !1
                }
            }, [function(t) {
                t.set("animation", {
                    delay: void 0,
                    duration: 1e3,
                    easing: "easeOutQuart",
                    fn: void 0,
                    from: void 0,
                    loop: void 0,
                    to: void 0,
                    type: void 0
                }), t.describe("animation", {
                    _fallback: !1,
                    _indexable: !1,
                    _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
                }), t.set("animations", {
                    colors: {
                        type: "color",
                        properties: ie
                    },
                    numbers: {
                        type: "number",
                        properties: ee
                    }
                }), t.describe("animations", {
                    _fallback: "animation"
                }), t.set("transitions", {
                    active: {
                        animation: {
                            duration: 400
                        }
                    },
                    resize: {
                        animation: {
                            duration: 0
                        }
                    },
                    show: {
                        animations: {
                            colors: {
                                from: "transparent"
                            },
                            visible: {
                                type: "boolean",
                                duration: 0
                            }
                        }
                    },
                    hide: {
                        animations: {
                            colors: {
                                to: "transparent"
                            },
                            visible: {
                                type: "boolean",
                                easing: "linear",
                                fn: t => 0 | t
                            }
                        }
                    }
                })
            }, function(t) {
                t.set("layout", {
                    autoPadding: !0,
                    padding: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                })
            }, function(t) {
                t.set("scale", {
                    display: !0,
                    offset: !1,
                    reverse: !1,
                    beginAtZero: !1,
                    bounds: "ticks",
                    clip: !0,
                    grace: 0,
                    grid: {
                        display: !0,
                        lineWidth: 1,
                        drawOnChartArea: !0,
                        drawTicks: !0,
                        tickLength: 8,
                        tickWidth: (t, e) => e.lineWidth,
                        tickColor: (t, e) => e.color,
                        offset: !1
                    },
                    border: {
                        display: !0,
                        dash: [],
                        dashOffset: 0,
                        width: 1
                    },
                    title: {
                        display: !1,
                        text: "",
                        padding: {
                            top: 4,
                            bottom: 4
                        }
                    },
                    ticks: {
                        minRotation: 0,
                        maxRotation: 50,
                        mirror: !1,
                        textStrokeWidth: 0,
                        textStrokeColor: "",
                        padding: 3,
                        display: !0,
                        autoSkip: !0,
                        autoSkipPadding: 3,
                        labelOffset: 0,
                        callback: ae.formatters.values,
                        minor: {},
                        major: {},
                        align: "center",
                        crossAlign: "near",
                        showLabelBackdrop: !1,
                        backdropColor: "rgba(255, 255, 255, 0.75)",
                        backdropPadding: 2
                    }
                }), t.route("scale.ticks", "color", "", "color"), t.route("scale.grid", "color", "", "borderColor"), t.route("scale.border", "color", "", "borderColor"), t.route("scale.title", "color", "", "color"), t.describe("scale", {
                    _fallback: !1,
                    _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
                    _indexable: t => "borderDash" !== t && "tickBorderDash" !== t && "dash" !== t
                }), t.describe("scales", {
                    _fallback: "scale"
                }), t.describe("scale.ticks", {
                    _scriptable: t => "backdropPadding" !== t && "callback" !== t,
                    _indexable: t => "backdropPadding" !== t
                })
            }]);

            function fe() {
                return "undefined" != typeof window && "undefined" != typeof document
            }

            function ge(t) {
                let e = t.parentNode;
                return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
            }

            function pe(t, e, i) {
                let s;
                return "string" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf("%") && (s = s / 100 * e.parentNode[i])) : s = t, s
            }
            const me = t => t.ownerDocument.defaultView.getComputedStyle(t, null);

            function be(t, e) {
                return me(t).getPropertyValue(e)
            }
            const xe = ["top", "right", "bottom", "left"];

            function _e(t, e, i) {
                const s = {};
                i = i ? "-" + i : "";
                for (let n = 0; n < 4; n++) {
                    const o = xe[n];
                    s[o] = parseFloat(t[e + "-" + o + i]) || 0
                }
                return s.width = s.left + s.right, s.height = s.top + s.bottom, s
            }
            const ye = (t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot);

            function ve(t, e) {
                if ("native" in t) return t;
                const {
                    canvas: i,
                    currentDevicePixelRatio: s
                } = e, n = me(i), o = "border-box" === n.boxSizing, a = _e(n, "padding"), r = _e(n, "border", "width"), {
                    x: l,
                    y: h,
                    box: c
                } = function(t, e) {
                    const i = t.touches,
                        s = i && i.length ? i[0] : t,
                        {
                            offsetX: n,
                            offsetY: o
                        } = s;
                    let a, r, l = !1;
                    if (ye(n, o, t.target)) a = n, r = o;
                    else {
                        const t = e.getBoundingClientRect();
                        a = s.clientX - t.left, r = s.clientY - t.top, l = !0
                    }
                    return {
                        x: a,
                        y: r,
                        box: l
                    }
                }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);
                let {
                    width: f,
                    height: g
                } = e;
                return o && (f -= a.width + r.width, g -= a.height + r.height), {
                    x: Math.round((l - d) / f * i.width / s),
                    y: Math.round((h - u) / g * i.height / s)
                }
            }
            const Me = t => Math.round(10 * t) / 10;

            function we(t, e, i, s) {
                const n = me(t),
                    o = _e(n, "margin"),
                    a = pe(n.maxWidth, t, "clientWidth") || T,
                    r = pe(n.maxHeight, t, "clientHeight") || T,
                    l = function(t, e, i) {
                        let s, n;
                        if (void 0 === e || void 0 === i) {
                            const o = ge(t);
                            if (o) {
                                const t = o.getBoundingClientRect(),
                                    a = me(o),
                                    r = _e(a, "border", "width"),
                                    l = _e(a, "padding");
                                e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = pe(a.maxWidth, o, "clientWidth"), n = pe(a.maxHeight, o, "clientHeight")
                            } else e = t.clientWidth, i = t.clientHeight
                        }
                        return {
                            width: e,
                            height: i,
                            maxWidth: s || T,
                            maxHeight: n || T
                        }
                    }(t, e, i);
                let {
                    width: h,
                    height: c
                } = l;
                if ("content-box" === n.boxSizing) {
                    const t = _e(n, "border", "width"),
                        e = _e(n, "padding");
                    h -= e.width + t.width, c -= e.height + t.height
                }
                h = Math.max(0, h - o.width), c = Math.max(0, s ? h / s : c - o.height), h = Me(Math.min(h, a, l.maxWidth)), c = Me(Math.min(c, r, l.maxHeight)), h && !c && (c = Me(h / 2));
                return (void 0 !== e || void 0 !== i) && s && l.height && c > l.height && (c = l.height, h = Me(Math.floor(c * s))), {
                    width: h,
                    height: c
                }
            }

            function ke(t, e, i) {
                const s = e || 1,
                    n = Math.floor(t.height * s),
                    o = Math.floor(t.width * s);
                t.height = Math.floor(t.height), t.width = Math.floor(t.width);
                const a = t.canvas;
                return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0)
            }
            const Se = function() {
                let t = !1;
                try {
                    const e = {get passive() {
                            return t = !0, !1
                        }
                    };
                    fe() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e))
                } catch (t) {}
                return t
            }();

            function Pe(t, e) {
                const i = be(t, e),
                    s = i && i.match(/^(\d+)(\.\d+)?px$/);
                return s ? +s[1] : void 0
            }

            function De(t) {
                return !t || s(t.size) || s(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
            }

            function Ce(t, e, i, s, n) {
                let o = e[n];
                return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s
            }

            function Oe(t, e, i, s) {
                let o = (s = s || {}).data = s.data || {},
                    a = s.garbageCollect = s.garbageCollect || [];
                s.font !== e && (o = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;
                let r = 0;
                const l = i.length;
                let h, c, d, u, f;
                for (h = 0; h < l; h++)
                    if (u = i[h], null == u || n(u)) {
                        if (n(u))
                            for (c = 0, d = u.length; c < d; c++) f = u[c], null == f || n(f) || (r = Ce(t, o, a, r, f))
                    } else r = Ce(t, o, a, r, u);
                t.restore();
                const g = a.length / 2;
                if (g > i.length) {
                    for (h = 0; h < g; h++) delete o[a[h]];
                    a.splice(0, g)
                }
                return r
            }

            function Ae(t, e, i) {
                const s = t.currentDevicePixelRatio,
                    n = 0 !== i ? Math.max(i / 2, .5) : 0;
                return Math.round((e - n) * s) / s + n
            }

            function Te(t, e) {
                (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()
            }

            function Le(t, e, i, s) {
                Ee(t, e, i, s, null)
            }

            function Ee(t, e, i, s, n) {
                let o, a, r, l, h, c, d, u;
                const f = e.pointStyle,
                    g = e.rotation,
                    p = e.radius;
                let m = (g || 0) * L;
                if (f && "object" == typeof f && (o = f.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return t.save(), t.translate(i, s), t.rotate(m), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void t.restore();
                if (!(isNaN(p) || p <= 0)) {
                    switch (t.beginPath(), f) {
                        default: n ? t.ellipse(i, s, n / 2, p, 0, 0, O) : t.arc(i, s, p, 0, O),
                        t.closePath();
                        break;
                        case "triangle":
                                c = n ? n / 2 : p,
                            t.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * p),
                            m += I,
                            t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p),
                            m += I,
                            t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p),
                            t.closePath();
                            break;
                        case "rectRounded":
                                h = .516 * p,
                            l = p - h,
                            a = Math.cos(m + R) * l,
                            d = Math.cos(m + R) * (n ? n / 2 - h : l),
                            r = Math.sin(m + R) * l,
                            u = Math.sin(m + R) * (n ? n / 2 - h : l),
                            t.arc(i - d, s - r, h, m - C, m - E),
                            t.arc(i + u, s - a, h, m - E, m),
                            t.arc(i + d, s + r, h, m, m + E),
                            t.arc(i - u, s + a, h, m + E, m + C),
                            t.closePath();
                            break;
                        case "rect":
                                if (!g) {
                                l = Math.SQRT1_2 * p, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);
                                break
                            }m += R;
                        case "rectRot":
                                d = Math.cos(m) * (n ? n / 2 : p),
                            a = Math.cos(m) * p,
                            r = Math.sin(m) * p,
                            u = Math.sin(m) * (n ? n / 2 : p),
                            t.moveTo(i - d, s - r),
                            t.lineTo(i + u, s - a),
                            t.lineTo(i + d, s + r),
                            t.lineTo(i - u, s + a),
                            t.closePath();
                            break;
                        case "crossRot":
                                m += R;
                        case "cross":
                                d = Math.cos(m) * (n ? n / 2 : p),
                            a = Math.cos(m) * p,
                            r = Math.sin(m) * p,
                            u = Math.sin(m) * (n ? n / 2 : p),
                            t.moveTo(i - d, s - r),
                            t.lineTo(i + d, s + r),
                            t.moveTo(i + u, s - a),
                            t.lineTo(i - u, s + a);
                            break;
                        case "star":
                                d = Math.cos(m) * (n ? n / 2 : p),
                            a = Math.cos(m) * p,
                            r = Math.sin(m) * p,
                            u = Math.sin(m) * (n ? n / 2 : p),
                            t.moveTo(i - d, s - r),
                            t.lineTo(i + d, s + r),
                            t.moveTo(i + u, s - a),
                            t.lineTo(i - u, s + a),
                            m += R,
                            d = Math.cos(m) * (n ? n / 2 : p),
                            a = Math.cos(m) * p,
                            r = Math.sin(m) * p,
                            u = Math.sin(m) * (n ? n / 2 : p),
                            t.moveTo(i - d, s - r),
                            t.lineTo(i + d, s + r),
                            t.moveTo(i + u, s - a),
                            t.lineTo(i - u, s + a);
                            break;
                        case "line":
                                a = n ? n / 2 : Math.cos(m) * p,
                            r = Math.sin(m) * p,
                            t.moveTo(i - a, s - r),
                            t.lineTo(i + a, s + r);
                            break;
                        case "dash":
                                t.moveTo(i, s),
                            t.lineTo(i + Math.cos(m) * (n ? n / 2 : p), s + Math.sin(m) * p);
                            break;
                        case !1:
                                t.closePath()
                    }
                    t.fill(), e.borderWidth > 0 && t.stroke()
                }
            }

            function Re(t, e, i) {
                return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
            }

            function Ie(t, e) {
                t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
            }

            function ze(t) {
                t.restore()
            }

            function Fe(t, e, i, s, n) {
                if (!e) return t.lineTo(i.x, i.y);
                if ("middle" === n) {
                    const s = (e.x + i.x) / 2;
                    t.lineTo(s, e.y), t.lineTo(s, i.y)
                } else "after" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
                t.lineTo(i.x, i.y)
            }

            function Ve(t, e, i, s) {
                if (!e) return t.lineTo(i.x, i.y);
                t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y)
            }

            function Be(t, e, i, s, n) {
                if (n.strikethrough || n.underline) {
                    const o = t.measureText(s),
                        a = e - o.actualBoundingBoxLeft,
                        r = e + o.actualBoundingBoxRight,
                        l = i - o.actualBoundingBoxAscent,
                        h = i + o.actualBoundingBoxDescent,
                        c = n.strikethrough ? (l + h) / 2 : h;
                    t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke()
                }
            }

            function We(t, e) {
                const i = t.fillStyle;
                t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i
            }

            function Ne(t, e, i, o, a, r = {}) {
                const l = n(e) ? e : [e],
                    h = r.strokeWidth > 0 && "" !== r.strokeColor;
                let c, d;
                for (t.save(), t.font = a.string, function(t, e) {
                        e.translation && t.translate(e.translation[0], e.translation[1]), s(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline)
                    }(t, r), c = 0; c < l.length; ++c) d = l[c], r.backdrop && We(t, r.backdrop), h && (r.strokeColor && (t.strokeStyle = r.strokeColor), s(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, i, o, r.maxWidth)), t.fillText(d, i, o, r.maxWidth), Be(t, i, o, d, r), o += Number(a.lineHeight);
                t.restore()
            }

            function He(t, e) {
                const {
                    x: i,
                    y: s,
                    w: n,
                    h: o,
                    radius: a
                } = e;
                t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, 1.5 * C, C, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, C, E, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, E, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -E, !0), t.lineTo(i + a.topLeft, s)
            }

            function je(t, e = [""], i, s, n = (() => t[0])) {
                const o = i || t;
                void 0 === s && (s = ti("_fallback", t));
                const a = {
                    [Symbol.toStringTag]: "Object",
                    _cacheable: !0,
                    _scopes: t,
                    _rootScopes: o,
                    _fallback: s,
                    _getTarget: n,
                    override: i => je([i, ...t], e, o, s)
                };
                return new Proxy(a, {
                    deleteProperty: (e, i) => (delete e[i], delete e._keys, delete t[0][i], !0),
                    get: (i, s) => qe(i, s, (() => function(t, e, i, s) {
                        let n;
                        for (const o of e)
                            if (n = ti(Ue(o, t), i), void 0 !== n) return Xe(t, n) ? Je(i, s, t, n) : n
                    }(s, e, t, i))),
                    getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
                    getPrototypeOf: () => Reflect.getPrototypeOf(t[0]),
                    has: (t, e) => ei(t).includes(e),
                    ownKeys: t => ei(t),
                    set(t, e, i) {
                        const s = t._storage || (t._storage = n());
                        return t[e] = s[e] = i, delete t._keys, !0
                    }
                })
            }

            function $e(t, e, i, s) {
                const a = {
                    _cacheable: !1,
                    _proxy: t,
                    _context: e,
                    _subProxy: i,
                    _stack: new Set,
                    _descriptors: Ye(t, s),
                    setContext: e => $e(t, e, i, s),
                    override: n => $e(t.override(n), e, i, s)
                };
                return new Proxy(a, {
                    deleteProperty: (e, i) => (delete e[i], delete t[i], !0),
                    get: (t, e, i) => qe(t, e, (() => function(t, e, i) {
                        const {
                            _proxy: s,
                            _context: a,
                            _subProxy: r,
                            _descriptors: l
                        } = t;
                        let h = s[e];
                        S(h) && l.isScriptable(e) && (h = function(t, e, i, s) {
                            const {
                                _proxy: n,
                                _context: o,
                                _subProxy: a,
                                _stack: r
                            } = i;
                            if (r.has(t)) throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + t);
                            r.add(t);
                            let l = e(o, a || s);
                            r.delete(t), Xe(t, l) && (l = Je(n._scopes, n, t, l));
                            return l
                        }(e, h, t, i));
                        n(h) && h.length && (h = function(t, e, i, s) {
                            const {
                                _proxy: n,
                                _context: a,
                                _subProxy: r,
                                _descriptors: l
                            } = i;
                            if (void 0 !== a.index && s(t)) return e[a.index % e.length];
                            if (o(e[0])) {
                                const i = e,
                                    s = n._scopes.filter((t => t !== i));
                                e = [];
                                for (const o of i) {
                                    const i = Je(s, n, t, o);
                                    e.push($e(i, a, r && r[t], l))
                                }
                            }
                            return e
                        }(e, h, t, l.isIndexable));
                        Xe(e, h) && (h = $e(h, a, r && r[e], l));
                        return h
                    }(t, e, i))),
                    getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? {
                        enumerable: !0,
                        configurable: !0
                    } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),
                    getPrototypeOf: () => Reflect.getPrototypeOf(t),
                    has: (e, i) => Reflect.has(t, i),
                    ownKeys: () => Reflect.ownKeys(t),
                    set: (e, i, s) => (t[i] = s, delete e[i], !0)
                })
            }

            function Ye(t, e = {
                scriptable: !0,
                indexable: !0
            }) {
                const {
                    _scriptable: i = e.scriptable,
                    _indexable: s = e.indexable,
                    _allKeys: n = e.allKeys
                } = t;
                return {
                    allKeys: n,
                    scriptable: i,
                    indexable: s,
                    isScriptable: S(i) ? i : () => i,
                    isIndexable: S(s) ? s : () => s
                }
            }
            const Ue = (t, e) => t ? t + w(e) : e,
                Xe = (t, e) => o(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);

            function qe(t, e, i) {
                if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];
                const s = i();
                return t[e] = s, s
            }

            function Ke(t, e, i) {
                return S(t) ? t(e, i) : t
            }
            const Ge = (t, e) => !0 === t ? e : "string" == typeof t ? M(e, t) : void 0;

            function Ze(t, e, i, s, n) {
                for (const o of e) {
                    const e = Ge(i, o);
                    if (e) {
                        t.add(e);
                        const o = Ke(e._fallback, i, n);
                        if (void 0 !== o && o !== i && o !== s) return o
                    } else if (!1 === e && void 0 !== s && i !== s) return null
                }
                return !1
            }

            function Je(t, e, i, s) {
                const a = e._rootScopes,
                    r = Ke(e._fallback, i, s),
                    l = [...t, ...a],
                    h = new Set;
                h.add(s);
                let c = Qe(h, l, i, r || i, s);
                return null !== c && ((void 0 === r || r === i || (c = Qe(h, l, r, c, s), null !== c)) && je(Array.from(h), [""], a, r, (() => function(t, e, i) {
                    const s = t._getTarget();
                    e in s || (s[e] = {});
                    const a = s[e];
                    if (n(a) && o(i)) return i;
                    return a || {}
                }(e, i, s))))
            }

            function Qe(t, e, i, s, n) {
                for (; i;) i = Ze(t, e, i, s, n);
                return i
            }

            function ti(t, e) {
                for (const i of e) {
                    if (!i) continue;
                    const e = i[t];
                    if (void 0 !== e) return e
                }
            }

            function ei(t) {
                let e = t._keys;
                return e || (e = t._keys = function(t) {
                    const e = new Set;
                    for (const i of t)
                        for (const t of Object.keys(i).filter((t => !t.startsWith("_")))) e.add(t);
                    return Array.from(e)
                }(t._scopes)), e
            }

            function ii(t, e, i, s) {
                const {
                    iScale: n
                } = t, {
                    key: o = "r"
                } = this._parsing, a = new Array(s);
                let r, l, h, c;
                for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {
                    r: n.parse(M(c, o), h)
                };
                return a
            }
            const si = Number.EPSILON || 1e-14,
                ni = (t, e) => e < t.length && !t[e].skip && t[e],
                oi = t => "x" === t ? "y" : "x";

            function ai(t, e, i, s) {
                const n = t.skip ? e : t,
                    o = e,
                    a = i.skip ? e : i,
                    r = q(o, n),
                    l = q(a, o);
                let h = r / (r + l),
                    c = l / (r + l);
                h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;
                const d = s * h,
                    u = s * c;
                return {
                    previous: {
                        x: o.x - d * (a.x - n.x),
                        y: o.y - d * (a.y - n.y)
                    },
                    next: {
                        x: o.x + u * (a.x - n.x),
                        y: o.y + u * (a.y - n.y)
                    }
                }
            }

            function ri(t, e = "x") {
                const i = oi(e),
                    s = t.length,
                    n = Array(s).fill(0),
                    o = Array(s);
                let a, r, l, h = ni(t, 0);
                for (a = 0; a < s; ++a)
                    if (r = l, l = h, h = ni(t, a + 1), l) {
                        if (h) {
                            const t = h[e] - l[e];
                            n[a] = 0 !== t ? (h[i] - l[i]) / t : 0
                        }
                        o[a] = r ? h ? F(n[a - 1]) !== F(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a]
                    }! function(t, e, i) {
                    const s = t.length;
                    let n, o, a, r, l, h = ni(t, 0);
                    for (let c = 0; c < s - 1; ++c) l = h, h = ni(t, c + 1), l && h && (V(e[c], 0, si) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])))
                }(t, n, o),
                function(t, e, i = "x") {
                    const s = oi(i),
                        n = t.length;
                    let o, a, r, l = ni(t, 0);
                    for (let h = 0; h < n; ++h) {
                        if (a = r, r = l, l = ni(t, h + 1), !r) continue;
                        const n = r[i],
                            c = r[s];
                        a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h])
                    }
                }(t, o, e)
            }

            function li(t, e, i) {
                return Math.max(Math.min(t, i), e)
            }

            function hi(t, e, i, s, n) {
                let o, a, r, l;
                if (e.spanGaps && (t = t.filter((t => !t.skip))), "monotone" === e.cubicInterpolationMode) ri(t, n);
                else {
                    let i = s ? t[t.length - 1] : t[0];
                    for (o = 0, a = t.length; o < a; ++o) r = t[o], l = ai(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r
                }
                e.capBezierPoints && function(t, e) {
                    let i, s, n, o, a, r = Re(t[0], e);
                    for (i = 0, s = t.length; i < s; ++i) a = o, o = r, r = i < s - 1 && Re(t[i + 1], e), o && (n = t[i], a && (n.cp1x = li(n.cp1x, e.left, e.right), n.cp1y = li(n.cp1y, e.top, e.bottom)), r && (n.cp2x = li(n.cp2x, e.left, e.right), n.cp2y = li(n.cp2y, e.top, e.bottom)))
                }(t, i)
            }
            const ci = t => 0 === t || 1 === t,
                di = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i),
                ui = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1,
                fi = {
                    linear: t => t,
                    easeInQuad: t => t * t,
                    easeOutQuad: t => -t * (t - 2),
                    easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
                    easeInCubic: t => t * t * t,
                    easeOutCubic: t => (t -= 1) * t * t + 1,
                    easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
                    easeInQuart: t => t * t * t * t,
                    easeOutQuart: t => -((t -= 1) * t * t * t - 1),
                    easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
                    easeInQuint: t => t * t * t * t * t,
                    easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
                    easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
                    easeInSine: t => 1 - Math.cos(t * E),
                    easeOutSine: t => Math.sin(t * E),
                    easeInOutSine: t => -.5 * (Math.cos(C * t) - 1),
                    easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
                    easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
                    easeInOutExpo: t => ci(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
                    easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
                    easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
                    easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
                    easeInElastic: t => ci(t) ? t : di(t, .075, .3),
                    easeOutElastic: t => ci(t) ? t : ui(t, .075, .3),
                    easeInOutElastic(t) {
                        const e = .1125;
                        return ci(t) ? t : t < .5 ? .5 * di(2 * t, e, .45) : .5 + .5 * ui(2 * t - 1, e, .45)
                    },
                    easeInBack(t) {
                        const e = 1.70158;
                        return t * t * ((e + 1) * t - e)
                    },
                    easeOutBack(t) {
                        const e = 1.70158;
                        return (t -= 1) * t * ((e + 1) * t + e) + 1
                    },
                    easeInOutBack(t) {
                        let e = 1.70158;
                        return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
                    },
                    easeInBounce: t => 1 - fi.easeOutBounce(1 - t),
                    easeOutBounce(t) {
                        const e = 7.5625,
                            i = 2.75;
                        return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375
                    },
                    easeInOutBounce: t => t < .5 ? .5 * fi.easeInBounce(2 * t) : .5 * fi.easeOutBounce(2 * t - 1) + .5
                };

            function gi(t, e, i, s) {
                return {
                    x: t.x + i * (e.x - t.x),
                    y: t.y + i * (e.y - t.y)
                }
            }

            function pi(t, e, i, s) {
                return {
                    x: t.x + i * (e.x - t.x),
                    y: "middle" === s ? i < .5 ? t.y : e.y : "after" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
                }
            }

            function mi(t, e, i, s) {
                const n = {
                        x: t.cp2x,
                        y: t.cp2y
                    },
                    o = {
                        x: e.cp1x,
                        y: e.cp1y
                    },
                    a = gi(t, n, i),
                    r = gi(n, o, i),
                    l = gi(o, e, i),
                    h = gi(a, r, i),
                    c = gi(r, l, i);
                return gi(h, c, i)
            }
            const bi = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
                xi = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;

            function _i(t, e) {
                const i = ("" + t).match(bi);
                if (!i || "normal" === i[1]) return 1.2 * e;
                switch (t = +i[2], i[3]) {
                    case "px":
                        return t;
                    case "%":
                        t /= 100
                }
                return e * t
            }
            const yi = t => +t || 0;

            function vi(t, e) {
                const i = {},
                    s = o(e),
                    n = s ? Object.keys(e) : e,
                    a = o(t) ? s ? i => l(t[i], t[e[i]]) : e => t[e] : () => t;
                for (const t of n) i[t] = yi(a(t));
                return i
            }

            function Mi(t) {
                return vi(t, {
                    top: "y",
                    right: "x",
                    bottom: "y",
                    left: "x"
                })
            }

            function wi(t) {
                return vi(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
            }

            function ki(t) {
                const e = Mi(t);
                return e.width = e.left + e.right, e.height = e.top + e.bottom, e
            }

            function Si(t, e) {
                t = t || {}, e = e || ue.font;
                let i = l(t.size, e.size);
                "string" == typeof i && (i = parseInt(i, 10));
                let s = l(t.style, e.style);
                s && !("" + s).match(xi) && (console.warn('Invalid font style specified: "' + s + '"'), s = void 0);
                const n = {
                    family: l(t.family, e.family),
                    lineHeight: _i(l(t.lineHeight, e.lineHeight), i),
                    size: i,
                    style: s,
                    weight: l(t.weight, e.weight),
                    string: ""
                };
                return n.string = De(n), n
            }

            function Pi(t, e, i, s) {
                let o, a, r, l = !0;
                for (o = 0, a = t.length; o < a; ++o)
                    if (r = t[o], void 0 !== r && (void 0 !== e && "function" == typeof r && (r = r(e), l = !1), void 0 !== i && n(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return s && !l && (s.cacheable = !1), r
            }

            function Di(t, e, i) {
                const {
                    min: s,
                    max: n
                } = t, o = c(e, (n - s) / 2), a = (t, e) => i && 0 === t ? 0 : t + e;
                return {
                    min: a(s, -Math.abs(o)),
                    max: a(n, o)
                }
            }

            function Ci(t, e) {
                return Object.assign(Object.create(t), e)
            }

            function Oi(t, e, i) {
                return t ? function(t, e) {
                    return {
                        x: i => t + t + e - i,
                        setWidth(t) {
                            e = t
                        },
                        textAlign: t => "center" === t ? t : "right" === t ? "left" : "right",
                        xPlus: (t, e) => t - e,
                        leftForLtr: (t, e) => t - e
                    }
                }(e, i) : {
                    x: t => t,
                    setWidth(t) {},
                    textAlign: t => t,
                    xPlus: (t, e) => t + e,
                    leftForLtr: (t, e) => t
                }
            }

            function Ai(t, e) {
                let i, s;
                "ltr" !== e && "rtl" !== e || (i = t.canvas.style, s = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = s)
            }

            function Ti(t, e) {
                void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
            }

            function Li(t) {
                return "angle" === t ? {
                    between: Z,
                    compare: K,
                    normalize: G
                } : {
                    between: tt,
                    compare: (t, e) => t - e,
                    normalize: t => t
                }
            }

            function Ei({
                start: t,
                end: e,
                count: i,
                loop: s,
                style: n
            }) {
                return {
                    start: t % i,
                    end: e % i,
                    loop: s && (e - t + 1) % i == 0,
                    style: n
                }
            }

            function Ri(t, e, i) {
                if (!i) return [t];
                const {
                    property: s,
                    start: n,
                    end: o
                } = i, a = e.length, {
                    compare: r,
                    between: l,
                    normalize: h
                } = Li(s), {
                    start: c,
                    end: d,
                    loop: u,
                    style: f
                } = function(t, e, i) {
                    const {
                        property: s,
                        start: n,
                        end: o
                    } = i, {
                        between: a,
                        normalize: r
                    } = Li(s), l = e.length;
                    let h, c, {
                        start: d,
                        end: u,
                        loop: f
                    } = t;
                    if (f) {
                        for (d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h) d--, u--;
                        d %= l, u %= l
                    }
                    return u < d && (u += l), {
                        start: d,
                        end: u,
                        loop: f,
                        style: t.style
                    }
                }(t, e, i), g = [];
                let p, m, b, x = !1,
                    _ = null;
                const y = () => x || l(n, b, p) && 0 !== r(n, b),
                    v = () => !x || 0 === r(o, p) || l(o, b, p);
                for (let t = c, i = c; t <= d; ++t) m = e[t % a], m.skip || (p = h(m[s]), p !== b && (x = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(Ei({
                    start: _,
                    end: t,
                    loop: u,
                    count: a,
                    style: f
                })), _ = null), i = t, b = p));
                return null !== _ && g.push(Ei({
                    start: _,
                    end: d,
                    loop: u,
                    count: a,
                    style: f
                })), g
            }

            function Ii(t, e) {
                const i = [],
                    s = t.segments;
                for (let n = 0; n < s.length; n++) {
                    const o = Ri(s[n], t.points, e);
                    o.length && i.push(...o)
                }
                return i
            }

            function zi(t, e) {
                const i = t.points,
                    s = t.options.spanGaps,
                    n = i.length;
                if (!n) return [];
                const o = !!t._loop,
                    {
                        start: a,
                        end: r
                    } = function(t, e, i, s) {
                        let n = 0,
                            o = e - 1;
                        if (i && !s)
                            for (; n < e && !t[n].skip;) n++;
                        for (; n < e && t[n].skip;) n++;
                        for (n %= e, i && (o += n); o > n && t[o % e].skip;) o--;
                        return o %= e, {
                            start: n,
                            end: o
                        }
                    }(i, n, o, s);
                if (!0 === s) return Fi(t, [{
                    start: a,
                    end: r,
                    loop: o
                }], i, e);
                return Fi(t, function(t, e, i, s) {
                    const n = t.length,
                        o = [];
                    let a, r = e,
                        l = t[e];
                    for (a = e + 1; a <= i; ++a) {
                        const i = t[a % n];
                        i.skip || i.stop ? l.skip || (s = !1, o.push({
                            start: e % n,
                            end: (a - 1) % n,
                            loop: s
                        }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i
                    }
                    return null !== r && o.push({
                        start: e % n,
                        end: r % n,
                        loop: s
                    }), o
                }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e)
            }

            function Fi(t, e, i, s) {
                return s && s.setContext && i ? function(t, e, i, s) {
                    const n = t._chart.getContext(),
                        o = Vi(t.options),
                        {
                            _datasetIndex: a,
                            options: {
                                spanGaps: r
                            }
                        } = t,
                        l = i.length,
                        h = [];
                    let c = o,
                        d = e[0].start,
                        u = d;

                    function f(t, e, s, n) {
                        const o = r ? -1 : 1;
                        if (t !== e) {
                            for (t += l; i[t % l].skip;) t -= o;
                            for (; i[e % l].skip;) e += o;
                            t % l != e % l && (h.push({
                                start: t % l,
                                end: e % l,
                                loop: s,
                                style: n
                            }), c = n, d = e % l)
                        }
                    }
                    for (const t of e) {
                        d = r ? d : t.start;
                        let e, o = i[d % l];
                        for (u = d + 1; u <= t.end; u++) {
                            const r = i[u % l];
                            e = Vi(s.setContext(Ci(n, {
                                type: "segment",
                                p0: o,
                                p1: r,
                                p0DataIndex: (u - 1) % l,
                                p1DataIndex: u % l,
                                datasetIndex: a
                            }))), Bi(e, c) && f(d, u - 1, t.loop, c), o = r, c = e
                        }
                        d < u - 1 && f(d, u - 1, t.loop, c)
                    }
                    return h
                }(t, e, i, s) : e
            }

            function Vi(t) {
                return {
                    backgroundColor: t.backgroundColor,
                    borderCapStyle: t.borderCapStyle,
                    borderDash: t.borderDash,
                    borderDashOffset: t.borderDashOffset,
                    borderJoinStyle: t.borderJoinStyle,
                    borderWidth: t.borderWidth,
                    borderColor: t.borderColor
                }
            }

            function Bi(t, e) {
                if (!e) return !1;
                const i = [],
                    s = function(t, e) {
                        return Jt(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e
                    };
                return JSON.stringify(t, s) !== JSON.stringify(e, s)
            }
            var Wi = Object.freeze({
                __proto__: null,
                HALF_PI: E,
                INFINITY: T,
                PI: C,
                PITAU: A,
                QUARTER_PI: R,
                RAD_PER_DEG: L,
                TAU: O,
                TWO_THIRDS_PI: I,
                _addGrace: Di,
                _alignPixel: Ae,
                _alignStartEnd: ft,
                _angleBetween: Z,
                _angleDiff: K,
                _arrayUnique: lt,
                _attachContext: $e,
                _bezierCurveTo: Ve,
                _bezierInterpolation: mi,
                _boundSegment: Ri,
                _boundSegments: Ii,
                _capitalize: w,
                _computeSegments: zi,
                _createResolver: je,
                _decimalPlaces: U,
                _deprecated: function(t, e, i, s) {
                    void 0 !== e && console.warn(t + ': "' + i + '" is deprecated. Please use "' + s + '" instead')
                },
                _descriptors: Ye,
                _elementsEqual: f,
                _factorize: W,
                _filterBetween: nt,
                _getParentNode: ge,
                _getStartAndCountOfVisiblePoints: pt,
                _int16Range: Q,
                _isBetween: tt,
                _isClickEvent: D,
                _isDomSupported: fe,
                _isPointInArea: Re,
                _limitValue: J,
                _longestText: Oe,
                _lookup: et,
                _lookupByKey: it,
                _measureText: Ce,
                _merger: m,
                _mergerIf: _,
                _normalizeAngle: G,
                _parseObjectDataRadialScale: ii,
                _pointInLine: gi,
                _readValueToProps: vi,
                _rlookupByKey: st,
                _scaleRangesChanged: mt,
                _setMinAndMaxByKey: j,
                _splitKey: v,
                _steppedInterpolation: pi,
                _steppedLineTo: Fe,
                _textX: gt,
                _toLeftRightCenter: ut,
                _updateBezierControlPoints: hi,
                addRoundedRectPath: He,
                almostEquals: V,
                almostWhole: H,
                callback: d,
                clearCanvas: Te,
                clipArea: Ie,
                clone: g,
                color: Qt,
                createContext: Ci,
                debounce: dt,
                defined: k,
                distanceBetweenPoints: q,
                drawPoint: Le,
                drawPointLegend: Ee,
                each: u,
                easingEffects: fi,
                finiteOrDefault: r,
                fontString: function(t, e, i) {
                    return e + " " + t + "px " + i
                },
                formatNumber: ne,
                getAngleFromPoint: X,
                getHoverColor: te,
                getMaximumSize: we,
                getRelativePosition: ve,
                getRtlAdapter: Oi,
                getStyle: be,
                isArray: n,
                isFinite: a,
                isFunction: S,
                isNullOrUndef: s,
                isNumber: N,
                isObject: o,
                isPatternOrGradient: Jt,
                listenArrayEvents: at,
                log10: z,
                merge: b,
                mergeIf: x,
                niceNum: B,
                noop: e,
                overrideTextDirection: Ai,
                readUsedSize: Pe,
                renderText: Ne,
                requestAnimFrame: ht,
                resolve: Pi,
                resolveObjectKey: M,
                restoreTextDirection: Ti,
                retinaScale: ke,
                setsEqual: P,
                sign: F,
                splineCurve: ai,
                splineCurveMonotone: ri,
                supportsEventListenerOptions: Se,
                throttled: ct,
                toDegrees: Y,
                toDimension: c,
                toFont: Si,
                toFontString: De,
                toLineHeight: _i,
                toPadding: ki,
                toPercentage: h,
                toRadians: $,
                toTRBL: Mi,
                toTRBLCorners: wi,
                uid: i,
                unclipArea: ze,
                unlistenArrayEvents: rt,
                valueOrDefault: l
            });

            function Ni(t, e, i, s) {
                const {
                    controller: n,
                    data: o,
                    _sorted: a
                } = t, r = n._cachedMeta.iScale;
                if (r && e === r.axis && "r" !== e && a && o.length) {
                    const t = r._reversePixels ? st : it;
                    if (!s) return t(o, e, i);
                    if (n._sharedOptions) {
                        const s = o[0],
                            n = "function" == typeof s.getRange && s.getRange(e);
                        if (n) {
                            const s = t(o, e, i - n),
                                a = t(o, e, i + n);
                            return {
                                lo: s.lo,
                                hi: a.hi
                            }
                        }
                    }
                }
                return {
                    lo: 0,
                    hi: o.length - 1
                }
            }

            function Hi(t, e, i, s, n) {
                const o = t.getSortedVisibleDatasetMetas(),
                    a = i[e];
                for (let t = 0, i = o.length; t < i; ++t) {
                    const {
                        index: i,
                        data: r
                    } = o[t], {
                        lo: l,
                        hi: h
                    } = Ni(o[t], e, a, n);
                    for (let t = l; t <= h; ++t) {
                        const e = r[t];
                        e.skip || s(e, i, t)
                    }
                }
            }

            function ji(t, e, i, s, n) {
                const o = [];
                if (!n && !t.isPointInArea(e)) return o;
                return Hi(t, i, e, (function(i, a, r) {
                    (n || Re(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({
                        element: i,
                        datasetIndex: a,
                        index: r
                    })
                }), !0), o
            }

            function $i(t, e, i, s, n, o) {
                let a = [];
                const r = function(t) {
                    const e = -1 !== t.indexOf("x"),
                        i = -1 !== t.indexOf("y");
                    return function(t, s) {
                        const n = e ? Math.abs(t.x - s.x) : 0,
                            o = i ? Math.abs(t.y - s.y) : 0;
                        return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2))
                    }
                }(i);
                let l = Number.POSITIVE_INFINITY;
                return Hi(t, i, e, (function(i, h, c) {
                    const d = i.inRange(e.x, e.y, n);
                    if (s && !d) return;
                    const u = i.getCenterPoint(n);
                    if (!(!!o || t.isPointInArea(u)) && !d) return;
                    const f = r(e, u);
                    f < l ? (a = [{
                        element: i,
                        datasetIndex: h,
                        index: c
                    }], l = f) : f === l && a.push({
                        element: i,
                        datasetIndex: h,
                        index: c
                    })
                })), a
            }

            function Yi(t, e, i, s, n, o) {
                return o || t.isPointInArea(e) ? "r" !== i || s ? $i(t, e, i, s, n, o) : function(t, e, i, s) {
                    let n = [];
                    return Hi(t, i, e, (function(t, i, o) {
                        const {
                            startAngle: a,
                            endAngle: r
                        } = t.getProps(["startAngle", "endAngle"], s), {
                            angle: l
                        } = X(t, {
                            x: e.x,
                            y: e.y
                        });
                        Z(l, a, r) && n.push({
                            element: t,
                            datasetIndex: i,
                            index: o
                        })
                    })), n
                }(t, e, i, n) : []
            }

            function Ui(t, e, i, s, n) {
                const o = [],
                    a = "x" === i ? "inXRange" : "inYRange";
                let r = !1;
                return Hi(t, i, e, ((t, s, l) => {
                    t[a](e[i], n) && (o.push({
                        element: t,
                        datasetIndex: s,
                        index: l
                    }), r = r || t.inRange(e.x, e.y, n))
                })), s && !r ? [] : o
            }
            var Xi = {
                evaluateInteractionItems: Hi,
                modes: {
                    index(t, e, i, s) {
                        const n = ve(e, t),
                            o = i.axis || "x",
                            a = i.includeInvisible || !1,
                            r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a),
                            l = [];
                        return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t => {
                            const e = r[0].index,
                                i = t.data[e];
                            i && !i.skip && l.push({
                                element: i,
                                datasetIndex: t.index,
                                index: e
                            })
                        })), l) : []
                    },
                    dataset(t, e, i, s) {
                        const n = ve(e, t),
                            o = i.axis || "xy",
                            a = i.includeInvisible || !1;
                        let r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a);
                        if (r.length > 0) {
                            const e = r[0].datasetIndex,
                                i = t.getDatasetMeta(e).data;
                            r = [];
                            for (let t = 0; t < i.length; ++t) r.push({
                                element: i[t],
                                datasetIndex: e,
                                index: t
                            })
                        }
                        return r
                    },
                    point: (t, e, i, s) => ji(t, ve(e, t), i.axis || "xy", s, i.includeInvisible || !1),
                    nearest(t, e, i, s) {
                        const n = ve(e, t),
                            o = i.axis || "xy",
                            a = i.includeInvisible || !1;
                        return Yi(t, n, o, i.intersect, s, a)
                    },
                    x: (t, e, i, s) => Ui(t, ve(e, t), "x", i.intersect, s),
                    y: (t, e, i, s) => Ui(t, ve(e, t), "y", i.intersect, s)
                }
            };
            const qi = ["left", "top", "right", "bottom"];

            function Ki(t, e) {
                return t.filter((t => t.pos === e))
            }

            function Gi(t, e) {
                return t.filter((t => -1 === qi.indexOf(t.pos) && t.box.axis === e))
            }

            function Zi(t, e) {
                return t.sort(((t, i) => {
                    const s = e ? i : t,
                        n = e ? t : i;
                    return s.weight === n.weight ? s.index - n.index : s.weight - n.weight
                }))
            }

            function Ji(t, e) {
                const i = function(t) {
                        const e = {};
                        for (const i of t) {
                            const {
                                stack: t,
                                pos: s,
                                stackWeight: n
                            } = i;
                            if (!t || !qi.includes(s)) continue;
                            const o = e[t] || (e[t] = {
                                count: 0,
                                placed: 0,
                                weight: 0,
                                size: 0
                            });
                            o.count++, o.weight += n
                        }
                        return e
                    }(t),
                    {
                        vBoxMaxWidth: s,
                        hBoxMaxHeight: n
                    } = e;
                let o, a, r;
                for (o = 0, a = t.length; o < a; ++o) {
                    r = t[o];
                    const {
                        fullSize: a
                    } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;
                    r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight)
                }
                return i
            }

            function Qi(t, e, i, s) {
                return Math.max(t[i], e[i]) + Math.max(t[s], e[s])
            }

            function ts(t, e) {
                t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)
            }

            function es(t, e, i, s) {
                const {
                    pos: n,
                    box: a
                } = i, r = t.maxPadding;
                if (!o(n)) {
                    i.size && (t[n] -= i.size);
                    const e = s[i.stack] || {
                        size: 0,
                        count: 1
                    };
                    e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[n] += i.size
                }
                a.getPadding && ts(r, a.getPadding());
                const l = Math.max(0, e.outerWidth - Qi(r, t, "left", "right")),
                    h = Math.max(0, e.outerHeight - Qi(r, t, "top", "bottom")),
                    c = l !== t.w,
                    d = h !== t.h;
                return t.w = l, t.h = h, i.horizontal ? {
                    same: c,
                    other: d
                } : {
                    same: d,
                    other: c
                }
            }

            function is(t, e) {
                const i = e.maxPadding;

                function s(t) {
                    const s = {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    };
                    return t.forEach((t => {
                        s[t] = Math.max(e[t], i[t])
                    })), s
                }
                return s(t ? ["left", "right"] : ["top", "bottom"])
            }

            function ss(t, e, i, s) {
                const n = [];
                let o, a, r, l, h, c;
                for (o = 0, a = t.length, h = 0; o < a; ++o) {
                    r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, is(r.horizontal, e));
                    const {
                        same: a,
                        other: d
                    } = es(e, i, r, s);
                    h |= a && n.length, c = c || d, l.fullSize || n.push(r)
                }
                return h && ss(n, e, i, s) || c
            }

            function ns(t, e, i, s, n) {
                t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n
            }

            function os(t, e, i, s) {
                const n = i.padding;
                let {
                    x: o,
                    y: a
                } = e;
                for (const r of t) {
                    const t = r.box,
                        l = s[r.stack] || {
                            count: 1,
                            placed: 0,
                            weight: 1
                        },
                        h = r.stackWeight / l.weight || 1;
                    if (r.horizontal) {
                        const s = e.w * h,
                            o = l.size || t.height;
                        k(l.start) && (a = l.start), t.fullSize ? ns(t, n.left, a, i.outerWidth - n.right - n.left, o) : ns(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom
                    } else {
                        const s = e.h * h,
                            a = l.size || t.width;
                        k(l.start) && (o = l.start), t.fullSize ? ns(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : ns(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right
                    }
                }
                e.x = o, e.y = a
            }
            var as = {
                addBox(t, e) {
                    t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
                        return [{
                            z: 0,
                            draw(t) {
                                e.draw(t)
                            }
                        }]
                    }, t.boxes.push(e)
                },
                removeBox(t, e) {
                    const i = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== i && t.boxes.splice(i, 1)
                },
                configure(t, e, i) {
                    e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight
                },
                update(t, e, i, s) {
                    if (!t) return;
                    const n = ki(t.options.layout.padding),
                        o = Math.max(e - n.width, 0),
                        a = Math.max(i - n.height, 0),
                        r = function(t) {
                            const e = function(t) {
                                    const e = [];
                                    let i, s, n, o, a, r;
                                    for (i = 0, s = (t || []).length; i < s; ++i) n = t[i], ({
                                        position: o,
                                        options: {
                                            stack: a,
                                            stackWeight: r = 1
                                        }
                                    } = n), e.push({
                                        index: i,
                                        box: n,
                                        pos: o,
                                        horizontal: n.isHorizontal(),
                                        weight: n.weight,
                                        stack: a && o + a,
                                        stackWeight: r
                                    });
                                    return e
                                }(t),
                                i = Zi(e.filter((t => t.box.fullSize)), !0),
                                s = Zi(Ki(e, "left"), !0),
                                n = Zi(Ki(e, "right")),
                                o = Zi(Ki(e, "top"), !0),
                                a = Zi(Ki(e, "bottom")),
                                r = Gi(e, "x"),
                                l = Gi(e, "y");
                            return {
                                fullSize: i,
                                leftAndTop: s.concat(o),
                                rightAndBottom: n.concat(l).concat(a).concat(r),
                                chartArea: Ki(e, "chartArea"),
                                vertical: s.concat(n).concat(l),
                                horizontal: o.concat(a).concat(r)
                            }
                        }(t.boxes),
                        l = r.vertical,
                        h = r.horizontal;
                    u(t.boxes, (t => {
                        "function" == typeof t.beforeLayout && t.beforeLayout()
                    }));
                    const c = l.reduce(((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1), 0) || 1,
                        d = Object.freeze({
                            outerWidth: e,
                            outerHeight: i,
                            padding: n,
                            availableWidth: o,
                            availableHeight: a,
                            vBoxMaxWidth: o / 2 / c,
                            hBoxMaxHeight: a / 2
                        }),
                        f = Object.assign({}, n);
                    ts(f, ki(s));
                    const g = Object.assign({
                            maxPadding: f,
                            w: o,
                            h: a,
                            x: n.left,
                            y: n.top
                        }, n),
                        p = Ji(l.concat(h), d);
                    ss(r.fullSize, g, d, p), ss(l, g, d, p), ss(h, g, d, p) && ss(l, g, d, p),
                        function(t) {
                            const e = t.maxPadding;

                            function i(i) {
                                const s = Math.max(e[i] - t[i], 0);
                                return t[i] += s, s
                            }
                            t.y += i("top"), t.x += i("left"), i("right"), i("bottom")
                        }(g), os(r.leftAndTop, g, d, p), g.x += g.w, g.y += g.h, os(r.rightAndBottom, g, d, p), t.chartArea = {
                            left: g.left,
                            top: g.top,
                            right: g.left + g.w,
                            bottom: g.top + g.h,
                            height: g.h,
                            width: g.w
                        }, u(r.chartArea, (e => {
                            const i = e.box;
                            Object.assign(i, t.chartArea), i.update(g.w, g.h, {
                                left: 0,
                                top: 0,
                                right: 0,
                                bottom: 0
                            })
                        }))
                }
            };
            class rs {
                acquireContext(t, e) {}
                releaseContext(t) {
                    return !1
                }
                addEventListener(t, e, i) {}
                removeEventListener(t, e, i) {}
                getDevicePixelRatio() {
                    return 1
                }
                getMaximumSize(t, e, i, s) {
                    return e = Math.max(0, e || t.width), i = i || t.height, {
                        width: e,
                        height: Math.max(0, s ? Math.floor(e / s) : i)
                    }
                }
                isAttached(t) {
                    return !0
                }
                updateConfig(t) {}
            }
            class ls extends rs {
                acquireContext(t) {
                    return t && t.getContext && t.getContext("2d") || null
                }
                updateConfig(t) {
                    t.options.animation = !1
                }
            }
            const hs = "$chartjs",
                cs = {
                    touchstart: "mousedown",
                    touchmove: "mousemove",
                    touchend: "mouseup",
                    pointerenter: "mouseenter",
                    pointerdown: "mousedown",
                    pointermove: "mousemove",
                    pointerup: "mouseup",
                    pointerleave: "mouseout",
                    pointerout: "mouseout"
                },
                ds = t => null === t || "" === t;
            const us = !!Se && {
                passive: !0
            };

            function fs(t, e, i) {
                t && t.canvas && t.canvas.removeEventListener(e, i, us)
            }

            function gs(t, e) {
                for (const i of t)
                    if (i === e || i.contains(e)) return !0
            }

            function ps(t, e, i) {
                const s = t.canvas,
                    n = new MutationObserver((t => {
                        let e = !1;
                        for (const i of t) e = e || gs(i.addedNodes, s), e = e && !gs(i.removedNodes, s);
                        e && i()
                    }));
                return n.observe(document, {
                    childList: !0,
                    subtree: !0
                }), n
            }

            function ms(t, e, i) {
                const s = t.canvas,
                    n = new MutationObserver((t => {
                        let e = !1;
                        for (const i of t) e = e || gs(i.removedNodes, s), e = e && !gs(i.addedNodes, s);
                        e && i()
                    }));
                return n.observe(document, {
                    childList: !0,
                    subtree: !0
                }), n
            }
            const bs = new Map;
            let xs = 0;

            function _s() {
                const t = window.devicePixelRatio;
                t !== xs && (xs = t, bs.forEach(((e, i) => {
                    i.currentDevicePixelRatio !== t && e()
                })))
            }

            function ys(t, e, i) {
                const s = t.canvas,
                    n = s && ge(s);
                if (!n) return;
                const o = ct(((t, e) => {
                        const s = n.clientWidth;
                        i(t, e), s < n.clientWidth && i()
                    }), window),
                    a = new ResizeObserver((t => {
                        const e = t[0],
                            i = e.contentRect.width,
                            s = e.contentRect.height;
                        0 === i && 0 === s || o(i, s)
                    }));
                return a.observe(n),
                    function(t, e) {
                        bs.size || window.addEventListener("resize", _s), bs.set(t, e)
                    }(t, o), a
            }

            function vs(t, e, i) {
                i && i.disconnect(), "resize" === e && function(t) {
                    bs.delete(t), bs.size || window.removeEventListener("resize", _s)
                }(t)
            }

            function Ms(t, e, i) {
                const s = t.canvas,
                    n = ct((e => {
                        null !== t.ctx && i(function(t, e) {
                            const i = cs[t.type] || t.type,
                                {
                                    x: s,
                                    y: n
                                } = ve(t, e);
                            return {
                                type: i,
                                chart: e,
                                native: t,
                                x: void 0 !== s ? s : null,
                                y: void 0 !== n ? n : null
                            }
                        }(e, t))
                    }), t);
                return function(t, e, i) {
                    t && t.addEventListener(e, i, us)
                }(s, e, n), n
            }
            class ws extends rs {
                acquireContext(t, e) {
                    const i = t && t.getContext && t.getContext("2d");
                    return i && i.canvas === t ? (function(t, e) {
                        const i = t.style,
                            s = t.getAttribute("height"),
                            n = t.getAttribute("width");
                        if (t[hs] = {
                                initial: {
                                    height: s,
                                    width: n,
                                    style: {
                                        display: i.display,
                                        height: i.height,
                                        width: i.width
                                    }
                                }
                            }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", ds(n)) {
                            const e = Pe(t, "width");
                            void 0 !== e && (t.width = e)
                        }
                        if (ds(s))
                            if ("" === t.style.height) t.height = t.width / (e || 2);
                            else {
                                const e = Pe(t, "height");
                                void 0 !== e && (t.height = e)
                            }
                    }(t, e), i) : null
                }
                releaseContext(t) {
                    const e = t.canvas;
                    if (!e[hs]) return !1;
                    const i = e[hs].initial;
                    ["height", "width"].forEach((t => {
                        const n = i[t];
                        s(n) ? e.removeAttribute(t) : e.setAttribute(t, n)
                    }));
                    const n = i.style || {};
                    return Object.keys(n).forEach((t => {
                        e.style[t] = n[t]
                    })), e.width = e.width, delete e[hs], !0
                }
                addEventListener(t, e, i) {
                    this.removeEventListener(t, e);
                    const s = t.$proxies || (t.$proxies = {}),
                        n = {
                            attach: ps,
                            detach: ms,
                            resize: ys
                        }[e] || Ms;
                    s[e] = n(t, e, i)
                }
                removeEventListener(t, e) {
                    const i = t.$proxies || (t.$proxies = {}),
                        s = i[e];
                    if (!s) return;
                    ({
                        attach: vs,
                        detach: vs,
                        resize: vs
                    }[e] || fs)(t, e, s), i[e] = void 0
                }
                getDevicePixelRatio() {
                    return window.devicePixelRatio
                }
                getMaximumSize(t, e, i, s) {
                    return we(t, e, i, s)
                }
                isAttached(t) {
                    const e = ge(t);
                    return !(!e || !e.isConnected)
                }
            }

            function ks(t) {
                return !fe() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? ls : ws
            }
            var Ss = Object.freeze({
                __proto__: null,
                BasePlatform: rs,
                BasicPlatform: ls,
                DomPlatform: ws,
                _detectPlatform: ks
            });
            const Ps = "transparent",
                Ds = {
                    boolean: (t, e, i) => i > .5 ? e : t,
                    color(t, e, i) {
                        const s = Qt(t || Ps),
                            n = s.valid && Qt(e || Ps);
                        return n && n.valid ? n.mix(s, i).hexString() : e
                    },
                    number: (t, e, i) => t + (e - t) * i
                };
            class Cs {
                constructor(t, e, i, s) {
                    const n = e[i];
                    s = Pi([t.to, s, n, t.from]);
                    const o = Pi([t.from, n, s]);
                    this._active = !0, this._fn = t.fn || Ds[t.type || typeof o], this._easing = fi[t.easing] || fi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0
                }
                active() {
                    return this._active
                }
                update(t, e, i) {
                    if (this._active) {
                        this._notify(!1);
                        const s = this._target[this._prop],
                            n = i - this._start,
                            o = this._duration - n;
                        this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Pi([t.to, e, s, t.from]), this._from = Pi([t.from, s, e])
                    }
                }
                cancel() {
                    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
                }
                tick(t) {
                    const e = t - this._start,
                        i = this._duration,
                        s = this._prop,
                        n = this._from,
                        o = this._loop,
                        a = this._to;
                    let r;
                    if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);
                    e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r))
                }
                wait() {
                    const t = this._promises || (this._promises = []);
                    return new Promise(((e, i) => {
                        t.push({
                            res: e,
                            rej: i
                        })
                    }))
                }
                _notify(t) {
                    const e = t ? "res" : "rej",
                        i = this._promises || [];
                    for (let t = 0; t < i.length; t++) i[t][e]()
                }
            }
            class Os {
                constructor(t, e) {
                    this._chart = t, this._properties = new Map, this.configure(e)
                }
                configure(t) {
                    if (!o(t)) return;
                    const e = Object.keys(ue.animation),
                        i = this._properties;
                    Object.getOwnPropertyNames(t).forEach((s => {
                        const a = t[s];
                        if (!o(a)) return;
                        const r = {};
                        for (const t of e) r[t] = a[t];
                        (n(a.properties) && a.properties || [s]).forEach((t => {
                            t !== s && i.has(t) || i.set(t, r)
                        }))
                    }))
                }
                _animateOptions(t, e) {
                    const i = e.options,
                        s = function(t, e) {
                            if (!e) return;
                            let i = t.options;
                            if (!i) return void(t.options = e);
                            i.$shared && (t.options = i = Object.assign({}, i, {
                                $shared: !1,
                                $animations: {}
                            }));
                            return i
                        }(t, i);
                    if (!s) return [];
                    const n = this._createAnimations(s, i);
                    return i.$shared && function(t, e) {
                        const i = [],
                            s = Object.keys(e);
                        for (let e = 0; e < s.length; e++) {
                            const n = t[s[e]];
                            n && n.active() && i.push(n.wait())
                        }
                        return Promise.all(i)
                    }(t.options.$animations, i).then((() => {
                        t.options = i
                    }), (() => {})), n
                }
                _createAnimations(t, e) {
                    const i = this._properties,
                        s = [],
                        n = t.$animations || (t.$animations = {}),
                        o = Object.keys(e),
                        a = Date.now();
                    let r;
                    for (r = o.length - 1; r >= 0; --r) {
                        const l = o[r];
                        if ("$" === l.charAt(0)) continue;
                        if ("options" === l) {
                            s.push(...this._animateOptions(t, e));
                            continue
                        }
                        const h = e[l];
                        let c = n[l];
                        const d = i.get(l);
                        if (c) {
                            if (d && c.active()) {
                                c.update(d, h, a);
                                continue
                            }
                            c.cancel()
                        }
                        d && d.duration ? (n[l] = c = new Cs(d, t, l, h), s.push(c)) : t[l] = h
                    }
                    return s
                }
                update(t, e) {
                    if (0 === this._properties.size) return void Object.assign(t, e);
                    const i = this._createAnimations(t, e);
                    return i.length ? (xt.add(this._chart, i), !0) : void 0
                }
            }

            function As(t, e) {
                const i = t && t.options || {},
                    s = i.reverse,
                    n = void 0 === i.min ? e : 0,
                    o = void 0 === i.max ? e : 0;
                return {
                    start: s ? o : n,
                    end: s ? n : o
                }
            }

            function Ts(t, e) {
                const i = [],
                    s = t._getSortedDatasetMetas(e);
                let n, o;
                for (n = 0, o = s.length; n < o; ++n) i.push(s[n].index);
                return i
            }

            function Ls(t, e, i, s = {}) {
                const n = t.keys,
                    o = "single" === s.mode;
                let r, l, h, c;
                if (null !== e) {
                    for (r = 0, l = n.length; r < l; ++r) {
                        if (h = +n[r], h === i) {
                            if (s.all) continue;
                            break
                        }
                        c = t.values[h], a(c) && (o || 0 === e || F(e) === F(c)) && (e += c)
                    }
                    return e
                }
            }

            function Es(t, e) {
                const i = t && t.options.stacked;
                return i || void 0 === i && void 0 !== e.stack
            }

            function Rs(t, e, i) {
                const s = t[e] || (t[e] = {});
                return s[i] || (s[i] = {})
            }

            function Is(t, e, i, s) {
                for (const n of e.getMatchingVisibleMetas(s).reverse()) {
                    const e = t[n.index];
                    if (i && e > 0 || !i && e < 0) return n.index
                }
                return null
            }

            function zs(t, e) {
                const {
                    chart: i,
                    _cachedMeta: s
                } = t, n = i._stacks || (i._stacks = {}), {
                    iScale: o,
                    vScale: a,
                    index: r
                } = s, l = o.axis, h = a.axis, c = function(t, e, i) {
                    return `${t.id}.${e.id}.${i.stack||i.type}`
                }(o, a, s), d = e.length;
                let u;
                for (let t = 0; t < d; ++t) {
                    const i = e[t],
                        {
                            [l]: o,
                            [h]: d
                        } = i;
                    u = (i._stacks || (i._stacks = {}))[h] = Rs(n, c, o), u[r] = d, u._top = Is(u, a, !0, s.type), u._bottom = Is(u, a, !1, s.type);
                    (u._visualValues || (u._visualValues = {}))[r] = d
                }
            }

            function Fs(t, e) {
                const i = t.scales;
                return Object.keys(i).filter((t => i[t].axis === e)).shift()
            }

            function Vs(t, e) {
                const i = t.controller.index,
                    s = t.vScale && t.vScale.axis;
                if (s) {
                    e = e || t._parsed;
                    for (const t of e) {
                        const e = t._stacks;
                        if (!e || void 0 === e[s] || void 0 === e[s][i]) return;
                        delete e[s][i], void 0 !== e[s]._visualValues && void 0 !== e[s]._visualValues[i] && delete e[s]._visualValues[i]
                    }
                }
            }
            const Bs = t => "reset" === t || "none" === t,
                Ws = (t, e) => e ? t : Object.assign({}, t);
            class Ns {
                static defaults = {};
                static datasetElementType = null;
                static dataElementType = null;
                constructor(t, e) {
                    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize()
                }
                initialize() {
                    const t = this._cachedMeta;
                    this.configure(), this.linkScales(), t._stacked = Es(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")
                }
                updateIndex(t) {
                    this.index !== t && Vs(this._cachedMeta), this.index = t
                }
                linkScales() {
                    const t = this.chart,
                        e = this._cachedMeta,
                        i = this.getDataset(),
                        s = (t, e, i, s) => "x" === t ? e : "r" === t ? s : i,
                        n = e.xAxisID = l(i.xAxisID, Fs(t, "x")),
                        o = e.yAxisID = l(i.yAxisID, Fs(t, "y")),
                        a = e.rAxisID = l(i.rAxisID, Fs(t, "r")),
                        r = e.indexAxis,
                        h = e.iAxisID = s(r, n, o, a),
                        c = e.vAxisID = s(r, o, n, a);
                    e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c)
                }
                getDataset() {
                    return this.chart.data.datasets[this.index]
                }
                getMeta() {
                    return this.chart.getDatasetMeta(this.index)
                }
                getScaleForId(t) {
                    return this.chart.scales[t]
                }
                _getOtherScale(t) {
                    const e = this._cachedMeta;
                    return t === e.iScale ? e.vScale : e.iScale
                }
                reset() {
                    this._update("reset")
                }
                _destroy() {
                    const t = this._cachedMeta;
                    this._data && rt(this._data, this), t._stacked && Vs(t)
                }
                _dataCheck() {
                    const t = this.getDataset(),
                        e = t.data || (t.data = []),
                        i = this._data;
                    if (o(e)) this._data = function(t) {
                        const e = Object.keys(t),
                            i = new Array(e.length);
                        let s, n, o;
                        for (s = 0, n = e.length; s < n; ++s) o = e[s], i[s] = {
                            x: o,
                            y: t[o]
                        };
                        return i
                    }(e);
                    else if (i !== e) {
                        if (i) {
                            rt(i, this);
                            const t = this._cachedMeta;
                            Vs(t), t._parsed = []
                        }
                        e && Object.isExtensible(e) && at(e, this), this._syncList = [], this._data = e
                    }
                }
                addElements() {
                    const t = this._cachedMeta;
                    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType)
                }
                buildOrUpdateElements(t) {
                    const e = this._cachedMeta,
                        i = this.getDataset();
                    let s = !1;
                    this._dataCheck();
                    const n = e._stacked;
                    e._stacked = Es(e.vScale, e), e.stack !== i.stack && (s = !0, Vs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && zs(this, e._parsed)
                }
                configure() {
                    const t = this.chart.config,
                        e = t.datasetScopeKeys(this._type),
                        i = t.getOptionScopes(this.getDataset(), e, !0);
                    this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
                }
                parse(t, e) {
                    const {
                        _cachedMeta: i,
                        _data: s
                    } = this, {
                        iScale: a,
                        _stacked: r
                    } = i, l = a.axis;
                    let h, c, d, u = 0 === t && e === s.length || i._sorted,
                        f = t > 0 && i._parsed[t - 1];
                    if (!1 === this._parsing) i._parsed = s, i._sorted = !0, d = s;
                    else {
                        d = n(s[t]) ? this.parseArrayData(i, s, t, e) : o(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);
                        const a = () => null === c[l] || f && c[l] < f[l];
                        for (h = 0; h < e; ++h) i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);
                        i._sorted = u
                    }
                    r && zs(this, d)
                }
                parsePrimitiveData(t, e, i, s) {
                    const {
                        iScale: n,
                        vScale: o
                    } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);
                    let d, u, f;
                    for (d = 0, u = s; d < u; ++d) f = d + i, c[d] = {
                        [a]: h || n.parse(l[f], f),
                        [r]: o.parse(e[f], f)
                    };
                    return c
                }
                parseArrayData(t, e, i, s) {
                    const {
                        xScale: n,
                        yScale: o
                    } = t, a = new Array(s);
                    let r, l, h, c;
                    for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {
                        x: n.parse(c[0], h),
                        y: o.parse(c[1], h)
                    };
                    return a
                }
                parseObjectData(t, e, i, s) {
                    const {
                        xScale: n,
                        yScale: o
                    } = t, {
                        xAxisKey: a = "x",
                        yAxisKey: r = "y"
                    } = this._parsing, l = new Array(s);
                    let h, c, d, u;
                    for (h = 0, c = s; h < c; ++h) d = h + i, u = e[d], l[h] = {
                        x: n.parse(M(u, a), d),
                        y: o.parse(M(u, r), d)
                    };
                    return l
                }
                getParsed(t) {
                    return this._cachedMeta._parsed[t]
                }
                getDataElement(t) {
                    return this._cachedMeta.data[t]
                }
                applyStack(t, e, i) {
                    const s = this.chart,
                        n = this._cachedMeta,
                        o = e[t.axis];
                    return Ls({
                        keys: Ts(s, !0),
                        values: e._stacks[t.axis]._visualValues
                    }, o, n.index, {
                        mode: i
                    })
                }
                updateRangeFromParsed(t, e, i, s) {
                    const n = i[e.axis];
                    let o = null === n ? NaN : n;
                    const a = s && i._stacks[e.axis];
                    s && a && (s.values = a, o = Ls(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)
                }
                getMinMax(t, e) {
                    const i = this._cachedMeta,
                        s = i._parsed,
                        n = i._sorted && t === i.iScale,
                        o = s.length,
                        r = this._getOtherScale(t),
                        l = ((t, e, i) => t && !e.hidden && e._stacked && {
                            keys: Ts(i, !0),
                            values: null
                        })(e, i, this.chart),
                        h = {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        },
                        {
                            min: c,
                            max: d
                        } = function(t) {
                            const {
                                min: e,
                                max: i,
                                minDefined: s,
                                maxDefined: n
                            } = t.getUserBounds();
                            return {
                                min: s ? e : Number.NEGATIVE_INFINITY,
                                max: n ? i : Number.POSITIVE_INFINITY
                            }
                        }(r);
                    let u, f;

                    function g() {
                        f = s[u];
                        const e = f[r.axis];
                        return !a(f[t.axis]) || c > e || d < e
                    }
                    for (u = 0; u < o && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);
                    if (n)
                        for (u = o - 1; u >= 0; --u)
                            if (!g()) {
                                this.updateRangeFromParsed(h, t, f, l);
                                break
                            }
                    return h
                }
                getAllParsedValues(t) {
                    const e = this._cachedMeta._parsed,
                        i = [];
                    let s, n, o;
                    for (s = 0, n = e.length; s < n; ++s) o = e[s][t.axis], a(o) && i.push(o);
                    return i
                }
                getMaxOverflow() {
                    return !1
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        i = e.iScale,
                        s = e.vScale,
                        n = this.getParsed(t);
                    return {
                        label: i ? "" + i.getLabelForValue(n[i.axis]) : "",
                        value: s ? "" + s.getLabelForValue(n[s.axis]) : ""
                    }
                }
                _update(t) {
                    const e = this._cachedMeta;
                    this.update(t || "default"), e._clip = function(t) {
                        let e, i, s, n;
                        return o(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {
                            top: e,
                            right: i,
                            bottom: s,
                            left: n,
                            disabled: !1 === t
                        }
                    }(l(this.options.clip, function(t, e, i) {
                        if (!1 === i) return !1;
                        const s = As(t, i),
                            n = As(e, i);
                        return {
                            top: n.end,
                            right: s.end,
                            bottom: n.start,
                            left: s.start
                        }
                    }(e.xScale, e.yScale, this.getMaxOverflow())))
                }
                update(t) {}
                draw() {
                    const t = this._ctx,
                        e = this.chart,
                        i = this._cachedMeta,
                        s = i.data || [],
                        n = e.chartArea,
                        o = [],
                        a = this._drawStart || 0,
                        r = this._drawCount || s.length - a,
                        l = this.options.drawActiveElementsOnTop;
                    let h;
                    for (i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h) {
                        const e = s[h];
                        e.hidden || (e.active && l ? o.push(e) : e.draw(t, n))
                    }
                    for (h = 0; h < o.length; ++h) o[h].draw(t, n)
                }
                getStyle(t, e) {
                    const i = e ? "active" : "default";
                    return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)
                }
                getContext(t, e, i) {
                    const s = this.getDataset();
                    let n;
                    if (t >= 0 && t < this._cachedMeta.data.length) {
                        const e = this._cachedMeta.data[t];
                        n = e.$context || (e.$context = function(t, e, i) {
                            return Ci(t, {
                                active: !1,
                                dataIndex: e,
                                parsed: void 0,
                                raw: void 0,
                                element: i,
                                index: e,
                                mode: "default",
                                type: "data"
                            })
                        }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t
                    } else n = this.$context || (this.$context = function(t, e) {
                        return Ci(t, {
                            active: !1,
                            dataset: void 0,
                            datasetIndex: e,
                            index: e,
                            mode: "default",
                            type: "dataset"
                        })
                    }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;
                    return n.active = !!e, n.mode = i, n
                }
                resolveDatasetElementOptions(t) {
                    return this._resolveElementOptions(this.datasetElementType.id, t)
                }
                resolveDataElementOptions(t, e) {
                    return this._resolveElementOptions(this.dataElementType.id, e, t)
                }
                _resolveElementOptions(t, e = "default", i) {
                    const s = "active" === e,
                        n = this._cachedDataOpts,
                        o = t + "-" + e,
                        a = n[o],
                        r = this.enableOptionSharing && k(i);
                    if (a) return Ws(a, r);
                    const l = this.chart.config,
                        h = l.datasetElementScopeKeys(this._type, t),
                        c = s ? [`${t}Hover`, "hover", t, ""] : [t, ""],
                        d = l.getOptionScopes(this.getDataset(), h),
                        u = Object.keys(ue.elements[t]),
                        f = l.resolveNamedOptions(d, u, (() => this.getContext(i, s, e)), c);
                    return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ws(f, r))), f
                }
                _resolveAnimations(t, e, i) {
                    const s = this.chart,
                        n = this._cachedDataOpts,
                        o = `animation-${e}`,
                        a = n[o];
                    if (a) return a;
                    let r;
                    if (!1 !== s.options.animation) {
                        const s = this.chart.config,
                            n = s.datasetAnimationScopeKeys(this._type, e),
                            o = s.getOptionScopes(this.getDataset(), n);
                        r = s.createResolver(o, this.getContext(t, i, e))
                    }
                    const l = new Os(s, r && r.animations);
                    return r && r._cacheable && (n[o] = Object.freeze(l)), l
                }
                getSharedOptions(t) {
                    if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
                }
                includeOptions(t, e) {
                    return !e || Bs(t) || this.chart._animationsDisabled
                }
                _getSharedOptions(t, e) {
                    const i = this.resolveDataElementOptions(t, e),
                        s = this._sharedOptions,
                        n = this.getSharedOptions(i),
                        o = this.includeOptions(e, n) || n !== s;
                    return this.updateSharedOptions(n, e, i), {
                        sharedOptions: n,
                        includeOptions: o
                    }
                }
                updateElement(t, e, i, s) {
                    Bs(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i)
                }
                updateSharedOptions(t, e, i) {
                    t && !Bs(e) && this._resolveAnimations(void 0, e).update(t, i)
                }
                _setStyle(t, e, i, s) {
                    t.active = s;
                    const n = this.getStyle(e, s);
                    this._resolveAnimations(e, i, s).update(t, {
                        options: !s && this.getSharedOptions(n) || n
                    })
                }
                removeHoverStyle(t, e, i) {
                    this._setStyle(t, i, "active", !1)
                }
                setHoverStyle(t, e, i) {
                    this._setStyle(t, i, "active", !0)
                }
                _removeDatasetHoverStyle() {
                    const t = this._cachedMeta.dataset;
                    t && this._setStyle(t, void 0, "active", !1)
                }
                _setDatasetHoverStyle() {
                    const t = this._cachedMeta.dataset;
                    t && this._setStyle(t, void 0, "active", !0)
                }
                _resyncElements(t) {
                    const e = this._data,
                        i = this._cachedMeta.data;
                    for (const [t, e, i] of this._syncList) this[t](e, i);
                    this._syncList = [];
                    const s = i.length,
                        n = e.length,
                        o = Math.min(n, s);
                    o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n)
                }
                _insertElements(t, e, i = !0) {
                    const s = this._cachedMeta,
                        n = s.data,
                        o = t + e;
                    let a;
                    const r = t => {
                        for (t.length += e, a = t.length - 1; a >= o; a--) t[a] = t[a - e]
                    };
                    for (r(n), a = t; a < o; ++a) n[a] = new this.dataElementType;
                    this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, "reset")
                }
                updateElements(t, e, i, s) {}
                _removeElements(t, e) {
                    const i = this._cachedMeta;
                    if (this._parsing) {
                        const s = i._parsed.splice(t, e);
                        i._stacked && Vs(i, s)
                    }
                    i.data.splice(t, e)
                }
                _sync(t) {
                    if (this._parsing) this._syncList.push(t);
                    else {
                        const [e, i, s] = t;
                        this[e](i, s)
                    }
                    this.chart._dataChanges.push([this.index, ...t])
                }
                _onDataPush() {
                    const t = arguments.length;
                    this._sync(["_insertElements", this.getDataset().data.length - t, t])
                }
                _onDataPop() {
                    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
                }
                _onDataShift() {
                    this._sync(["_removeElements", 0, 1])
                }
                _onDataSplice(t, e) {
                    e && this._sync(["_removeElements", t, e]);
                    const i = arguments.length - 2;
                    i && this._sync(["_insertElements", t, i])
                }
                _onDataUnshift() {
                    this._sync(["_insertElements", 0, arguments.length])
                }
            }
            class Hs {
                static defaults = {};
                static defaultRoutes = void 0;
                x;
                y;
                active = !1;
                options;
                $animations;
                tooltipPosition(t) {
                    const {
                        x: e,
                        y: i
                    } = this.getProps(["x", "y"], t);
                    return {
                        x: e,
                        y: i
                    }
                }
                hasValue() {
                    return N(this.x) && N(this.y)
                }
                getProps(t, e) {
                    const i = this.$animations;
                    if (!e || !i) return this;
                    const s = {};
                    return t.forEach((t => {
                        s[t] = i[t] && i[t].active() ? i[t]._to : this[t]
                    })), s
                }
            }

            function js(t, e) {
                const i = t.options.ticks,
                    n = function(t) {
                        const e = t.options.offset,
                            i = t._tickSize(),
                            s = t._length / i + (e ? 0 : 1),
                            n = t._maxLength / i;
                        return Math.floor(Math.min(s, n))
                    }(t),
                    o = Math.min(i.maxTicksLimit || n, n),
                    a = i.major.enabled ? function(t) {
                        const e = [];
                        let i, s;
                        for (i = 0, s = t.length; i < s; i++) t[i].major && e.push(i);
                        return e
                    }(e) : [],
                    r = a.length,
                    l = a[0],
                    h = a[r - 1],
                    c = [];
                if (r > o) return function(t, e, i, s) {
                    let n, o = 0,
                        a = i[0];
                    for (s = Math.ceil(s), n = 0; n < t.length; n++) n === a && (e.push(t[n]), o++, a = i[o * s])
                }(e, c, a, r / o), c;
                const d = function(t, e, i) {
                    const s = function(t) {
                            const e = t.length;
                            let i, s;
                            if (e < 2) return !1;
                            for (s = t[0], i = 1; i < e; ++i)
                                if (t[i] - t[i - 1] !== s) return !1;
                            return s
                        }(t),
                        n = e.length / i;
                    if (!s) return Math.max(n, 1);
                    const o = W(s);
                    for (let t = 0, e = o.length - 1; t < e; t++) {
                        const e = o[t];
                        if (e > n) return e
                    }
                    return Math.max(n, 1)
                }(a, e, o);
                if (r > 0) {
                    let t, i;
                    const n = r > 1 ? Math.round((h - l) / (r - 1)) : null;
                    for ($s(e, c, d, s(n) ? 0 : l - n, l), t = 0, i = r - 1; t < i; t++) $s(e, c, d, a[t], a[t + 1]);
                    return $s(e, c, d, h, s(n) ? e.length : h + n), c
                }
                return $s(e, c, d), c
            }

            function $s(t, e, i, s, n) {
                const o = l(s, 0),
                    a = Math.min(l(n, t.length), t.length);
                let r, h, c, d = 0;
                for (i = Math.ceil(i), n && (r = n - s, i = r / Math.floor(r / i)), c = o; c < 0;) d++, c = Math.round(o + d * i);
                for (h = Math.max(o, 0); h < a; h++) h === c && (e.push(t[h]), d++, c = Math.round(o + d * i))
            }
            const Ys = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i,
                Us = (t, e) => Math.min(e || t, t);

            function Xs(t, e) {
                const i = [],
                    s = t.length / e,
                    n = t.length;
                let o = 0;
                for (; o < n; o += s) i.push(t[Math.floor(o)]);
                return i
            }

            function qs(t, e, i) {
                const s = t.ticks.length,
                    n = Math.min(e, s - 1),
                    o = t._startPixel,
                    a = t._endPixel,
                    r = 1e-6;
                let l, h = t.getPixelForTick(n);
                if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h
            }

            function Ks(t) {
                return t.drawTicks ? t.tickLength : 0
            }

            function Gs(t, e) {
                if (!t.display) return 0;
                const i = Si(t.font, e),
                    s = ki(t.padding);
                return (n(t.text) ? t.text.length : 1) * i.lineHeight + s.height
            }

            function Zs(t, e, i) {
                let s = ut(t);
                return (i && "right" !== e || !i && "right" === e) && (s = (t => "left" === t ? "right" : "right" === t ? "left" : t)(s)), s
            }
            class Js extends Hs {
                constructor(t) {
                    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
                }
                init(t) {
                    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax)
                }
                parse(t, e) {
                    return t
                }
                getUserBounds() {
                    let {
                        _userMin: t,
                        _userMax: e,
                        _suggestedMin: i,
                        _suggestedMax: s
                    } = this;
                    return t = r(t, Number.POSITIVE_INFINITY), e = r(e, Number.NEGATIVE_INFINITY), i = r(i, Number.POSITIVE_INFINITY), s = r(s, Number.NEGATIVE_INFINITY), {
                        min: r(t, i),
                        max: r(e, s),
                        minDefined: a(t),
                        maxDefined: a(e)
                    }
                }
                getMinMax(t) {
                    let e, {
                        min: i,
                        max: s,
                        minDefined: n,
                        maxDefined: o
                    } = this.getUserBounds();
                    if (n && o) return {
                        min: i,
                        max: s
                    };
                    const a = this.getMatchingVisibleMetas();
                    for (let r = 0, l = a.length; r < l; ++r) e = a[r].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));
                    return i = o && i > s ? s : i, s = n && i > s ? i : s, {
                        min: r(i, r(s, i)),
                        max: r(s, r(i, s))
                    }
                }
                getPadding() {
                    return {
                        left: this.paddingLeft || 0,
                        top: this.paddingTop || 0,
                        right: this.paddingRight || 0,
                        bottom: this.paddingBottom || 0
                    }
                }
                getTicks() {
                    return this.ticks
                }
                getLabels() {
                    const t = this.chart.data;
                    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
                }
                getLabelItems(t = this.chart.chartArea) {
                    return this._labelItems || (this._labelItems = this._computeLabelItems(t))
                }
                beforeLayout() {
                    this._cache = {}, this._dataLimitsCached = !1
                }
                beforeUpdate() {
                    d(this.options.beforeUpdate, [this])
                }
                update(t, e, i) {
                    const {
                        beginAtZero: s,
                        grace: n,
                        ticks: o
                    } = this.options, a = o.sampleSize;
                    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Di(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
                    const r = a < this.ticks.length;
                    this._convertTicksToLabels(r ? Xs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = js(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
                }
                configure() {
                    let t, e, i = this.options.reverse;
                    this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels
                }
                afterUpdate() {
                    d(this.options.afterUpdate, [this])
                }
                beforeSetDimensions() {
                    d(this.options.beforeSetDimensions, [this])
                }
                setDimensions() {
                    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
                }
                afterSetDimensions() {
                    d(this.options.afterSetDimensions, [this])
                }
                _callHooks(t) {
                    this.chart.notifyPlugins(t, this.getContext()), d(this.options[t], [this])
                }
                beforeDataLimits() {
                    this._callHooks("beforeDataLimits")
                }
                determineDataLimits() {}
                afterDataLimits() {
                    this._callHooks("afterDataLimits")
                }
                beforeBuildTicks() {
                    this._callHooks("beforeBuildTicks")
                }
                buildTicks() {
                    return []
                }
                afterBuildTicks() {
                    this._callHooks("afterBuildTicks")
                }
                beforeTickToLabelConversion() {
                    d(this.options.beforeTickToLabelConversion, [this])
                }
                generateTickLabels(t) {
                    const e = this.options.ticks;
                    let i, s, n;
                    for (i = 0, s = t.length; i < s; i++) n = t[i], n.label = d(e.callback, [n.value, i, t], this)
                }
                afterTickToLabelConversion() {
                    d(this.options.afterTickToLabelConversion, [this])
                }
                beforeCalculateLabelRotation() {
                    d(this.options.beforeCalculateLabelRotation, [this])
                }
                calculateLabelRotation() {
                    const t = this.options,
                        e = t.ticks,
                        i = Us(this.ticks.length, t.ticks.maxTicksLimit),
                        s = e.minRotation || 0,
                        n = e.maxRotation;
                    let o, a, r, l = s;
                    if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void(this.labelRotation = s);
                    const h = this._getLabelSizes(),
                        c = h.widest.width,
                        d = h.highest.height,
                        u = J(this.chart.width - c, 0, this.maxWidth);
                    o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ks(t.grid) - e.padding - Gs(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = Y(Math.min(Math.asin(J((h.highest.height + 6) / o, -1, 1)), Math.asin(J(a / r, -1, 1)) - Math.asin(J(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l
                }
                afterCalculateLabelRotation() {
                    d(this.options.afterCalculateLabelRotation, [this])
                }
                afterAutoSkip() {}
                beforeFit() {
                    d(this.options.beforeFit, [this])
                }
                fit() {
                    const t = {
                            width: 0,
                            height: 0
                        },
                        {
                            chart: e,
                            options: {
                                ticks: i,
                                title: s,
                                grid: n
                            }
                        } = this,
                        o = this._isVisible(),
                        a = this.isHorizontal();
                    if (o) {
                        const o = Gs(s, e.options.font);
                        if (a ? (t.width = this.maxWidth, t.height = Ks(n) + o) : (t.height = this.maxHeight, t.width = Ks(n) + o), i.display && this.ticks.length) {
                            const {
                                first: e,
                                last: s,
                                widest: n,
                                highest: o
                            } = this._getLabelSizes(), r = 2 * i.padding, l = $(this.labelRotation), h = Math.cos(l), c = Math.sin(l);
                            if (a) {
                                const e = i.mirror ? 0 : c * n.width + h * o.height;
                                t.height = Math.min(this.maxHeight, t.height + e + r)
                            } else {
                                const e = i.mirror ? 0 : h * n.width + c * o.height;
                                t.width = Math.min(this.maxWidth, t.width + e + r)
                            }
                            this._calculatePadding(e, s, c, h)
                        }
                    }
                    this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom)
                }
                _calculatePadding(t, e, i, s) {
                    const {
                        ticks: {
                            align: n,
                            padding: o
                        },
                        position: a
                    } = this.options, r = 0 !== this.labelRotation, l = "top" !== a && "x" === this.axis;
                    if (this.isHorizontal()) {
                        const a = this.getPixelForTick(0) - this.left,
                            h = this.right - this.getPixelForTick(this.ticks.length - 1);
                        let c = 0,
                            d = 0;
                        r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : "start" === n ? d = e.width : "end" === n ? c = t.width : "inner" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0)
                    } else {
                        let i = e.height / 2,
                            s = t.height / 2;
                        "start" === n ? (i = 0, s = t.height) : "end" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o
                    }
                }
                _handleMargins() {
                    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
                }
                afterFit() {
                    d(this.options.afterFit, [this])
                }
                isHorizontal() {
                    const {
                        axis: t,
                        position: e
                    } = this.options;
                    return "top" === e || "bottom" === e || "x" === t
                }
                isFullSize() {
                    return this.options.fullSize
                }
                _convertTicksToLabels(t) {
                    let e, i;
                    for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++) s(t[e].label) && (t.splice(e, 1), i--, e--);
                    this.afterTickToLabelConversion()
                }
                _getLabelSizes() {
                    let t = this._labelSizes;
                    if (!t) {
                        const e = this.options.ticks.sampleSize;
                        let i = this.ticks;
                        e < i.length && (i = Xs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit)
                    }
                    return t
                }
                _computeLabelSizes(t, e, i) {
                    const {
                        ctx: o,
                        _longestTextCache: a
                    } = this, r = [], l = [], h = Math.floor(e / Us(e, i));
                    let c, d, f, g, p, m, b, x, _, y, v, M = 0,
                        w = 0;
                    for (c = 0; c < e; c += h) {
                        if (g = t[c].label, p = this._resolveTickFontOptions(c), o.font = m = p.string, b = a[m] = a[m] || {
                                data: {},
                                gc: []
                            }, x = p.lineHeight, _ = y = 0, s(g) || n(g)) {
                            if (n(g))
                                for (d = 0, f = g.length; d < f; ++d) v = g[d], s(v) || n(v) || (_ = Ce(o, b.data, b.gc, _, v), y += x)
                        } else _ = Ce(o, b.data, b.gc, _, g), y = x;
                        r.push(_), l.push(y), M = Math.max(_, M), w = Math.max(y, w)
                    }! function(t, e) {
                        u(t, (t => {
                            const i = t.gc,
                                s = i.length / 2;
                            let n;
                            if (s > e) {
                                for (n = 0; n < s; ++n) delete t.data[i[n]];
                                i.splice(0, s)
                            }
                        }))
                    }(a, e);
                    const k = r.indexOf(M),
                        S = l.indexOf(w),
                        P = t => ({
                            width: r[t] || 0,
                            height: l[t] || 0
                        });
                    return {
                        first: P(0),
                        last: P(e - 1),
                        widest: P(k),
                        highest: P(S),
                        widths: r,
                        heights: l
                    }
                }
                getLabelForValue(t) {
                    return t
                }
                getPixelForValue(t, e) {
                    return NaN
                }
                getValueForPixel(t) {}
                getPixelForTick(t) {
                    const e = this.ticks;
                    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
                }
                getPixelForDecimal(t) {
                    this._reversePixels && (t = 1 - t);
                    const e = this._startPixel + t * this._length;
                    return Q(this._alignToPixels ? Ae(this.chart, e, 0) : e)
                }
                getDecimalForPixel(t) {
                    const e = (t - this._startPixel) / this._length;
                    return this._reversePixels ? 1 - e : e
                }
                getBasePixel() {
                    return this.getPixelForValue(this.getBaseValue())
                }
                getBaseValue() {
                    const {
                        min: t,
                        max: e
                    } = this;
                    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
                }
                getContext(t) {
                    const e = this.ticks || [];
                    if (t >= 0 && t < e.length) {
                        const i = e[t];
                        return i.$context || (i.$context = function(t, e, i) {
                            return Ci(t, {
                                tick: i,
                                index: e,
                                type: "tick"
                            })
                        }(this.getContext(), t, i))
                    }
                    return this.$context || (this.$context = Ci(this.chart.getContext(), {
                        scale: this,
                        type: "scale"
                    }))
                }
                _tickSize() {
                    const t = this.options.ticks,
                        e = $(this.labelRotation),
                        i = Math.abs(Math.cos(e)),
                        s = Math.abs(Math.sin(e)),
                        n = this._getLabelSizes(),
                        o = t.autoSkipPadding || 0,
                        a = n ? n.widest.width + o : 0,
                        r = n ? n.highest.height + o : 0;
                    return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s
                }
                _isVisible() {
                    const t = this.options.display;
                    return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0
                }
                _computeGridLineItems(t) {
                    const e = this.axis,
                        i = this.chart,
                        s = this.options,
                        {
                            grid: n,
                            position: a,
                            border: r
                        } = s,
                        h = n.offset,
                        c = this.isHorizontal(),
                        d = this.ticks.length + (h ? 1 : 0),
                        u = Ks(n),
                        f = [],
                        g = r.setContext(this.getContext()),
                        p = g.display ? g.width : 0,
                        m = p / 2,
                        b = function(t) {
                            return Ae(i, t, p)
                        };
                    let x, _, y, v, M, w, k, S, P, D, C, O;
                    if ("top" === a) x = b(this.bottom), w = this.bottom - u, S = x - m, D = b(t.top) + m, O = t.bottom;
                    else if ("bottom" === a) x = b(this.top), D = t.top, O = b(t.bottom) - m, w = x + m, S = this.top + u;
                    else if ("left" === a) x = b(this.right), M = this.right - u, k = x - m, P = b(t.left) + m, C = t.right;
                    else if ("right" === a) x = b(this.left), P = t.left, C = b(t.right) - m, M = x + m, k = this.left + u;
                    else if ("x" === e) {
                        if ("center" === a) x = b((t.top + t.bottom) / 2 + .5);
                        else if (o(a)) {
                            const t = Object.keys(a)[0],
                                e = a[t];
                            x = b(this.chart.scales[t].getPixelForValue(e))
                        }
                        D = t.top, O = t.bottom, w = x + m, S = w + u
                    } else if ("y" === e) {
                        if ("center" === a) x = b((t.left + t.right) / 2);
                        else if (o(a)) {
                            const t = Object.keys(a)[0],
                                e = a[t];
                            x = b(this.chart.scales[t].getPixelForValue(e))
                        }
                        M = x - m, k = M - u, P = t.left, C = t.right
                    }
                    const A = l(s.ticks.maxTicksLimit, d),
                        T = Math.max(1, Math.ceil(d / A));
                    for (_ = 0; _ < d; _ += T) {
                        const t = this.getContext(_),
                            e = n.setContext(t),
                            s = r.setContext(t),
                            o = e.lineWidth,
                            a = e.color,
                            l = s.dash || [],
                            d = s.dashOffset,
                            u = e.tickWidth,
                            g = e.tickColor,
                            p = e.tickBorderDash || [],
                            m = e.tickBorderDashOffset;
                        y = qs(this, _, h), void 0 !== y && (v = Ae(i, y, o), c ? M = k = P = C = v : w = S = D = O = v, f.push({
                            tx1: M,
                            ty1: w,
                            tx2: k,
                            ty2: S,
                            x1: P,
                            y1: D,
                            x2: C,
                            y2: O,
                            width: o,
                            color: a,
                            borderDash: l,
                            borderDashOffset: d,
                            tickWidth: u,
                            tickColor: g,
                            tickBorderDash: p,
                            tickBorderDashOffset: m
                        }))
                    }
                    return this._ticksLength = d, this._borderValue = x, f
                }
                _computeLabelItems(t) {
                    const e = this.axis,
                        i = this.options,
                        {
                            position: s,
                            ticks: a
                        } = i,
                        r = this.isHorizontal(),
                        l = this.ticks,
                        {
                            align: h,
                            crossAlign: c,
                            padding: d,
                            mirror: u
                        } = a,
                        f = Ks(i.grid),
                        g = f + d,
                        p = u ? -d : g,
                        m = -$(this.labelRotation),
                        b = [];
                    let x, _, y, v, M, w, k, S, P, D, C, O, A = "middle";
                    if ("top" === s) w = this.bottom - p, k = this._getXAxisLabelAlignment();
                    else if ("bottom" === s) w = this.top + p, k = this._getXAxisLabelAlignment();
                    else if ("left" === s) {
                        const t = this._getYAxisLabelAlignment(f);
                        k = t.textAlign, M = t.x
                    } else if ("right" === s) {
                        const t = this._getYAxisLabelAlignment(f);
                        k = t.textAlign, M = t.x
                    } else if ("x" === e) {
                        if ("center" === s) w = (t.top + t.bottom) / 2 + g;
                        else if (o(s)) {
                            const t = Object.keys(s)[0],
                                e = s[t];
                            w = this.chart.scales[t].getPixelForValue(e) + g
                        }
                        k = this._getXAxisLabelAlignment()
                    } else if ("y" === e) {
                        if ("center" === s) M = (t.left + t.right) / 2 - g;
                        else if (o(s)) {
                            const t = Object.keys(s)[0],
                                e = s[t];
                            M = this.chart.scales[t].getPixelForValue(e)
                        }
                        k = this._getYAxisLabelAlignment(f).textAlign
                    }
                    "y" === e && ("start" === h ? A = "top" : "end" === h && (A = "bottom"));
                    const T = this._getLabelSizes();
                    for (x = 0, _ = l.length; x < _; ++x) {
                        y = l[x], v = y.label;
                        const t = a.setContext(this.getContext(x));
                        S = this.getPixelForTick(x) + a.labelOffset, P = this._resolveTickFontOptions(x), D = P.lineHeight, C = n(v) ? v.length : 1;
                        const e = C / 2,
                            i = t.color,
                            o = t.textStrokeColor,
                            h = t.textStrokeWidth;
                        let d, f = k;
                        if (r ? (M = S, "inner" === k && (f = x === _ - 1 ? this.options.reverse ? "left" : "right" : 0 === x ? this.options.reverse ? "right" : "left" : "center"), O = "top" === s ? "near" === c || 0 !== m ? -C * D + D / 2 : "center" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : "near" === c || 0 !== m ? D / 2 : "center" === c ? T.highest.height / 2 - e * D : T.highest.height - C * D, u && (O *= -1), 0 === m || t.showLabelBackdrop || (M += D / 2 * Math.sin(m))) : (w = S, O = (1 - C) * D / 2), t.showLabelBackdrop) {
                            const e = ki(t.backdropPadding),
                                i = T.heights[x],
                                s = T.widths[x];
                            let n = O - e.top,
                                o = 0 - e.left;
                            switch (A) {
                                case "middle":
                                    n -= i / 2;
                                    break;
                                case "bottom":
                                    n -= i
                            }
                            switch (k) {
                                case "center":
                                    o -= s / 2;
                                    break;
                                case "right":
                                    o -= s;
                                    break;
                                case "inner":
                                    x === _ - 1 ? o -= s : x > 0 && (o -= s / 2)
                            }
                            d = {
                                left: o,
                                top: n,
                                width: s + e.width,
                                height: i + e.height,
                                color: t.backdropColor
                            }
                        }
                        b.push({
                            label: v,
                            font: P,
                            textOffset: O,
                            options: {
                                rotation: m,
                                color: i,
                                strokeColor: o,
                                strokeWidth: h,
                                textAlign: f,
                                textBaseline: A,
                                translation: [M, w],
                                backdrop: d
                            }
                        })
                    }
                    return b
                }
                _getXAxisLabelAlignment() {
                    const {
                        position: t,
                        ticks: e
                    } = this.options;
                    if (-$(this.labelRotation)) return "top" === t ? "left" : "right";
                    let i = "center";
                    return "start" === e.align ? i = "left" : "end" === e.align ? i = "right" : "inner" === e.align && (i = "inner"), i
                }
                _getYAxisLabelAlignment(t) {
                    const {
                        position: e,
                        ticks: {
                            crossAlign: i,
                            mirror: s,
                            padding: n
                        }
                    } = this.options, o = t + n, a = this._getLabelSizes().widest.width;
                    let r, l;
                    return "left" === e ? s ? (l = this.right + n, "near" === i ? r = "left" : "center" === i ? (r = "center", l += a / 2) : (r = "right", l += a)) : (l = this.right - o, "near" === i ? r = "right" : "center" === i ? (r = "center", l -= a / 2) : (r = "left", l = this.left)) : "right" === e ? s ? (l = this.left + n, "near" === i ? r = "right" : "center" === i ? (r = "center", l -= a / 2) : (r = "left", l -= a)) : (l = this.left + o, "near" === i ? r = "left" : "center" === i ? (r = "center", l += a / 2) : (r = "right", l = this.right)) : r = "right", {
                        textAlign: r,
                        x: l
                    }
                }
                _computeLabelArea() {
                    if (this.options.ticks.mirror) return;
                    const t = this.chart,
                        e = this.options.position;
                    return "left" === e || "right" === e ? {
                        top: 0,
                        left: this.left,
                        bottom: t.height,
                        right: this.right
                    } : "top" === e || "bottom" === e ? {
                        top: this.top,
                        left: 0,
                        bottom: this.bottom,
                        right: t.width
                    } : void 0
                }
                drawBackground() {
                    const {
                        ctx: t,
                        options: {
                            backgroundColor: e
                        },
                        left: i,
                        top: s,
                        width: n,
                        height: o
                    } = this;
                    e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore())
                }
                getLineWidthForValue(t) {
                    const e = this.options.grid;
                    if (!this._isVisible() || !e.display) return 0;
                    const i = this.ticks.findIndex((e => e.value === t));
                    if (i >= 0) {
                        return e.setContext(this.getContext(i)).lineWidth
                    }
                    return 0
                }
                drawGrid(t) {
                    const e = this.options.grid,
                        i = this.ctx,
                        s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
                    let n, o;
                    const a = (t, e, s) => {
                        s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore())
                    };
                    if (e.display)
                        for (n = 0, o = s.length; n < o; ++n) {
                            const t = s[n];
                            e.drawOnChartArea && a({
                                x: t.x1,
                                y: t.y1
                            }, {
                                x: t.x2,
                                y: t.y2
                            }, t), e.drawTicks && a({
                                x: t.tx1,
                                y: t.ty1
                            }, {
                                x: t.tx2,
                                y: t.ty2
                            }, {
                                color: t.tickColor,
                                width: t.tickWidth,
                                borderDash: t.tickBorderDash,
                                borderDashOffset: t.tickBorderDashOffset
                            })
                        }
                }
                drawBorder() {
                    const {
                        chart: t,
                        ctx: e,
                        options: {
                            border: i,
                            grid: s
                        }
                    } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;
                    if (!o) return;
                    const a = s.setContext(this.getContext(0)).lineWidth,
                        r = this._borderValue;
                    let l, h, c, d;
                    this.isHorizontal() ? (l = Ae(t, this.left, o) - o / 2, h = Ae(t, this.right, a) + a / 2, c = d = r) : (c = Ae(t, this.top, o) - o / 2, d = Ae(t, this.bottom, a) + a / 2, l = h = r), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, d), e.stroke(), e.restore()
                }
                drawLabels(t) {
                    if (!this.options.ticks.display) return;
                    const e = this.ctx,
                        i = this._computeLabelArea();
                    i && Ie(e, i);
                    const s = this.getLabelItems(t);
                    for (const t of s) {
                        const i = t.options,
                            s = t.font;
                        Ne(e, t.label, 0, t.textOffset, s, i)
                    }
                    i && ze(e)
                }
                drawTitle() {
                    const {
                        ctx: t,
                        options: {
                            position: e,
                            title: i,
                            reverse: s
                        }
                    } = this;
                    if (!i.display) return;
                    const a = Si(i.font),
                        r = ki(i.padding),
                        l = i.align;
                    let h = a.lineHeight / 2;
                    "bottom" === e || "center" === e || o(e) ? (h += r.bottom, n(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;
                    const {
                        titleX: c,
                        titleY: d,
                        maxWidth: u,
                        rotation: f
                    } = function(t, e, i, s) {
                        const {
                            top: n,
                            left: a,
                            bottom: r,
                            right: l,
                            chart: h
                        } = t, {
                            chartArea: c,
                            scales: d
                        } = h;
                        let u, f, g, p = 0;
                        const m = r - n,
                            b = l - a;
                        if (t.isHorizontal()) {
                            if (f = ft(s, a, l), o(i)) {
                                const t = Object.keys(i)[0],
                                    s = i[t];
                                g = d[t].getPixelForValue(s) + m - e
                            } else g = "center" === i ? (c.bottom + c.top) / 2 + m - e : Ys(t, i, e);
                            u = l - a
                        } else {
                            if (o(i)) {
                                const t = Object.keys(i)[0],
                                    s = i[t];
                                f = d[t].getPixelForValue(s) - b + e
                            } else f = "center" === i ? (c.left + c.right) / 2 - b + e : Ys(t, i, e);
                            g = ft(s, r, n), p = "left" === i ? -E : E
                        }
                        return {
                            titleX: f,
                            titleY: g,
                            maxWidth: u,
                            rotation: p
                        }
                    }(this, h, e, l);
                    Ne(t, i.text, 0, 0, a, {
                        color: i.color,
                        maxWidth: u,
                        rotation: f,
                        textAlign: Zs(l, e, s),
                        textBaseline: "middle",
                        translation: [c, d]
                    })
                }
                draw(t) {
                    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
                }
                _layers() {
                    const t = this.options,
                        e = t.ticks && t.ticks.z || 0,
                        i = l(t.grid && t.grid.z, -1),
                        s = l(t.border && t.border.z, 0);
                    return this._isVisible() && this.draw === Js.prototype.draw ? [{
                        z: i,
                        draw: t => {
                            this.drawBackground(), this.drawGrid(t), this.drawTitle()
                        }
                    }, {
                        z: s,
                        draw: () => {
                            this.drawBorder()
                        }
                    }, {
                        z: e,
                        draw: t => {
                            this.drawLabels(t)
                        }
                    }] : [{
                        z: e,
                        draw: t => {
                            this.draw(t)
                        }
                    }]
                }
                getMatchingVisibleMetas(t) {
                    const e = this.chart.getSortedVisibleDatasetMetas(),
                        i = this.axis + "AxisID",
                        s = [];
                    let n, o;
                    for (n = 0, o = e.length; n < o; ++n) {
                        const o = e[n];
                        o[i] !== this.id || t && o.type !== t || s.push(o)
                    }
                    return s
                }
                _resolveTickFontOptions(t) {
                    return Si(this.options.ticks.setContext(this.getContext(t)).font)
                }
                _maxDigits() {
                    const t = this._resolveTickFontOptions(0).lineHeight;
                    return (this.isHorizontal() ? this.width : this.height) / t
                }
            }
            class Qs {
                constructor(t, e, i) {
                    this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)
                }
                isForType(t) {
                    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
                }
                register(t) {
                    const e = Object.getPrototypeOf(t);
                    let i;
                    (function(t) {
                        return "id" in t && "defaults" in t
                    })(e) && (i = this.register(e));
                    const s = this.items,
                        n = t.id,
                        o = this.scope + "." + n;
                    if (!n) throw new Error("class does not have id: " + t);
                    return n in s || (s[n] = t, function(t, e, i) {
                        const s = b(Object.create(null), [i ? ue.get(i) : {}, ue.get(e), t.defaults]);
                        ue.set(e, s), t.defaultRoutes && function(t, e) {
                            Object.keys(e).forEach((i => {
                                const s = i.split("."),
                                    n = s.pop(),
                                    o = [t].concat(s).join("."),
                                    a = e[i].split("."),
                                    r = a.pop(),
                                    l = a.join(".");
                                ue.route(o, n, l, r)
                            }))
                        }(e, t.defaultRoutes);
                        t.descriptors && ue.describe(e, t.descriptors)
                    }(t, o, i), this.override && ue.override(t.id, t.overrides)), o
                }
                get(t) {
                    return this.items[t]
                }
                unregister(t) {
                    const e = this.items,
                        i = t.id,
                        s = this.scope;
                    i in e && delete e[i], s && i in ue[s] && (delete ue[s][i], this.override && delete re[i])
                }
            }
            class tn {
                constructor() {
                    this.controllers = new Qs(Ns, "datasets", !0), this.elements = new Qs(Hs, "elements"), this.plugins = new Qs(Object, "plugins"), this.scales = new Qs(Js, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
                }
                add(...t) {
                    this._each("register", t)
                }
                remove(...t) {
                    this._each("unregister", t)
                }
                addControllers(...t) {
                    this._each("register", t, this.controllers)
                }
                addElements(...t) {
                    this._each("register", t, this.elements)
                }
                addPlugins(...t) {
                    this._each("register", t, this.plugins)
                }
                addScales(...t) {
                    this._each("register", t, this.scales)
                }
                getController(t) {
                    return this._get(t, this.controllers, "controller")
                }
                getElement(t) {
                    return this._get(t, this.elements, "element")
                }
                getPlugin(t) {
                    return this._get(t, this.plugins, "plugin")
                }
                getScale(t) {
                    return this._get(t, this.scales, "scale")
                }
                removeControllers(...t) {
                    this._each("unregister", t, this.controllers)
                }
                removeElements(...t) {
                    this._each("unregister", t, this.elements)
                }
                removePlugins(...t) {
                    this._each("unregister", t, this.plugins)
                }
                removeScales(...t) {
                    this._each("unregister", t, this.scales)
                }
                _each(t, e, i) {
                    [...e].forEach((e => {
                        const s = i || this._getRegistryForType(e);
                        i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : u(e, (e => {
                            const s = i || this._getRegistryForType(e);
                            this._exec(t, s, e)
                        }))
                    }))
                }
                _exec(t, e, i) {
                    const s = w(t);
                    d(i["before" + s], [], i), e[t](i), d(i["after" + s], [], i)
                }
                _getRegistryForType(t) {
                    for (let e = 0; e < this._typedRegistries.length; e++) {
                        const i = this._typedRegistries[e];
                        if (i.isForType(t)) return i
                    }
                    return this.plugins
                }
                _get(t, e, i) {
                    const s = e.get(t);
                    if (void 0 === s) throw new Error('"' + t + '" is not a registered ' + i + ".");
                    return s
                }
            }
            var en = new tn;
            class sn {
                constructor() {
                    this._init = []
                }
                notify(t, e, i, s) {
                    "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
                    const n = s ? this._descriptors(t).filter(s) : this._descriptors(t),
                        o = this._notify(n, t, e, i);
                    return "afterDestroy" === e && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), o
                }
                _notify(t, e, i, s) {
                    s = s || {};
                    for (const n of t) {
                        const t = n.plugin;
                        if (!1 === d(t[i], [e, s, n.options], t) && s.cancelable) return !1
                    }
                    return !0
                }
                invalidate() {
                    s(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
                }
                _descriptors(t) {
                    if (this._cache) return this._cache;
                    const e = this._cache = this._createDescriptors(t);
                    return this._notifyStateChanges(t), e
                }
                _createDescriptors(t, e) {
                    const i = t && t.config,
                        s = l(i.options && i.options.plugins, {}),
                        n = function(t) {
                            const e = {},
                                i = [],
                                s = Object.keys(en.plugins.items);
                            for (let t = 0; t < s.length; t++) i.push(en.getPlugin(s[t]));
                            const n = t.plugins || [];
                            for (let t = 0; t < n.length; t++) {
                                const s = n[t]; - 1 === i.indexOf(s) && (i.push(s), e[s.id] = !0)
                            }
                            return {
                                plugins: i,
                                localIds: e
                            }
                        }(i);
                    return !1 !== s || e ? function(t, {
                        plugins: e,
                        localIds: i
                    }, s, n) {
                        const o = [],
                            a = t.getContext();
                        for (const r of e) {
                            const e = r.id,
                                l = nn(s[e], n);
                            null !== l && o.push({
                                plugin: r,
                                options: on(t.config, {
                                    plugin: r,
                                    local: i[e]
                                }, l, a)
                            })
                        }
                        return o
                    }(t, n, s, e) : []
                }
                _notifyStateChanges(t) {
                    const e = this._oldCache || [],
                        i = this._cache,
                        s = (t, e) => t.filter((t => !e.some((e => t.plugin.id === e.plugin.id))));
                    this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start")
                }
            }

            function nn(t, e) {
                return e || !1 !== t ? !0 === t ? {} : t : null
            }

            function on(t, {
                plugin: e,
                local: i
            }, s, n) {
                const o = t.pluginScopeKeys(e),
                    a = t.getOptionScopes(s, o);
                return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [""], {
                    scriptable: !1,
                    indexable: !1,
                    allKeys: !0
                })
            }

            function an(t, e) {
                const i = ue.datasets[t] || {};
                return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
            }

            function rn(t) {
                if ("x" === t || "y" === t || "r" === t) return t
            }

            function ln(t, ...e) {
                if (rn(t)) return t;
                for (const s of e) {
                    const e = s.axis || ("top" === (i = s.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.length > 1 && rn(t[0].toLowerCase());
                    if (e) return e
                }
                var i;
                throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)
            }

            function hn(t, e, i) {
                if (i[e + "AxisID"] === t) return {
                    axis: e
                }
            }

            function cn(t, e) {
                const i = re[t.type] || {
                        scales: {}
                    },
                    s = e.scales || {},
                    n = an(t.type, e),
                    a = Object.create(null);
                return Object.keys(s).forEach((e => {
                    const r = s[e];
                    if (!o(r)) return console.error(`Invalid scale configuration for scale: ${e}`);
                    if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`);
                    const l = ln(e, r, function(t, e) {
                            if (e.data && e.data.datasets) {
                                const i = e.data.datasets.filter((e => e.xAxisID === t || e.yAxisID === t));
                                if (i.length) return hn(t, "x", i[0]) || hn(t, "y", i[0])
                            }
                            return {}
                        }(e, t), ue.scales[r.type]),
                        h = function(t, e) {
                            return t === e ? "_index_" : "_value_"
                        }(l, n),
                        c = i.scales || {};
                    a[e] = x(Object.create(null), [{
                        axis: l
                    }, r, c[l], c[h]])
                })), t.data.datasets.forEach((i => {
                    const n = i.type || t.type,
                        o = i.indexAxis || an(n, e),
                        r = (re[n] || {}).scales || {};
                    Object.keys(r).forEach((t => {
                        const e = function(t, e) {
                                let i = t;
                                return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i
                            }(t, o),
                            n = i[e + "AxisID"] || e;
                        a[n] = a[n] || Object.create(null), x(a[n], [{
                            axis: e
                        }, s[n], r[t]])
                    }))
                })), Object.keys(a).forEach((t => {
                    const e = a[t];
                    x(e, [ue.scales[e.type], ue.scale])
                })), a
            }

            function dn(t) {
                const e = t.options || (t.options = {});
                e.plugins = l(e.plugins, {}), e.scales = cn(t, e)
            }

            function un(t) {
                return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t
            }
            const fn = new Map,
                gn = new Set;

            function pn(t, e) {
                let i = fn.get(t);
                return i || (i = e(), fn.set(t, i), gn.add(i)), i
            }
            const mn = (t, e, i) => {
                const s = M(e, i);
                void 0 !== s && t.add(s)
            };
            class bn {
                constructor(t) {
                    this._config = function(t) {
                        return (t = t || {}).data = un(t.data), dn(t), t
                    }(t), this._scopeCache = new Map, this._resolverCache = new Map
                }
                get platform() {
                    return this._config.platform
                }
                get type() {
                    return this._config.type
                }
                set type(t) {
                    this._config.type = t
                }
                get data() {
                    return this._config.data
                }
                set data(t) {
                    this._config.data = un(t)
                }
                get options() {
                    return this._config.options
                }
                set options(t) {
                    this._config.options = t
                }
                get plugins() {
                    return this._config.plugins
                }
                update() {
                    const t = this._config;
                    this.clearCache(), dn(t)
                }
                clearCache() {
                    this._scopeCache.clear(), this._resolverCache.clear()
                }
                datasetScopeKeys(t) {
                    return pn(t, (() => [
                        [`datasets.${t}`, ""]
                    ]))
                }
                datasetAnimationScopeKeys(t, e) {
                    return pn(`${t}.transition.${e}`, (() => [
                        [`datasets.${t}.transitions.${e}`, `transitions.${e}`],
                        [`datasets.${t}`, ""]
                    ]))
                }
                datasetElementScopeKeys(t, e) {
                    return pn(`${t}-${e}`, (() => [
                        [`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]
                    ]))
                }
                pluginScopeKeys(t) {
                    const e = t.id;
                    return pn(`${this.type}-plugin-${e}`, (() => [
                        [`plugins.${e}`, ...t.additionalOptionScopes || []]
                    ]))
                }
                _cachedScopes(t, e) {
                    const i = this._scopeCache;
                    let s = i.get(t);
                    return s && !e || (s = new Map, i.set(t, s)), s
                }
                getOptionScopes(t, e, i) {
                    const {
                        options: s,
                        type: n
                    } = this, o = this._cachedScopes(t, i), a = o.get(e);
                    if (a) return a;
                    const r = new Set;
                    e.forEach((e => {
                        t && (r.add(t), e.forEach((e => mn(r, t, e)))), e.forEach((t => mn(r, s, t))), e.forEach((t => mn(r, re[n] || {}, t))), e.forEach((t => mn(r, ue, t))), e.forEach((t => mn(r, le, t)))
                    }));
                    const l = Array.from(r);
                    return 0 === l.length && l.push(Object.create(null)), gn.has(e) && o.set(e, l), l
                }
                chartOptionScopes() {
                    const {
                        options: t,
                        type: e
                    } = this;
                    return [t, re[e] || {}, ue.datasets[e] || {}, {
                        type: e
                    }, ue, le]
                }
                resolveNamedOptions(t, e, i, s = [""]) {
                    const o = {
                            $shared: !0
                        },
                        {
                            resolver: a,
                            subPrefixes: r
                        } = xn(this._resolverCache, t, s);
                    let l = a;
                    if (function(t, e) {
                            const {
                                isScriptable: i,
                                isIndexable: s
                            } = Ye(t);
                            for (const o of e) {
                                const e = i(o),
                                    a = s(o),
                                    r = (a || e) && t[o];
                                if (e && (S(r) || _n(r)) || a && n(r)) return !0
                            }
                            return !1
                        }(a, e)) {
                        o.$shared = !1;
                        l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r))
                    }
                    for (const t of e) o[t] = l[t];
                    return o
                }
                createResolver(t, e, i = [""], s) {
                    const {
                        resolver: n
                    } = xn(this._resolverCache, t, i);
                    return o(e) ? $e(n, e, void 0, s) : n
                }
            }

            function xn(t, e, i) {
                let s = t.get(e);
                s || (s = new Map, t.set(e, s));
                const n = i.join();
                let o = s.get(n);
                if (!o) {
                    o = {
                        resolver: je(e, i),
                        subPrefixes: i.filter((t => !t.toLowerCase().includes("hover")))
                    }, s.set(n, o)
                }
                return o
            }
            const _n = t => o(t) && Object.getOwnPropertyNames(t).some((e => S(t[e])));
            const yn = ["top", "bottom", "left", "right", "chartArea"];

            function vn(t, e) {
                return "top" === t || "bottom" === t || -1 === yn.indexOf(t) && "x" === e
            }

            function Mn(t, e) {
                return function(i, s) {
                    return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t]
                }
            }

            function wn(t) {
                const e = t.chart,
                    i = e.options.animation;
                e.notifyPlugins("afterRender"), d(i && i.onComplete, [t], e)
            }

            function kn(t) {
                const e = t.chart,
                    i = e.options.animation;
                d(i && i.onProgress, [t], e)
            }

            function Sn(t) {
                return fe() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t
            }
            const Pn = {},
                Dn = t => {
                    const e = Sn(t);
                    return Object.values(Pn).filter((t => t.canvas === e)).pop()
                };

            function Cn(t, e, i) {
                const s = Object.keys(t);
                for (const n of s) {
                    const s = +n;
                    if (s >= e) {
                        const o = t[n];
                        delete t[n], (i > 0 || s > e) && (t[s + i] = o)
                    }
                }
            }

            function On(t, e, i) {
                return t.options.clip ? t[i] : e[i]
            }
            class An {
                static defaults = ue;
                static instances = Pn;
                static overrides = re;
                static registry = en;
                static version = "4.4.2";
                static getChart = Dn;
                static register(...t) {
                    en.add(...t), Tn()
                }
                static unregister(...t) {
                    en.remove(...t), Tn()
                }
                constructor(t, e) {
                    const s = this.config = new bn(e),
                        n = Sn(t),
                        o = Dn(n);
                    if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
                    const a = s.createResolver(s.chartOptionScopes(), this.getContext());
                    this.platform = new(s.platform || ks(n)), this.platform.updateConfig(s);
                    const r = this.platform.acquireContext(n, a.aspectRatio),
                        l = r && r.canvas,
                        h = l && l.height,
                        c = l && l.width;
                    this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t => this.update(t)), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r && l ? (xt.listen(this, "complete", wn), xt.listen(this, "progress", kn), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
                }
                get aspectRatio() {
                    const {
                        options: {
                            aspectRatio: t,
                            maintainAspectRatio: e
                        },
                        width: i,
                        height: n,
                        _aspectRatio: o
                    } = this;
                    return s(t) ? e && o ? o : n ? i / n : null : t
                }
                get data() {
                    return this.config.data
                }
                set data(t) {
                    this.config.data = t
                }
                get options() {
                    return this._options
                }
                set options(t) {
                    this.config.options = t
                }
                get registry() {
                    return en
                }
                _initialize() {
                    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
                }
                clear() {
                    return Te(this.canvas, this.ctx), this
                }
                stop() {
                    return xt.stop(this), this
                }
                resize(t, e) {
                    xt.running(this) ? this._resizeBeforeDraw = {
                        width: t,
                        height: e
                    } : this._resize(t, e)
                }
                _resize(t, e) {
                    const i = this.options,
                        s = this.canvas,
                        n = i.maintainAspectRatio && this.aspectRatio,
                        o = this.platform.getMaximumSize(s, t, e, n),
                        a = i.devicePixelRatio || this.platform.getDevicePixelRatio(),
                        r = this.width ? "resize" : "attach";
                    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ke(this, a, !0) && (this.notifyPlugins("resize", {
                        size: o
                    }), d(i.onResize, [this, o], this), this.attached && this._doResize(r) && this.render())
                }
                ensureScalesHaveIDs() {
                    u(this.options.scales || {}, ((t, e) => {
                        t.id = e
                    }))
                }
                buildOrUpdateScales() {
                    const t = this.options,
                        e = t.scales,
                        i = this.scales,
                        s = Object.keys(i).reduce(((t, e) => (t[e] = !1, t)), {});
                    let n = [];
                    e && (n = n.concat(Object.keys(e).map((t => {
                        const i = e[t],
                            s = ln(t, i),
                            n = "r" === s,
                            o = "x" === s;
                        return {
                            options: i,
                            dposition: n ? "chartArea" : o ? "bottom" : "left",
                            dtype: n ? "radialLinear" : o ? "category" : "linear"
                        }
                    })))), u(n, (e => {
                        const n = e.options,
                            o = n.id,
                            a = ln(o, n),
                            r = l(n.type, e.dtype);
                        void 0 !== n.position && vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0;
                        let h = null;
                        if (o in i && i[o].type === r) h = i[o];
                        else {
                            h = new(en.getScale(r))({
                                id: o,
                                type: r,
                                ctx: this.ctx,
                                chart: this
                            }), i[h.id] = h
                        }
                        h.init(n, t)
                    })), u(s, ((t, e) => {
                        t || delete i[e]
                    })), u(i, (t => {
                        as.configure(this, t, t.options), as.addBox(this, t)
                    }))
                }
                _updateMetasets() {
                    const t = this._metasets,
                        e = this.data.datasets.length,
                        i = t.length;
                    if (t.sort(((t, e) => t.index - e.index)), i > e) {
                        for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);
                        t.splice(e, i - e)
                    }
                    this._sortedMetasets = t.slice(0).sort(Mn("order", "index"))
                }
                _removeUnreferencedMetasets() {
                    const {
                        _metasets: t,
                        data: {
                            datasets: e
                        }
                    } = this;
                    t.length > e.length && delete this._stacks, t.forEach(((t, i) => {
                        0 === e.filter((e => e === t._dataset)).length && this._destroyDatasetMeta(i)
                    }))
                }
                buildOrUpdateControllers() {
                    const t = [],
                        e = this.data.datasets;
                    let i, s;
                    for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) {
                        const s = e[i];
                        let n = this.getDatasetMeta(i);
                        const o = s.type || this.config.type;
                        if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = "" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();
                        else {
                            const e = en.getController(o),
                                {
                                    datasetElementType: s,
                                    dataElementType: a
                                } = ue.datasets[o];
                            Object.assign(e, {
                                dataElementType: en.getElement(a),
                                datasetElementType: s && en.getElement(s)
                            }), n.controller = new e(this, i), t.push(n.controller)
                        }
                    }
                    return this._updateMetasets(), t
                }
                _resetElements() {
                    u(this.data.datasets, ((t, e) => {
                        this.getDatasetMeta(e).controller.reset()
                    }), this)
                }
                reset() {
                    this._resetElements(), this.notifyPlugins("reset")
                }
                update(t) {
                    const e = this.config;
                    e.update();
                    const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),
                        s = this._animationsDisabled = !i.animation;
                    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
                            mode: t,
                            cancelable: !0
                        })) return;
                    const n = this.buildOrUpdateControllers();
                    this.notifyPlugins("beforeElementsUpdate");
                    let o = 0;
                    for (let t = 0, e = this.data.datasets.length; t < e; t++) {
                        const {
                            controller: e
                        } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);
                        e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o)
                    }
                    o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t => {
                        t.reset()
                    })), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
                        mode: t
                    }), this._layers.sort(Mn("z", "_idx"));
                    const {
                        _active: a,
                        _lastEvent: r
                    } = this;
                    r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render()
                }
                _updateScales() {
                    u(this.scales, (t => {
                        as.removeBox(this, t)
                    })), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
                }
                _checkEventBindings() {
                    const t = this.options,
                        e = new Set(Object.keys(this._listeners)),
                        i = new Set(t.events);
                    P(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents())
                }
                _updateHiddenIndices() {
                    const {
                        _hiddenIndices: t
                    } = this, e = this._getUniformDataChanges() || [];
                    for (const {
                            method: i,
                            start: s,
                            count: n
                        }
                        of e) {
                        Cn(t, s, "_removeElements" === i ? -n : n)
                    }
                }
                _getUniformDataChanges() {
                    const t = this._dataChanges;
                    if (!t || !t.length) return;
                    this._dataChanges = [];
                    const e = this.data.datasets.length,
                        i = e => new Set(t.filter((t => t[0] === e)).map(((t, e) => e + "," + t.splice(1).join(",")))),
                        s = i(0);
                    for (let t = 1; t < e; t++)
                        if (!P(s, i(t))) return;
                    return Array.from(s).map((t => t.split(","))).map((t => ({
                        method: t[1],
                        start: +t[2],
                        count: +t[3]
                    })))
                }
                _updateLayout(t) {
                    if (!1 === this.notifyPlugins("beforeLayout", {
                            cancelable: !0
                        })) return;
                    as.update(this, this.width, this.height, t);
                    const e = this.chartArea,
                        i = e.width <= 0 || e.height <= 0;
                    this._layers = [], u(this.boxes, (t => {
                        i && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()))
                    }), this), this._layers.forEach(((t, e) => {
                        t._idx = e
                    })), this.notifyPlugins("afterLayout")
                }
                _updateDatasets(t) {
                    if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                            mode: t,
                            cancelable: !0
                        })) {
                        for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.configure();
                        for (let e = 0, i = this.data.datasets.length; e < i; ++e) this._updateDataset(e, S(t) ? t({
                            datasetIndex: e
                        }) : t);
                        this.notifyPlugins("afterDatasetsUpdate", {
                            mode: t
                        })
                    }
                }
                _updateDataset(t, e) {
                    const i = this.getDatasetMeta(t),
                        s = {
                            meta: i,
                            index: t,
                            mode: e,
                            cancelable: !0
                        };
                    !1 !== this.notifyPlugins("beforeDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s))
                }
                render() {
                    !1 !== this.notifyPlugins("beforeRender", {
                        cancelable: !0
                    }) && (xt.has(this) ? this.attached && !xt.running(this) && xt.start(this) : (this.draw(), wn({
                        chart: this
                    })))
                }
                draw() {
                    let t;
                    if (this._resizeBeforeDraw) {
                        const {
                            width: t,
                            height: e
                        } = this._resizeBeforeDraw;
                        this._resize(t, e), this._resizeBeforeDraw = null
                    }
                    if (this.clear(), this.width <= 0 || this.height <= 0) return;
                    if (!1 === this.notifyPlugins("beforeDraw", {
                            cancelable: !0
                        })) return;
                    const e = this._layers;
                    for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);
                    for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);
                    this.notifyPlugins("afterDraw")
                }
                _getSortedDatasetMetas(t) {
                    const e = this._sortedMetasets,
                        i = [];
                    let s, n;
                    for (s = 0, n = e.length; s < n; ++s) {
                        const n = e[s];
                        t && !n.visible || i.push(n)
                    }
                    return i
                }
                getSortedVisibleDatasetMetas() {
                    return this._getSortedDatasetMetas(!0)
                }
                _drawDatasets() {
                    if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
                            cancelable: !0
                        })) return;
                    const t = this.getSortedVisibleDatasetMetas();
                    for (let e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);
                    this.notifyPlugins("afterDatasetsDraw")
                }
                _drawDataset(t) {
                    const e = this.ctx,
                        i = t._clip,
                        s = !i.disabled,
                        n = function(t, e) {
                            const {
                                xScale: i,
                                yScale: s
                            } = t;
                            return i && s ? {
                                left: On(i, e, "left"),
                                right: On(i, e, "right"),
                                top: On(s, e, "top"),
                                bottom: On(s, e, "bottom")
                            } : e
                        }(t, this.chartArea),
                        o = {
                            meta: t,
                            index: t.index,
                            cancelable: !0
                        };
                    !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (s && Ie(e, {
                        left: !1 === i.left ? 0 : n.left - i.left,
                        right: !1 === i.right ? this.width : n.right + i.right,
                        top: !1 === i.top ? 0 : n.top - i.top,
                        bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom
                    }), t.controller.draw(), s && ze(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o))
                }
                isPointInArea(t) {
                    return Re(t, this.chartArea, this._minPadding)
                }
                getElementsAtEventForMode(t, e, i, s) {
                    const n = Xi.modes[e];
                    return "function" == typeof n ? n(this, t, i, s) : []
                }
                getDatasetMeta(t) {
                    const e = this.data.datasets[t],
                        i = this._metasets;
                    let s = i.filter((t => t && t._dataset === e)).pop();
                    return s || (s = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: e && e.order || 0,
                        index: t,
                        _dataset: e,
                        _parsed: [],
                        _sorted: !1
                    }, i.push(s)), s
                }
                getContext() {
                    return this.$context || (this.$context = Ci(null, {
                        chart: this,
                        type: "chart"
                    }))
                }
                getVisibleDatasetCount() {
                    return this.getSortedVisibleDatasetMetas().length
                }
                isDatasetVisible(t) {
                    const e = this.data.datasets[t];
                    if (!e) return !1;
                    const i = this.getDatasetMeta(t);
                    return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden
                }
                setDatasetVisibility(t, e) {
                    this.getDatasetMeta(t).hidden = !e
                }
                toggleDataVisibility(t) {
                    this._hiddenIndices[t] = !this._hiddenIndices[t]
                }
                getDataVisibility(t) {
                    return !this._hiddenIndices[t]
                }
                _updateVisibility(t, e, i) {
                    const s = i ? "show" : "hide",
                        n = this.getDatasetMeta(t),
                        o = n.controller._resolveAnimations(void 0, s);
                    k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {
                        visible: i
                    }), this.update((e => e.datasetIndex === t ? s : void 0)))
                }
                hide(t, e) {
                    this._updateVisibility(t, e, !1)
                }
                show(t, e) {
                    this._updateVisibility(t, e, !0)
                }
                _destroyDatasetMeta(t) {
                    const e = this._metasets[t];
                    e && e.controller && e.controller._destroy(), delete this._metasets[t]
                }
                _stop() {
                    let t, e;
                    for (this.stop(), xt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t)
                }
                destroy() {
                    this.notifyPlugins("beforeDestroy");
                    const {
                        canvas: t,
                        ctx: e
                    } = this;
                    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins("afterDestroy")
                }
                toBase64Image(...t) {
                    return this.canvas.toDataURL(...t)
                }
                bindEvents() {
                    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
                }
                bindUserEvents() {
                    const t = this._listeners,
                        e = this.platform,
                        i = (i, s) => {
                            e.addEventListener(this, i, s), t[i] = s
                        },
                        s = (t, e, i) => {
                            t.offsetX = e, t.offsetY = i, this._eventHandler(t)
                        };
                    u(this.options.events, (t => i(t, s)))
                }
                bindResponsiveEvents() {
                    this._responsiveListeners || (this._responsiveListeners = {});
                    const t = this._responsiveListeners,
                        e = this.platform,
                        i = (i, s) => {
                            e.addEventListener(this, i, s), t[i] = s
                        },
                        s = (i, s) => {
                            t[i] && (e.removeEventListener(this, i, s), delete t[i])
                        },
                        n = (t, e) => {
                            this.canvas && this.resize(t, e)
                        };
                    let o;
                    const a = () => {
                        s("attach", a), this.attached = !0, this.resize(), i("resize", n), i("detach", o)
                    };
                    o = () => {
                        this.attached = !1, s("resize", n), this._stop(), this._resize(0, 0), i("attach", a)
                    }, e.isAttached(this.canvas) ? a() : o()
                }
                unbindEvents() {
                    u(this._listeners, ((t, e) => {
                        this.platform.removeEventListener(this, e, t)
                    })), this._listeners = {}, u(this._responsiveListeners, ((t, e) => {
                        this.platform.removeEventListener(this, e, t)
                    })), this._responsiveListeners = void 0
                }
                updateHoverStyle(t, e, i) {
                    const s = i ? "set" : "remove";
                    let n, o, a, r;
                    for ("dataset" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + s + "DatasetHoverStyle"]()), a = 0, r = t.length; a < r; ++a) {
                        o = t[a];
                        const e = o && this.getDatasetMeta(o.datasetIndex).controller;
                        e && e[s + "HoverStyle"](o.element, o.datasetIndex, o.index)
                    }
                }
                getActiveElements() {
                    return this._active || []
                }
                setActiveElements(t) {
                    const e = this._active || [],
                        i = t.map((({
                            datasetIndex: t,
                            index: e
                        }) => {
                            const i = this.getDatasetMeta(t);
                            if (!i) throw new Error("No dataset found at index " + t);
                            return {
                                datasetIndex: t,
                                element: i.data[e],
                                index: e
                            }
                        }));
                    !f(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e))
                }
                notifyPlugins(t, e, i) {
                    return this._plugins.notify(this, t, e, i)
                }
                isPluginEnabled(t) {
                    return 1 === this._plugins._cache.filter((e => e.plugin.id === t)).length
                }
                _updateHoverStyles(t, e, i) {
                    const s = this.options.hover,
                        n = (t, e) => t.filter((t => !e.some((e => t.datasetIndex === e.datasetIndex && t.index === e.index)))),
                        o = n(e, t),
                        a = i ? t : n(t, e);
                    o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0)
                }
                _eventHandler(t, e) {
                    const i = {
                            event: t,
                            replay: e,
                            cancelable: !0,
                            inChartArea: this.isPointInArea(t)
                        },
                        s = e => (e.options.events || this.options.events).includes(t.native.type);
                    if (!1 === this.notifyPlugins("beforeEvent", i, s)) return;
                    const n = this._handleEvent(t, e, i.inChartArea);
                    return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (n || i.changed) && this.render(), this
                }
                _handleEvent(t, e, i) {
                    const {
                        _active: s = [],
                        options: n
                    } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function(t, e, i, s) {
                        return i && "mouseout" !== t.type ? s ? e : t : null
                    }(t, this._lastEvent, i, r);
                    i && (this._lastEvent = null, d(n.onHover, [t, a, this], this), r && d(n.onClick, [t, a, this], this));
                    const h = !f(a, s);
                    return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h
                }
                _getActiveElements(t, e, i, s) {
                    if ("mouseout" === t.type) return [];
                    if (!i) return e;
                    const n = this.options.hover;
                    return this.getElementsAtEventForMode(t, n.mode, n, s)
                }
            }

            function Tn() {
                return u(An.instances, (t => t._plugins.invalidate()))
            }

            function Ln() {
                throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
            }
            class En {
                static override(t) {
                    Object.assign(En.prototype, t)
                }
                options;
                constructor(t) {
                    this.options = t || {}
                }
                init() {}
                formats() {
                    return Ln()
                }
                parse() {
                    return Ln()
                }
                format() {
                    return Ln()
                }
                add() {
                    return Ln()
                }
                diff() {
                    return Ln()
                }
                startOf() {
                    return Ln()
                }
                endOf() {
                    return Ln()
                }
            }
            var Rn = {
                _date: En
            };

            function In(t) {
                const e = t.iScale,
                    i = function(t, e) {
                        if (!t._cache.$bar) {
                            const i = t.getMatchingVisibleMetas(e);
                            let s = [];
                            for (let e = 0, n = i.length; e < n; e++) s = s.concat(i[e].controller.getAllParsedValues(t));
                            t._cache.$bar = lt(s.sort(((t, e) => t - e)))
                        }
                        return t._cache.$bar
                    }(e, t.type);
                let s, n, o, a, r = e._length;
                const l = () => {
                    32767 !== o && -32768 !== o && (k(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o)
                };
                for (s = 0, n = i.length; s < n; ++s) o = e.getPixelForValue(i[s]), l();
                for (a = void 0, s = 0, n = e.ticks.length; s < n; ++s) o = e.getPixelForTick(s), l();
                return r
            }

            function zn(t, e, i, s) {
                return n(t) ? function(t, e, i, s) {
                    const n = i.parse(t[0], s),
                        o = i.parse(t[1], s),
                        a = Math.min(n, o),
                        r = Math.max(n, o);
                    let l = a,
                        h = r;
                    Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {
                        barStart: l,
                        barEnd: h,
                        start: n,
                        end: o,
                        min: a,
                        max: r
                    }
                }(t, e, i, s) : e[i.axis] = i.parse(t, s), e
            }

            function Fn(t, e, i, s) {
                const n = t.iScale,
                    o = t.vScale,
                    a = n.getLabels(),
                    r = n === o,
                    l = [];
                let h, c, d, u;
                for (h = i, c = i + s; h < c; ++h) u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(zn(u, d, o, h));
                return l
            }

            function Vn(t) {
                return t && void 0 !== t.barStart && void 0 !== t.barEnd
            }

            function Bn(t, e, i, s) {
                let n = e.borderSkipped;
                const o = {};
                if (!n) return void(t.borderSkipped = o);
                if (!0 === n) return void(t.borderSkipped = {
                    top: !0,
                    right: !0,
                    bottom: !0,
                    left: !0
                });
                const {
                    start: a,
                    end: r,
                    reverse: l,
                    top: h,
                    bottom: c
                } = function(t) {
                    let e, i, s, n, o;
                    return t.horizontal ? (e = t.base > t.x, i = "left", s = "right") : (e = t.base < t.y, i = "bottom", s = "top"), e ? (n = "end", o = "start") : (n = "start", o = "end"), {
                        start: i,
                        end: s,
                        reverse: e,
                        top: n,
                        bottom: o
                    }
                }(t);
                "middle" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Wn(c, a, r, l)] = !0, n = h)), o[Wn(n, a, r, l)] = !0, t.borderSkipped = o
            }

            function Wn(t, e, i, s) {
                var n, o, a;
                return s ? (a = i, t = Nn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Nn(t, e, i), t
            }

            function Nn(t, e, i) {
                return "start" === t ? e : "end" === t ? i : t
            }

            function Hn(t, {
                inflateAmount: e
            }, i) {
                t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e
            }
            class jn extends Ns {
                static id = "doughnut";
                static defaults = {
                    datasetElementType: !1,
                    dataElementType: "arc",
                    animation: {
                        animateRotate: !0,
                        animateScale: !1
                    },
                    animations: {
                        numbers: {
                            type: "number",
                            properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
                        }
                    },
                    cutout: "50%",
                    rotation: 0,
                    circumference: 360,
                    radius: "100%",
                    spacing: 0,
                    indexAxis: "r"
                };
                static descriptors = {
                    _scriptable: t => "spacing" !== t,
                    _indexable: t => "spacing" !== t && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
                };
                static overrides = {
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            labels: {
                                generateLabels(t) {
                                    const e = t.data;
                                    if (e.labels.length && e.datasets.length) {
                                        const {
                                            labels: {
                                                pointStyle: i,
                                                color: s
                                            }
                                        } = t.legend.options;
                                        return e.labels.map(((e, n) => {
                                            const o = t.getDatasetMeta(0).controller.getStyle(n);
                                            return {
                                                text: e,
                                                fillStyle: o.backgroundColor,
                                                strokeStyle: o.borderColor,
                                                fontColor: s,
                                                lineWidth: o.borderWidth,
                                                pointStyle: i,
                                                hidden: !t.getDataVisibility(n),
                                                index: n
                                            }
                                        }))
                                    }
                                    return []
                                }
                            },
                            onClick(t, e, i) {
                                i.chart.toggleDataVisibility(e.index), i.chart.update()
                            }
                        }
                    }
                };
                constructor(t, e) {
                    super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
                }
                linkScales() {}
                parse(t, e) {
                    const i = this.getDataset().data,
                        s = this._cachedMeta;
                    if (!1 === this._parsing) s._parsed = i;
                    else {
                        let n, a, r = t => +i[t];
                        if (o(i[t])) {
                            const {
                                key: t = "value"
                            } = this._parsing;
                            r = e => +M(i[e], t)
                        }
                        for (n = t, a = t + e; n < a; ++n) s._parsed[n] = r(n)
                    }
                }
                _getRotation() {
                    return $(this.options.rotation - 90)
                }
                _getCircumference() {
                    return $(this.options.circumference)
                }
                _getRotationExtents() {
                    let t = O,
                        e = -O;
                    for (let i = 0; i < this.chart.data.datasets.length; ++i)
                        if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                            const s = this.chart.getDatasetMeta(i).controller,
                                n = s._getRotation(),
                                o = s._getCircumference();
                            t = Math.min(t, n), e = Math.max(e, n + o)
                        }
                    return {
                        rotation: t,
                        circumference: e - t
                    }
                }
                update(t) {
                    const e = this.chart,
                        {
                            chartArea: i
                        } = e,
                        s = this._cachedMeta,
                        n = s.data,
                        o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing,
                        a = Math.max((Math.min(i.width, i.height) - o) / 2, 0),
                        r = Math.min(h(this.options.cutout, a), 1),
                        l = this._getRingWeight(this.index),
                        {
                            circumference: d,
                            rotation: u
                        } = this._getRotationExtents(),
                        {
                            ratioX: f,
                            ratioY: g,
                            offsetX: p,
                            offsetY: m
                        } = function(t, e, i) {
                            let s = 1,
                                n = 1,
                                o = 0,
                                a = 0;
                            if (e < O) {
                                const r = t,
                                    l = r + e,
                                    h = Math.cos(r),
                                    c = Math.sin(r),
                                    d = Math.cos(l),
                                    u = Math.sin(l),
                                    f = (t, e, s) => Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i),
                                    g = (t, e, s) => Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i),
                                    p = f(0, h, d),
                                    m = f(E, c, u),
                                    b = g(C, h, d),
                                    x = g(C + E, c, u);
                                s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, a = -(m + x) / 2
                            }
                            return {
                                ratioX: s,
                                ratioY: n,
                                offsetX: o,
                                offsetY: a
                            }
                        }(u, d, r),
                        b = (i.width - o) / f,
                        x = (i.height - o) / g,
                        _ = Math.max(Math.min(b, x) / 2, 0),
                        y = c(this.options.radius, _),
                        v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();
                    this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t)
                }
                _circumference(t, e) {
                    const i = this.options,
                        s = this._cachedMeta,
                        n = this._getCircumference();
                    return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O)
                }
                updateElements(t, e, i, s) {
                    const n = "reset" === s,
                        o = this.chart,
                        a = o.chartArea,
                        r = o.options.animation,
                        l = (a.left + a.right) / 2,
                        h = (a.top + a.bottom) / 2,
                        c = n && r.animateScale,
                        d = c ? 0 : this.innerRadius,
                        u = c ? 0 : this.outerRadius,
                        {
                            sharedOptions: f,
                            includeOptions: g
                        } = this._getSharedOptions(e, s);
                    let p, m = this._getRotation();
                    for (p = 0; p < e; ++p) m += this._circumference(p, n);
                    for (p = e; p < e + i; ++p) {
                        const e = this._circumference(p, n),
                            i = t[p],
                            o = {
                                x: l + this.offsetX,
                                y: h + this.offsetY,
                                startAngle: m,
                                endAngle: m + e,
                                circumference: e,
                                outerRadius: u,
                                innerRadius: d
                            };
                        g && (o.options = f || this.resolveDataElementOptions(p, i.active ? "active" : s)), m += e, this.updateElement(i, p, o, s)
                    }
                }
                calculateTotal() {
                    const t = this._cachedMeta,
                        e = t.data;
                    let i, s = 0;
                    for (i = 0; i < e.length; i++) {
                        const n = t._parsed[i];
                        null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n))
                    }
                    return s
                }
                calculateCircumference(t) {
                    const e = this._cachedMeta.total;
                    return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        i = this.chart,
                        s = i.data.labels || [],
                        n = ne(e._parsed[t], i.options.locale);
                    return {
                        label: s[t] || "",
                        value: n
                    }
                }
                getMaxBorderWidth(t) {
                    let e = 0;
                    const i = this.chart;
                    let s, n, o, a, r;
                    if (!t)
                        for (s = 0, n = i.data.datasets.length; s < n; ++s)
                            if (i.isDatasetVisible(s)) {
                                o = i.getDatasetMeta(s), t = o.data, a = o.controller;
                                break
                            }
                    if (!t) return 0;
                    for (s = 0, n = t.length; s < n; ++s) r = a.resolveDataElementOptions(s), "inner" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));
                    return e
                }
                getMaxOffset(t) {
                    let e = 0;
                    for (let i = 0, s = t.length; i < s; ++i) {
                        const t = this.resolveDataElementOptions(i);
                        e = Math.max(e, t.offset || 0, t.hoverOffset || 0)
                    }
                    return e
                }
                _getRingWeightOffset(t) {
                    let e = 0;
                    for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
                    return e
                }
                _getRingWeight(t) {
                    return Math.max(l(this.chart.data.datasets[t].weight, 1), 0)
                }
                _getVisibleDatasetWeightTotal() {
                    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
                }
            }
            class $n extends Ns {
                static id = "polarArea";
                static defaults = {
                    dataElementType: "arc",
                    animation: {
                        animateRotate: !0,
                        animateScale: !0
                    },
                    animations: {
                        numbers: {
                            type: "number",
                            properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
                        }
                    },
                    indexAxis: "r",
                    startAngle: 0
                };
                static overrides = {
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            labels: {
                                generateLabels(t) {
                                    const e = t.data;
                                    if (e.labels.length && e.datasets.length) {
                                        const {
                                            labels: {
                                                pointStyle: i,
                                                color: s
                                            }
                                        } = t.legend.options;
                                        return e.labels.map(((e, n) => {
                                            const o = t.getDatasetMeta(0).controller.getStyle(n);
                                            return {
                                                text: e,
                                                fillStyle: o.backgroundColor,
                                                strokeStyle: o.borderColor,
                                                fontColor: s,
                                                lineWidth: o.borderWidth,
                                                pointStyle: i,
                                                hidden: !t.getDataVisibility(n),
                                                index: n
                                            }
                                        }))
                                    }
                                    return []
                                }
                            },
                            onClick(t, e, i) {
                                i.chart.toggleDataVisibility(e.index), i.chart.update()
                            }
                        }
                    },
                    scales: {
                        r: {
                            type: "radialLinear",
                            angleLines: {
                                display: !1
                            },
                            beginAtZero: !0,
                            grid: {
                                circular: !0
                            },
                            pointLabels: {
                                display: !1
                            },
                            startAngle: 0
                        }
                    }
                };
                constructor(t, e) {
                    super(t, e), this.innerRadius = void 0, this.outerRadius = void 0
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        i = this.chart,
                        s = i.data.labels || [],
                        n = ne(e._parsed[t].r, i.options.locale);
                    return {
                        label: s[t] || "",
                        value: n
                    }
                }
                parseObjectData(t, e, i, s) {
                    return ii.bind(this)(t, e, i, s)
                }
                update(t) {
                    const e = this._cachedMeta.data;
                    this._updateRadius(), this.updateElements(e, 0, e.length, t)
                }
                getMinMax() {
                    const t = this._cachedMeta,
                        e = {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        };
                    return t.data.forEach(((t, i) => {
                        const s = this.getParsed(i).r;
                        !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s))
                    })), e
                }
                _updateRadius() {
                    const t = this.chart,
                        e = t.chartArea,
                        i = t.options,
                        s = Math.min(e.right - e.left, e.bottom - e.top),
                        n = Math.max(s / 2, 0),
                        o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
                    this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o
                }
                updateElements(t, e, i, s) {
                    const n = "reset" === s,
                        o = this.chart,
                        a = o.options.animation,
                        r = this._cachedMeta.rScale,
                        l = r.xCenter,
                        h = r.yCenter,
                        c = r.getIndexAngle(0) - .5 * C;
                    let d, u = c;
                    const f = 360 / this.countVisibleElements();
                    for (d = 0; d < e; ++d) u += this._computeAngle(d, s, f);
                    for (d = e; d < e + i; d++) {
                        const e = t[d];
                        let i = u,
                            g = u + this._computeAngle(d, s, f),
                            p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;
                        u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));
                        const m = {
                            x: l,
                            y: h,
                            innerRadius: 0,
                            outerRadius: p,
                            startAngle: i,
                            endAngle: g,
                            options: this.resolveDataElementOptions(d, e.active ? "active" : s)
                        };
                        this.updateElement(e, d, m, s)
                    }
                }
                countVisibleElements() {
                    const t = this._cachedMeta;
                    let e = 0;
                    return t.data.forEach(((t, i) => {
                        !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++
                    })), e
                }
                _computeAngle(t, e, i) {
                    return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0
                }
            }
            var Yn = Object.freeze({
                __proto__: null,
                BarController: class extends Ns {
                    static id = "bar";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "bar",
                        categoryPercentage: .8,
                        barPercentage: .9,
                        grouped: !0,
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["x", "y", "base", "width", "height"]
                            }
                        }
                    };
                    static overrides = {
                        scales: {
                            _index_: {
                                type: "category",
                                offset: !0,
                                grid: {
                                    offset: !0
                                }
                            },
                            _value_: {
                                type: "linear",
                                beginAtZero: !0
                            }
                        }
                    };
                    parsePrimitiveData(t, e, i, s) {
                        return Fn(t, e, i, s)
                    }
                    parseArrayData(t, e, i, s) {
                        return Fn(t, e, i, s)
                    }
                    parseObjectData(t, e, i, s) {
                        const {
                            iScale: n,
                            vScale: o
                        } = t, {
                            xAxisKey: a = "x",
                            yAxisKey: r = "y"
                        } = this._parsing, l = "x" === n.axis ? a : r, h = "x" === o.axis ? a : r, c = [];
                        let d, u, f, g;
                        for (d = i, u = i + s; d < u; ++d) g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(zn(M(g, h), f, o, d));
                        return c
                    }
                    updateRangeFromParsed(t, e, i, s) {
                        super.updateRangeFromParsed(t, e, i, s);
                        const n = i._custom;
                        n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max))
                    }
                    getMaxOverflow() {
                        return 0
                    }
                    getLabelAndValue(t) {
                        const e = this._cachedMeta,
                            {
                                iScale: i,
                                vScale: s
                            } = e,
                            n = this.getParsed(t),
                            o = n._custom,
                            a = Vn(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(n[s.axis]);
                        return {
                            label: "" + i.getLabelForValue(n[i.axis]),
                            value: a
                        }
                    }
                    initialize() {
                        this.enableOptionSharing = !0, super.initialize();
                        this._cachedMeta.stack = this.getDataset().stack
                    }
                    update(t) {
                        const e = this._cachedMeta;
                        this.updateElements(e.data, 0, e.data.length, t)
                    }
                    updateElements(t, e, i, n) {
                        const o = "reset" === n,
                            {
                                index: a,
                                _cachedMeta: {
                                    vScale: r
                                }
                            } = this,
                            l = r.getBasePixel(),
                            h = r.isHorizontal(),
                            c = this._getRuler(),
                            {
                                sharedOptions: d,
                                includeOptions: u
                            } = this._getSharedOptions(e, n);
                        for (let f = e; f < e + i; f++) {
                            const e = this.getParsed(f),
                                i = o || s(e[r.axis]) ? {
                                    base: l,
                                    head: l
                                } : this._calculateBarValuePixels(f),
                                g = this._calculateBarIndexPixels(f, c),
                                p = (e._stacks || {})[r.axis],
                                m = {
                                    horizontal: h,
                                    base: i.base,
                                    enableBorderRadius: !p || Vn(e._custom) || a === p._top || a === p._bottom,
                                    x: h ? i.head : g.center,
                                    y: h ? g.center : i.head,
                                    height: h ? g.size : Math.abs(i.size),
                                    width: h ? Math.abs(i.size) : g.size
                                };
                            u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : n));
                            const b = m.options || t[f].options;
                            Bn(m, b, p, a), Hn(m, b, c.ratio), this.updateElement(t[f], f, m, n)
                        }
                    }
                    _getStacks(t, e) {
                        const {
                            iScale: i
                        } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t => t.controller.options.grouped)), o = i.options.stacked, a = [], r = t => {
                            const i = t.controller.getParsed(e),
                                n = i && i[t.vScale.axis];
                            if (s(n) || isNaN(n)) return !0
                        };
                        for (const i of n)
                            if ((void 0 === e || !r(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;
                        return a.length || a.push(void 0), a
                    }
                    _getStackCount(t) {
                        return this._getStacks(void 0, t).length
                    }
                    _getStackIndex(t, e, i) {
                        const s = this._getStacks(t, i),
                            n = void 0 !== e ? s.indexOf(e) : -1;
                        return -1 === n ? s.length - 1 : n
                    }
                    _getRuler() {
                        const t = this.options,
                            e = this._cachedMeta,
                            i = e.iScale,
                            s = [];
                        let n, o;
                        for (n = 0, o = e.data.length; n < o; ++n) s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));
                        const a = t.barThickness;
                        return {
                            min: a || In(e),
                            pixels: s,
                            start: i._startPixel,
                            end: i._endPixel,
                            stackCount: this._getStackCount(),
                            scale: i,
                            grouped: t.grouped,
                            ratio: a ? 1 : t.categoryPercentage * t.barPercentage
                        }
                    }
                    _calculateBarValuePixels(t) {
                        const {
                            _cachedMeta: {
                                vScale: e,
                                _stacked: i,
                                index: n
                            },
                            options: {
                                base: o,
                                minBarLength: a
                            }
                        } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Vn(h);
                        let d, u, f = l[e.axis],
                            g = 0,
                            p = i ? this.applyStack(e, l, i) : f;
                        p !== f && (g = p - f, p = f), c && (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f && F(f) !== F(h.barEnd) && (g = 0), g += f);
                        const m = s(o) || c ? g : o;
                        let b = e.getPixelForValue(m);
                        if (d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : b, u = d - b, Math.abs(u) < a) {
                            u = function(t, e, i) {
                                return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1)
                            }(u, e, r) * a, f === r && (b -= u / 2);
                            const t = e.getPixelForDecimal(0),
                                s = e.getPixelForDecimal(1),
                                o = Math.min(t, s),
                                h = Math.max(t, s);
                            b = Math.max(Math.min(b, h), o), d = b + u, i && !c && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(b))
                        }
                        if (b === e.getPixelForValue(r)) {
                            const t = F(u) * e.getLineWidthForValue(r) / 2;
                            b += t, u -= t
                        }
                        return {
                            size: u,
                            base: b,
                            head: d,
                            center: d + u / 2
                        }
                    }
                    _calculateBarIndexPixels(t, e) {
                        const i = e.scale,
                            n = this.options,
                            o = n.skipNull,
                            a = l(n.maxBarThickness, 1 / 0);
                        let r, h;
                        if (e.grouped) {
                            const i = o ? this._getStackCount(t) : e.stackCount,
                                l = "flex" === n.barThickness ? function(t, e, i, s) {
                                    const n = e.pixels,
                                        o = n[t];
                                    let a = t > 0 ? n[t - 1] : null,
                                        r = t < n.length - 1 ? n[t + 1] : null;
                                    const l = i.categoryPercentage;
                                    null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);
                                    const h = o - (o - Math.min(a, r)) / 2 * l;
                                    return {
                                        chunk: Math.abs(r - a) / 2 * l / s,
                                        ratio: i.barPercentage,
                                        start: h
                                    }
                                }(t, e, n, i) : function(t, e, i, n) {
                                    const o = i.barThickness;
                                    let a, r;
                                    return s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), {
                                        chunk: a / n,
                                        ratio: r,
                                        start: e.pixels[t] - a / 2
                                    }
                                }(t, e, n, i),
                                c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);
                            r = l.start + l.chunk * c + l.chunk / 2, h = Math.min(a, l.chunk * l.ratio)
                        } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio);
                        return {
                            base: r - h / 2,
                            head: r + h / 2,
                            center: r,
                            size: h
                        }
                    }
                    draw() {
                        const t = this._cachedMeta,
                            e = t.vScale,
                            i = t.data,
                            s = i.length;
                        let n = 0;
                        for (; n < s; ++n) null !== this.getParsed(n)[e.axis] && i[n].draw(this._ctx)
                    }
                },
                BubbleController: class extends Ns {
                    static id = "bubble";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "point",
                        animations: {
                            numbers: {
                                type: "number",
                                properties: ["x", "y", "borderWidth", "radius"]
                            }
                        }
                    };
                    static overrides = {
                        scales: {
                            x: {
                                type: "linear"
                            },
                            y: {
                                type: "linear"
                            }
                        }
                    };
                    initialize() {
                        this.enableOptionSharing = !0, super.initialize()
                    }
                    parsePrimitiveData(t, e, i, s) {
                        const n = super.parsePrimitiveData(t, e, i, s);
                        for (let t = 0; t < n.length; t++) n[t]._custom = this.resolveDataElementOptions(t + i).radius;
                        return n
                    }
                    parseArrayData(t, e, i, s) {
                        const n = super.parseArrayData(t, e, i, s);
                        for (let t = 0; t < n.length; t++) {
                            const s = e[i + t];
                            n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius)
                        }
                        return n
                    }
                    parseObjectData(t, e, i, s) {
                        const n = super.parseObjectData(t, e, i, s);
                        for (let t = 0; t < n.length; t++) {
                            const s = e[i + t];
                            n[t]._custom = l(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius)
                        }
                        return n
                    }
                    getMaxOverflow() {
                        const t = this._cachedMeta.data;
                        let e = 0;
                        for (let i = t.length - 1; i >= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);
                        return e > 0 && e
                    }
                    getLabelAndValue(t) {
                        const e = this._cachedMeta,
                            i = this.chart.data.labels || [],
                            {
                                xScale: s,
                                yScale: n
                            } = e,
                            o = this.getParsed(t),
                            a = s.getLabelForValue(o.x),
                            r = n.getLabelForValue(o.y),
                            l = o._custom;
                        return {
                            label: i[t] || "",
                            value: "(" + a + ", " + r + (l ? ", " + l : "") + ")"
                        }
                    }
                    update(t) {
                        const e = this._cachedMeta.data;
                        this.updateElements(e, 0, e.length, t)
                    }
                    updateElements(t, e, i, s) {
                        const n = "reset" === s,
                            {
                                iScale: o,
                                vScale: a
                            } = this._cachedMeta,
                            {
                                sharedOptions: r,
                                includeOptions: l
                            } = this._getSharedOptions(e, s),
                            h = o.axis,
                            c = a.axis;
                        for (let d = e; d < e + i; d++) {
                            const e = t[d],
                                i = !n && this.getParsed(d),
                                u = {},
                                f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]),
                                g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);
                            u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? "active" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s)
                        }
                    }
                    resolveDataElementOptions(t, e) {
                        const i = this.getParsed(t);
                        let s = super.resolveDataElementOptions(t, e);
                        s.$shared && (s = Object.assign({}, s, {
                            $shared: !1
                        }));
                        const n = s.radius;
                        return "active" !== e && (s.radius = 0), s.radius += l(i && i._custom, n), s
                    }
                },
                DoughnutController: jn,
                LineController: class extends Ns {
                    static id = "line";
                    static defaults = {
                        datasetElementType: "line",
                        dataElementType: "point",
                        showLine: !0,
                        spanGaps: !1
                    };
                    static overrides = {
                        scales: {
                            _index_: {
                                type: "category"
                            },
                            _value_: {
                                type: "linear"
                            }
                        }
                    };
                    initialize() {
                        this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()
                    }
                    update(t) {
                        const e = this._cachedMeta,
                            {
                                dataset: i,
                                data: s = [],
                                _dataset: n
                            } = e,
                            o = this.chart._animationsDisabled;
                        let {
                            start: a,
                            count: r
                        } = pt(e, s, o);
                        this._drawStart = a, this._drawCount = r, mt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;
                        const l = this.resolveDatasetElementOptions(t);
                        this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {
                            animated: !o,
                            options: l
                        }, t), this.updateElements(s, a, r, t)
                    }
                    updateElements(t, e, i, n) {
                        const o = "reset" === n,
                            {
                                iScale: a,
                                vScale: r,
                                _stacked: l,
                                _dataset: h
                            } = this._cachedMeta,
                            {
                                sharedOptions: c,
                                includeOptions: d
                            } = this._getSharedOptions(e, n),
                            u = a.axis,
                            f = r.axis,
                            {
                                spanGaps: g,
                                segment: p
                            } = this.options,
                            m = N(g) ? g : Number.POSITIVE_INFINITY,
                            b = this.chart._animationsDisabled || o || "none" === n,
                            x = e + i,
                            _ = t.length;
                        let y = e > 0 && this.getParsed(e - 1);
                        for (let i = 0; i < _; ++i) {
                            const g = t[i],
                                _ = b ? g : {};
                            if (i < e || i >= x) {
                                _.skip = !0;
                                continue
                            }
                            const v = this.getParsed(i),
                                M = s(v[f]),
                                w = _[u] = a.getPixelForValue(v[u], i),
                                k = _[f] = o || M ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, v, l) : v[f], i);
                            _.skip = isNaN(w) || isNaN(k) || M, _.stop = i > 0 && Math.abs(v[u] - y[u]) > m, p && (_.parsed = v, _.raw = h.data[i]), d && (_.options = c || this.resolveDataElementOptions(i, g.active ? "active" : n)), b || this.updateElement(g, i, _, n), y = v
                        }
                    }
                    getMaxOverflow() {
                        const t = this._cachedMeta,
                            e = t.dataset,
                            i = e.options && e.options.borderWidth || 0,
                            s = t.data || [];
                        if (!s.length) return i;
                        const n = s[0].size(this.resolveDataElementOptions(0)),
                            o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
                        return Math.max(i, n, o) / 2
                    }
                    draw() {
                        const t = this._cachedMeta;
                        t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()
                    }
                },
                PieController: class extends jn {
                    static id = "pie";
                    static defaults = {
                        cutout: 0,
                        rotation: 0,
                        circumference: 360,
                        radius: "100%"
                    }
                },
                PolarAreaController: $n,
                RadarController: class extends Ns {
                    static id = "radar";
                    static defaults = {
                        datasetElementType: "line",
                        dataElementType: "point",
                        indexAxis: "r",
                        showLine: !0,
                        elements: {
                            line: {
                                fill: "start"
                            }
                        }
                    };
                    static overrides = {
                        aspectRatio: 1,
                        scales: {
                            r: {
                                type: "radialLinear"
                            }
                        }
                    };
                    getLabelAndValue(t) {
                        const e = this._cachedMeta.vScale,
                            i = this.getParsed(t);
                        return {
                            label: e.getLabels()[t],
                            value: "" + e.getLabelForValue(i[e.axis])
                        }
                    }
                    parseObjectData(t, e, i, s) {
                        return ii.bind(this)(t, e, i, s)
                    }
                    update(t) {
                        const e = this._cachedMeta,
                            i = e.dataset,
                            s = e.data || [],
                            n = e.iScale.getLabels();
                        if (i.points = s, "resize" !== t) {
                            const e = this.resolveDatasetElementOptions(t);
                            this.options.showLine || (e.borderWidth = 0);
                            const o = {
                                _loop: !0,
                                _fullLoop: n.length === s.length,
                                options: e
                            };
                            this.updateElement(i, void 0, o, t)
                        }
                        this.updateElements(s, 0, s.length, t)
                    }
                    updateElements(t, e, i, s) {
                        const n = this._cachedMeta.rScale,
                            o = "reset" === s;
                        for (let a = e; a < e + i; a++) {
                            const e = t[a],
                                i = this.resolveDataElementOptions(a, e.active ? "active" : s),
                                r = n.getPointPositionForValue(a, this.getParsed(a).r),
                                l = o ? n.xCenter : r.x,
                                h = o ? n.yCenter : r.y,
                                c = {
                                    x: l,
                                    y: h,
                                    angle: r.angle,
                                    skip: isNaN(l) || isNaN(h),
                                    options: i
                                };
                            this.updateElement(e, a, c, s)
                        }
                    }
                },
                ScatterController: class extends Ns {
                    static id = "scatter";
                    static defaults = {
                        datasetElementType: !1,
                        dataElementType: "point",
                        showLine: !1,
                        fill: !1
                    };
                    static overrides = {
                        interaction: {
                            mode: "point"
                        },
                        scales: {
                            x: {
                                type: "linear"
                            },
                            y: {
                                type: "linear"
                            }
                        }
                    };
                    getLabelAndValue(t) {
                        const e = this._cachedMeta,
                            i = this.chart.data.labels || [],
                            {
                                xScale: s,
                                yScale: n
                            } = e,
                            o = this.getParsed(t),
                            a = s.getLabelForValue(o.x),
                            r = n.getLabelForValue(o.y);
                        return {
                            label: i[t] || "",
                            value: "(" + a + ", " + r + ")"
                        }
                    }
                    update(t) {
                        const e = this._cachedMeta,
                            {
                                data: i = []
                            } = e,
                            s = this.chart._animationsDisabled;
                        let {
                            start: n,
                            count: o
                        } = pt(e, i, s);
                        if (this._drawStart = n, this._drawCount = o, mt(e) && (n = 0, o = i.length), this.options.showLine) {
                            this.datasetElementType || this.addElements();
                            const {
                                dataset: n,
                                _dataset: o
                            } = e;
                            n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;
                            const a = this.resolveDatasetElementOptions(t);
                            a.segment = this.options.segment, this.updateElement(n, void 0, {
                                animated: !s,
                                options: a
                            }, t)
                        } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);
                        this.updateElements(i, n, o, t)
                    }
                    addElements() {
                        const {
                            showLine: t
                        } = this.options;
                        !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements()
                    }
                    updateElements(t, e, i, n) {
                        const o = "reset" === n,
                            {
                                iScale: a,
                                vScale: r,
                                _stacked: l,
                                _dataset: h
                            } = this._cachedMeta,
                            c = this.resolveDataElementOptions(e, n),
                            d = this.getSharedOptions(c),
                            u = this.includeOptions(n, d),
                            f = a.axis,
                            g = r.axis,
                            {
                                spanGaps: p,
                                segment: m
                            } = this.options,
                            b = N(p) ? p : Number.POSITIVE_INFINITY,
                            x = this.chart._animationsDisabled || o || "none" === n;
                        let _ = e > 0 && this.getParsed(e - 1);
                        for (let c = e; c < e + i; ++c) {
                            const e = t[c],
                                i = this.getParsed(c),
                                p = x ? e : {},
                                y = s(i[g]),
                                v = p[f] = a.getPixelForValue(i[f], c),
                                M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c);
                            p.skip = isNaN(v) || isNaN(M) || y, p.stop = c > 0 && Math.abs(i[f] - _[f]) > b, m && (p.parsed = i, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? "active" : n)), x || this.updateElement(e, c, p, n), _ = i
                        }
                        this.updateSharedOptions(d, n, c)
                    }
                    getMaxOverflow() {
                        const t = this._cachedMeta,
                            e = t.data || [];
                        if (!this.options.showLine) {
                            let t = 0;
                            for (let i = e.length - 1; i >= 0; --i) t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);
                            return t > 0 && t
                        }
                        const i = t.dataset,
                            s = i.options && i.options.borderWidth || 0;
                        if (!e.length) return s;
                        const n = e[0].size(this.resolveDataElementOptions(0)),
                            o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
                        return Math.max(s, n, o) / 2
                    }
                }
            });

            function Un(t, e, i, s) {
                const n = vi(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
                const o = (i - e) / 2,
                    a = Math.min(o, s * e / 2),
                    r = t => {
                        const e = (i - Math.min(o, t)) * s / 2;
                        return J(t, 0, Math.min(o, e))
                    };
                return {
                    outerStart: r(n.outerStart),
                    outerEnd: r(n.outerEnd),
                    innerStart: J(n.innerStart, 0, a),
                    innerEnd: J(n.innerEnd, 0, a)
                }
            }

            function Xn(t, e, i, s) {
                return {
                    x: i + t * Math.cos(e),
                    y: s + t * Math.sin(e)
                }
            }

            function qn(t, e, i, s, n, o) {
                const {
                    x: a,
                    y: r,
                    startAngle: l,
                    pixelMargin: h,
                    innerRadius: c
                } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;
                let f = 0;
                const g = n - l;
                if (s) {
                    const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;
                    f = (g - (0 !== t ? g * t / (t + s) : g)) / 2
                }
                const p = (g - Math.max(.001, g * d - i / C) / d) / 2,
                    m = l + p + f,
                    b = n - p - f,
                    {
                        outerStart: x,
                        outerEnd: _,
                        innerStart: y,
                        innerEnd: v
                    } = Un(e, u, d, b - m),
                    M = d - x,
                    w = d - _,
                    k = m + x / M,
                    S = b - _ / w,
                    P = u + y,
                    D = u + v,
                    O = m + y / P,
                    A = b - v / D;
                if (t.beginPath(), o) {
                    const e = (k + S) / 2;
                    if (t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ > 0) {
                        const e = Xn(w, S, a, r);
                        t.arc(e.x, e.y, _, S, b + E)
                    }
                    const i = Xn(D, b, a, r);
                    if (t.lineTo(i.x, i.y), v > 0) {
                        const e = Xn(D, A, a, r);
                        t.arc(e.x, e.y, v, b + E, A + Math.PI)
                    }
                    const s = (b - v / u + (m + y / u)) / 2;
                    if (t.arc(a, r, u, b - v / u, s, !0), t.arc(a, r, u, s, m + y / u, !0), y > 0) {
                        const e = Xn(P, O, a, r);
                        t.arc(e.x, e.y, y, O + Math.PI, m - E)
                    }
                    const n = Xn(M, m, a, r);
                    if (t.lineTo(n.x, n.y), x > 0) {
                        const e = Xn(M, k, a, r);
                        t.arc(e.x, e.y, x, m - E, k)
                    }
                } else {
                    t.moveTo(a, r);
                    const e = Math.cos(k) * d + a,
                        i = Math.sin(k) * d + r;
                    t.lineTo(e, i);
                    const s = Math.cos(S) * d + a,
                        n = Math.sin(S) * d + r;
                    t.lineTo(s, n)
                }
                t.closePath()
            }

            function Kn(t, e, i, s, n) {
                const {
                    fullCircles: o,
                    startAngle: a,
                    circumference: r,
                    options: l
                } = e, {
                    borderWidth: h,
                    borderJoinStyle: c,
                    borderDash: d,
                    borderDashOffset: u
                } = l, f = "inner" === l.borderAlign;
                if (!h) return;
                t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || "round") : (t.lineWidth = h, t.lineJoin = c || "bevel");
                let g = e.endAngle;
                if (o) {
                    qn(t, e, i, s, g, n);
                    for (let e = 0; e < o; ++e) t.stroke();
                    isNaN(r) || (g = a + (r % O || O))
                }
                f && function(t, e, i) {
                    const {
                        startAngle: s,
                        pixelMargin: n,
                        x: o,
                        y: a,
                        outerRadius: r,
                        innerRadius: l
                    } = e;
                    let h = n / r;
                    t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + E, s - E), t.closePath(), t.clip()
                }(t, e, g), o || (qn(t, e, i, s, g, n), t.stroke())
            }

            function Gn(t, e, i = e) {
                t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor)
            }

            function Zn(t, e, i) {
                t.lineTo(i.x, i.y)
            }

            function Jn(t, e, i = {}) {
                const s = t.length,
                    {
                        start: n = 0,
                        end: o = s - 1
                    } = i,
                    {
                        start: a,
                        end: r
                    } = e,
                    l = Math.max(n, a),
                    h = Math.min(o, r),
                    c = n < a && o < a || n > r && o > r;
                return {
                    count: s,
                    start: l,
                    loop: e.loop,
                    ilen: h < l && !c ? s + h - l : h - l
                }
            }

            function Qn(t, e, i, s) {
                const {
                    points: n,
                    options: o
                } = e, {
                    count: a,
                    start: r,
                    loop: l,
                    ilen: h
                } = Jn(n, i, s), c = function(t) {
                    return t.stepped ? Fe : t.tension || "monotone" === t.cubicInterpolationMode ? Ve : Zn
                }(o);
                let d, u, f, {
                    move: g = !0,
                    reverse: p
                } = s || {};
                for (d = 0; d <= h; ++d) u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);
                return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l
            }

            function to(t, e, i, s) {
                const n = e.points,
                    {
                        count: o,
                        start: a,
                        ilen: r
                    } = Jn(n, i, s),
                    {
                        move: l = !0,
                        reverse: h
                    } = s || {};
                let c, d, u, f, g, p, m = 0,
                    b = 0;
                const x = t => (a + (h ? r - t : t)) % o,
                    _ = () => {
                        f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p))
                    };
                for (l && (d = n[x(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c) {
                    if (d = n[x(c)], d.skip) continue;
                    const e = d.x,
                        i = d.y,
                        s = 0 | e;
                    s === u ? (i < f ? f = i : i > g && (g = i), m = (b * m + e) / ++b) : (_(), t.lineTo(e, i), u = s, b = 0, f = g = i), p = i
                }
                _()
            }

            function eo(t) {
                const e = t.options,
                    i = e.borderDash && e.borderDash.length;
                return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? to : Qn
            }
            const io = "function" == typeof Path2D;

            function so(t, e, i, s) {
                io && !e.options.segment ? function(t, e, i, s) {
                    let n = e._path;
                    n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Gn(t, e.options), t.stroke(n)
                }(t, e, i, s) : function(t, e, i, s) {
                    const {
                        segments: n,
                        options: o
                    } = e, a = eo(e);
                    for (const r of n) Gn(t, o, r.style), t.beginPath(), a(t, e, r, {
                        start: i,
                        end: i + s - 1
                    }) && t.closePath(), t.stroke()
                }(t, e, i, s)
            }
            class no extends Hs {
                static id = "line";
                static defaults = {
                    borderCapStyle: "butt",
                    borderDash: [],
                    borderDashOffset: 0,
                    borderJoinStyle: "miter",
                    borderWidth: 3,
                    capBezierPoints: !0,
                    cubicInterpolationMode: "default",
                    fill: !1,
                    spanGaps: !1,
                    stepped: !1,
                    tension: 0
                };
                static defaultRoutes = {
                    backgroundColor: "backgroundColor",
                    borderColor: "borderColor"
                };
                static descriptors = {
                    _scriptable: !0,
                    _indexable: t => "borderDash" !== t && "fill" !== t
                };
                constructor(t) {
                    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t)
                }
                updateControlPoints(t, e) {
                    const i = this.options;
                    if ((i.tension || "monotone" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {
                        const s = i.spanGaps ? this._loop : this._fullLoop;
                        hi(this._points, i, t, s, e), this._pointsUpdated = !0
                    }
                }
                set points(t) {
                    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1
                }
                get points() {
                    return this._points
                }
                get segments() {
                    return this._segments || (this._segments = zi(this, this.options.segment))
                }
                first() {
                    const t = this.segments,
                        e = this.points;
                    return t.length && e[t[0].start]
                }
                last() {
                    const t = this.segments,
                        e = this.points,
                        i = t.length;
                    return i && e[t[i - 1].end]
                }
                interpolate(t, e) {
                    const i = this.options,
                        s = t[e],
                        n = this.points,
                        o = Ii(this, {
                            property: e,
                            start: s,
                            end: s
                        });
                    if (!o.length) return;
                    const a = [],
                        r = function(t) {
                            return t.stepped ? pi : t.tension || "monotone" === t.cubicInterpolationMode ? mi : gi
                        }(i);
                    let l, h;
                    for (l = 0, h = o.length; l < h; ++l) {
                        const {
                            start: h,
                            end: c
                        } = o[l], d = n[h], u = n[c];
                        if (d === u) {
                            a.push(d);
                            continue
                        }
                        const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);
                        f[e] = t[e], a.push(f)
                    }
                    return 1 === a.length ? a[0] : a
                }
                pathSegment(t, e, i) {
                    return eo(this)(t, this, e, i)
                }
                path(t, e, i) {
                    const s = this.segments,
                        n = eo(this);
                    let o = this._loop;
                    e = e || 0, i = i || this.points.length - e;
                    for (const a of s) o &= n(t, this, a, {
                        start: e,
                        end: e + i - 1
                    });
                    return !!o
                }
                draw(t, e, i, s) {
                    const n = this.options || {};
                    (this.points || []).length && n.borderWidth && (t.save(), so(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0)
                }
            }

            function oo(t, e, i, s) {
                const n = t.options,
                    {
                        [i]: o
                    } = t.getProps([i], s);
                return Math.abs(e - o) < n.radius + n.hitRadius
            }

            function ao(t, e) {
                const {
                    x: i,
                    y: s,
                    base: n,
                    width: o,
                    height: a
                } = t.getProps(["x", "y", "base", "width", "height"], e);
                let r, l, h, c, d;
                return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {
                    left: r,
                    top: h,
                    right: l,
                    bottom: c
                }
            }

            function ro(t, e, i, s) {
                return t ? 0 : J(e, i, s)
            }

            function lo(t) {
                const e = ao(t),
                    i = e.right - e.left,
                    s = e.bottom - e.top,
                    n = function(t, e, i) {
                        const s = t.options.borderWidth,
                            n = t.borderSkipped,
                            o = Mi(s);
                        return {
                            t: ro(n.top, o.top, 0, i),
                            r: ro(n.right, o.right, 0, e),
                            b: ro(n.bottom, o.bottom, 0, i),
                            l: ro(n.left, o.left, 0, e)
                        }
                    }(t, i / 2, s / 2),
                    a = function(t, e, i) {
                        const {
                            enableBorderRadius: s
                        } = t.getProps(["enableBorderRadius"]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);
                        return {
                            topLeft: ro(!h || l.top || l.left, a.topLeft, 0, r),
                            topRight: ro(!h || l.top || l.right, a.topRight, 0, r),
                            bottomLeft: ro(!h || l.bottom || l.left, a.bottomLeft, 0, r),
                            bottomRight: ro(!h || l.bottom || l.right, a.bottomRight, 0, r)
                        }
                    }(t, i / 2, s / 2);
                return {
                    outer: {
                        x: e.left,
                        y: e.top,
                        w: i,
                        h: s,
                        radius: a
                    },
                    inner: {
                        x: e.left + n.l,
                        y: e.top + n.t,
                        w: i - n.l - n.r,
                        h: s - n.t - n.b,
                        radius: {
                            topLeft: Math.max(0, a.topLeft - Math.max(n.t, n.l)),
                            topRight: Math.max(0, a.topRight - Math.max(n.t, n.r)),
                            bottomLeft: Math.max(0, a.bottomLeft - Math.max(n.b, n.l)),
                            bottomRight: Math.max(0, a.bottomRight - Math.max(n.b, n.r))
                        }
                    }
                }
            }

            function ho(t, e, i, s) {
                const n = null === e,
                    o = null === i,
                    a = t && !(n && o) && ao(t, s);
                return a && (n || tt(e, a.left, a.right)) && (o || tt(i, a.top, a.bottom))
            }

            function co(t, e) {
                t.rect(e.x, e.y, e.w, e.h)
            }

            function uo(t, e, i = {}) {
                const s = t.x !== i.x ? -e : 0,
                    n = t.y !== i.y ? -e : 0,
                    o = (t.x + t.w !== i.x + i.w ? e : 0) - s,
                    a = (t.y + t.h !== i.y + i.h ? e : 0) - n;
                return {
                    x: t.x + s,
                    y: t.y + n,
                    w: t.w + o,
                    h: t.h + a,
                    radius: t.radius
                }
            }
            var fo = Object.freeze({
                __proto__: null,
                ArcElement: class extends Hs {
                    static id = "arc";
                    static defaults = {
                        borderAlign: "center",
                        borderColor: "#fff",
                        borderDash: [],
                        borderDashOffset: 0,
                        borderJoinStyle: void 0,
                        borderRadius: 0,
                        borderWidth: 2,
                        offset: 0,
                        spacing: 0,
                        angle: void 0,
                        circular: !0
                    };
                    static defaultRoutes = {
                        backgroundColor: "backgroundColor"
                    };
                    static descriptors = {
                        _scriptable: !0,
                        _indexable: t => "borderDash" !== t
                    };
                    circumference;
                    endAngle;
                    fullCircles;
                    innerRadius;
                    outerRadius;
                    pixelMargin;
                    startAngle;
                    constructor(t) {
                        super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t)
                    }
                    inRange(t, e, i) {
                        const s = this.getProps(["x", "y"], i),
                            {
                                angle: n,
                                distance: o
                            } = X(s, {
                                x: t,
                                y: e
                            }),
                            {
                                startAngle: a,
                                endAngle: r,
                                innerRadius: h,
                                outerRadius: c,
                                circumference: d
                            } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i),
                            u = (this.options.spacing + this.options.borderWidth) / 2,
                            f = l(d, r - a) >= O || Z(n, a, r),
                            g = tt(o, h + u, c + u);
                        return f && g
                    }
                    getCenterPoint(t) {
                        const {
                            x: e,
                            y: i,
                            startAngle: s,
                            endAngle: n,
                            innerRadius: o,
                            outerRadius: a
                        } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), {
                            offset: r,
                            spacing: l
                        } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;
                        return {
                            x: e + Math.cos(h) * c,
                            y: i + Math.sin(h) * c
                        }
                    }
                    tooltipPosition(t) {
                        return this.getCenterPoint(t)
                    }
                    draw(t) {
                        const {
                            options: e,
                            circumference: i
                        } = this, s = (e.offset || 0) / 4, n = (e.spacing || 0) / 2, o = e.circular;
                        if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;
                        t.save();
                        const a = (this.startAngle + this.endAngle) / 2;
                        t.translate(Math.cos(a) * s, Math.sin(a) * s);
                        const r = s * (1 - Math.sin(Math.min(C, i || 0)));
                        t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor,
                            function(t, e, i, s, n) {
                                const {
                                    fullCircles: o,
                                    startAngle: a,
                                    circumference: r
                                } = e;
                                let l = e.endAngle;
                                if (o) {
                                    qn(t, e, i, s, l, n);
                                    for (let e = 0; e < o; ++e) t.fill();
                                    isNaN(r) || (l = a + (r % O || O))
                                }
                                qn(t, e, i, s, l, n), t.fill()
                            }(t, this, r, n, o), Kn(t, this, r, n, o), t.restore()
                    }
                },
                BarElement: class extends Hs {
                    static id = "bar";
                    static defaults = {
                        borderSkipped: "start",
                        borderWidth: 0,
                        borderRadius: 0,
                        inflateAmount: "auto",
                        pointStyle: void 0
                    };
                    static defaultRoutes = {
                        backgroundColor: "backgroundColor",
                        borderColor: "borderColor"
                    };
                    constructor(t) {
                        super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t)
                    }
                    draw(t) {
                        const {
                            inflateAmount: e,
                            options: {
                                borderColor: i,
                                backgroundColor: s
                            }
                        } = this, {
                            inner: n,
                            outer: o
                        } = lo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : co;
                        var r;
                        t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, uo(o, e, n)), t.clip(), a(t, uo(n, -e, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), a(t, uo(n, e)), t.fillStyle = s, t.fill(), t.restore()
                    }
                    inRange(t, e, i) {
                        return ho(this, t, e, i)
                    }
                    inXRange(t, e) {
                        return ho(this, t, null, e)
                    }
                    inYRange(t, e) {
                        return ho(this, null, t, e)
                    }
                    getCenterPoint(t) {
                        const {
                            x: e,
                            y: i,
                            base: s,
                            horizontal: n
                        } = this.getProps(["x", "y", "base", "horizontal"], t);
                        return {
                            x: n ? (e + s) / 2 : e,
                            y: n ? i : (i + s) / 2
                        }
                    }
                    getRange(t) {
                        return "x" === t ? this.width / 2 : this.height / 2
                    }
                },
                LineElement: no,
                PointElement: class extends Hs {
                    static id = "point";
                    parsed;
                    skip;
                    stop;
                    static defaults = {
                        borderWidth: 1,
                        hitRadius: 1,
                        hoverBorderWidth: 1,
                        hoverRadius: 4,
                        pointStyle: "circle",
                        radius: 3,
                        rotation: 0
                    };
                    static defaultRoutes = {
                        backgroundColor: "backgroundColor",
                        borderColor: "borderColor"
                    };
                    constructor(t) {
                        super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t)
                    }
                    inRange(t, e, i) {
                        const s = this.options,
                            {
                                x: n,
                                y: o
                            } = this.getProps(["x", "y"], i);
                        return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2)
                    }
                    inXRange(t, e) {
                        return oo(this, t, "x", e)
                    }
                    inYRange(t, e) {
                        return oo(this, t, "y", e)
                    }
                    getCenterPoint(t) {
                        const {
                            x: e,
                            y: i
                        } = this.getProps(["x", "y"], t);
                        return {
                            x: e,
                            y: i
                        }
                    }
                    size(t) {
                        let e = (t = t || this.options || {}).radius || 0;
                        e = Math.max(e, e && t.hoverRadius || 0);
                        return 2 * (e + (e && t.borderWidth || 0))
                    }
                    draw(t, e) {
                        const i = this.options;
                        this.skip || i.radius < .1 || !Re(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, this.x, this.y))
                    }
                    getRange() {
                        const t = this.options || {};
                        return t.radius + t.hitRadius
                    }
                }
            });

            function go(t, e, i, s) {
                const n = t.indexOf(e);
                if (-1 === n) return ((t, e, i, s) => ("string" == typeof e ? (i = t.push(e) - 1, s.unshift({
                    index: i,
                    label: e
                })) : isNaN(e) && (i = null), i))(t, e, i, s);
                return n !== t.lastIndexOf(e) ? i : n
            }

            function po(t) {
                const e = this.getLabels();
                return t >= 0 && t < e.length ? e[t] : t
            }

            function mo(t, e, {
                horizontal: i,
                minRotation: s
            }) {
                const n = $(s),
                    o = (i ? Math.sin(n) : Math.cos(n)) || .001,
                    a = .75 * e * ("" + t).length;
                return Math.min(e / o, a)
            }
            class bo extends Js {
                constructor(t) {
                    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
                }
                parse(t, e) {
                    return s(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
                }
                handleTickRangeOptions() {
                    const {
                        beginAtZero: t
                    } = this.options, {
                        minDefined: e,
                        maxDefined: i
                    } = this.getUserBounds();
                    let {
                        min: s,
                        max: n
                    } = this;
                    const o = t => s = e ? s : t,
                        a = t => n = i ? n : t;
                    if (t) {
                        const t = F(s),
                            e = F(n);
                        t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0)
                    }
                    if (s === n) {
                        let e = 0 === n ? 1 : Math.abs(.05 * n);
                        a(n + e), t || o(s - e)
                    }
                    this.min = s, this.max = n
                }
                getTickLimit() {
                    const t = this.options.ticks;
                    let e, {
                        maxTicksLimit: i,
                        stepSize: s
                    } = t;
                    return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e
                }
                computeTickLimit() {
                    return Number.POSITIVE_INFINITY
                }
                buildTicks() {
                    const t = this.options,
                        e = t.ticks;
                    let i = this.getTickLimit();
                    i = Math.max(2, i);
                    const n = function(t, e) {
                        const i = [],
                            {
                                bounds: n,
                                step: o,
                                min: a,
                                max: r,
                                precision: l,
                                count: h,
                                maxTicks: c,
                                maxDigits: d,
                                includeBounds: u
                            } = t,
                            f = o || 1,
                            g = c - 1,
                            {
                                min: p,
                                max: m
                            } = e,
                            b = !s(a),
                            x = !s(r),
                            _ = !s(h),
                            y = (m - p) / (d + 1);
                        let v, M, w, k, S = B((m - p) / g / f) * f;
                        if (S < 1e-14 && !b && !x) return [{
                            value: p
                        }, {
                            value: m
                        }];
                        k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = B(k * S / g / f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), "ticks" === n ? (M = Math.floor(p / S) * S, w = Math.ceil(m / S) * S) : (M = p, w = m), b && x && o && H((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, M = a, w = r) : _ ? (M = b ? a : M, w = x ? r : w, k = h - 1, S = (w - M) / k) : (k = (w - M) / S, k = V(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));
                        const P = Math.max(U(S), U(M));
                        v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) / v, w = Math.round(w * v) / v;
                        let D = 0;
                        for (b && (u && M !== a ? (i.push({
                                value: a
                            }), M < a && D++, V(Math.round((M + D * S) * v) / v, a, mo(a, y, t)) && D++) : M < a && D++); D < k; ++D) {
                            const t = Math.round((M + D * S) * v) / v;
                            if (x && t > r) break;
                            i.push({
                                value: t
                            })
                        }
                        return x && u && w !== r ? i.length && V(i[i.length - 1].value, r, mo(r, y, t)) ? i[i.length - 1].value = r : i.push({
                            value: r
                        }) : x && w !== r || i.push({
                            value: w
                        }), i
                    }({
                        maxTicks: i,
                        bounds: t.bounds,
                        min: t.min,
                        max: t.max,
                        precision: e.precision,
                        step: e.stepSize,
                        count: e.count,
                        maxDigits: this._maxDigits(),
                        horizontal: this.isHorizontal(),
                        minRotation: e.minRotation || 0,
                        includeBounds: !1 !== e.includeBounds
                    }, this._range || this);
                    return "ticks" === t.bounds && j(n, this, "value"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n
                }
                configure() {
                    const t = this.ticks;
                    let e = this.min,
                        i = this.max;
                    if (super.configure(), this.options.offset && t.length) {
                        const s = (i - e) / Math.max(t.length - 1, 1) / 2;
                        e -= s, i += s
                    }
                    this._startValue = e, this._endValue = i, this._valueRange = i - e
                }
                getLabelForValue(t) {
                    return ne(t, this.chart.options.locale, this.options.ticks.format)
                }
            }
            class xo extends bo {
                static id = "linear";
                static defaults = {
                    ticks: {
                        callback: ae.formatters.numeric
                    }
                };
                determineDataLimits() {
                    const {
                        min: t,
                        max: e
                    } = this.getMinMax(!0);
                    this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions()
                }
                computeTickLimit() {
                    const t = this.isHorizontal(),
                        e = t ? this.width : this.height,
                        i = $(this.options.ticks.minRotation),
                        s = (t ? Math.sin(i) : Math.cos(i)) || .001,
                        n = this._resolveTickFontOptions(0);
                    return Math.ceil(e / Math.min(40, n.lineHeight / s))
                }
                getPixelForValue(t) {
                    return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
                }
                getValueForPixel(t) {
                    return this._startValue + this.getDecimalForPixel(t) * this._valueRange
                }
            }
            const _o = t => Math.floor(z(t)),
                yo = (t, e) => Math.pow(10, _o(t) + e);

            function vo(t) {
                return 1 === t / Math.pow(10, _o(t))
            }

            function Mo(t, e, i) {
                const s = Math.pow(10, i),
                    n = Math.floor(t / s);
                return Math.ceil(e / s) - n
            }

            function wo(t, {
                min: e,
                max: i
            }) {
                e = r(t.min, e);
                const s = [],
                    n = _o(e);
                let o = function(t, e) {
                        let i = _o(e - t);
                        for (; Mo(t, e, i) > 10;) i++;
                        for (; Mo(t, e, i) < 10;) i--;
                        return Math.min(i, _o(t))
                    }(e, i),
                    a = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
                const l = Math.pow(10, o),
                    h = n > o ? Math.pow(10, n) : 0,
                    c = Math.round((e - h) * a) / a,
                    d = Math.floor((e - h) / l / 10) * l * 10;
                let u = Math.floor((c - d) / Math.pow(10, o)),
                    f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) / a);
                for (; f < i;) s.push({
                    value: f,
                    major: vo(f),
                    significand: u
                }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) / a;
                const g = r(t.max, f);
                return s.push({
                    value: g,
                    major: vo(g),
                    significand: u
                }), s
            }
            class ko extends Js {
                static id = "logarithmic";
                static defaults = {
                    ticks: {
                        callback: ae.formatters.logarithmic,
                        major: {
                            enabled: !0
                        }
                    }
                };
                constructor(t) {
                    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
                }
                parse(t, e) {
                    const i = bo.prototype.parse.apply(this, [t, e]);
                    if (0 !== i) return a(i) && i > 0 ? i : null;
                    this._zero = !0
                }
                determineDataLimits() {
                    const {
                        min: t,
                        max: e
                    } = this.getMinMax(!0);
                    this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !a(this._userMin) && (this.min = t === yo(this.min, 0) ? yo(this.min, -1) : yo(this.min, 0)), this.handleTickRangeOptions()
                }
                handleTickRangeOptions() {
                    const {
                        minDefined: t,
                        maxDefined: e
                    } = this.getUserBounds();
                    let i = this.min,
                        s = this.max;
                    const n = e => i = t ? i : e,
                        o = t => s = e ? s : t;
                    i === s && (i <= 0 ? (n(1), o(10)) : (n(yo(i, -1)), o(yo(s, 1)))), i <= 0 && n(yo(s, -1)), s <= 0 && o(yo(i, 1)), this.min = i, this.max = s
                }
                buildTicks() {
                    const t = this.options,
                        e = wo({
                            min: this._userMin,
                            max: this._userMax
                        }, this);
                    return "ticks" === t.bounds && j(e, this, "value"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e
                }
                getLabelForValue(t) {
                    return void 0 === t ? "0" : ne(t, this.chart.options.locale, this.options.ticks.format)
                }
                configure() {
                    const t = this.min;
                    super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t)
                }
                getPixelForValue(t) {
                    return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) / this._valueRange)
                }
                getValueForPixel(t) {
                    const e = this.getDecimalForPixel(t);
                    return Math.pow(10, this._startValue + e * this._valueRange)
                }
            }

            function So(t) {
                const e = t.ticks;
                if (e.display && t.display) {
                    const t = ki(e.backdropPadding);
                    return l(e.font && e.font.size, ue.font.size) + t.height
                }
                return 0
            }

            function Po(t, e, i, s, n) {
                return t === s || t === n ? {
                    start: e - i / 2,
                    end: e + i / 2
                } : t < s || t > n ? {
                    start: e - i,
                    end: e
                } : {
                    start: e,
                    end: e + i
                }
            }

            function Do(t) {
                const e = {
                        l: t.left + t._padding.left,
                        r: t.right - t._padding.right,
                        t: t.top + t._padding.top,
                        b: t.bottom - t._padding.bottom
                    },
                    i = Object.assign({}, e),
                    s = [],
                    o = [],
                    a = t._pointLabels.length,
                    r = t.options.pointLabels,
                    l = r.centerPointLabels ? C / a : 0;
                for (let u = 0; u < a; u++) {
                    const a = r.setContext(t.getPointLabelContext(u));
                    o[u] = a.padding;
                    const f = t.getPointPosition(u, t.drawingArea + o[u], l),
                        g = Si(a.font),
                        p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [d], {
                            w: Oe(h, c.string, d),
                            h: d.length * c.lineHeight
                        });
                    s[u] = p;
                    const m = G(t.getIndexAngle(u) + l),
                        b = Math.round(Y(m));
                    Co(i, e, m, Po(b, f.x, p.w, 0, 180), Po(b, f.y, p.h, 90, 270))
                }
                var h, c, d;
                t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function(t, e, i) {
                    const s = [],
                        n = t._pointLabels.length,
                        o = t.options,
                        {
                            centerPointLabels: a,
                            display: r
                        } = o.pointLabels,
                        l = {
                            extra: So(o) / 2,
                            additionalAngle: a ? C / n : 0
                        };
                    let h;
                    for (let o = 0; o < n; o++) {
                        l.padding = i[o], l.size = e[o];
                        const n = Oo(t, o, l);
                        s.push(n), "auto" === r && (n.visible = Ao(n, h), n.visible && (h = n))
                    }
                    return s
                }(t, s, o)
            }

            function Co(t, e, i, s, n) {
                const o = Math.abs(Math.sin(i)),
                    a = Math.abs(Math.cos(i));
                let r = 0,
                    l = 0;
                s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l))
            }

            function Oo(t, e, i) {
                const s = t.drawingArea,
                    {
                        extra: n,
                        additionalAngle: o,
                        padding: a,
                        size: r
                    } = i,
                    l = t.getPointPosition(e, s + n + a, o),
                    h = Math.round(Y(G(l.angle + E))),
                    c = function(t, e, i) {
                        90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);
                        return t
                    }(l.y, r.h, h),
                    d = function(t) {
                        if (0 === t || 180 === t) return "center";
                        if (t < 180) return "left";
                        return "right"
                    }(h),
                    u = function(t, e, i) {
                        "right" === i ? t -= e : "center" === i && (t -= e / 2);
                        return t
                    }(l.x, r.w, d);
                return {
                    visible: !0,
                    x: l.x,
                    y: c,
                    textAlign: d,
                    left: u,
                    top: c,
                    right: u + r.w,
                    bottom: c + r.h
                }
            }

            function Ao(t, e) {
                if (!e) return !0;
                const {
                    left: i,
                    top: s,
                    right: n,
                    bottom: o
                } = t;
                return !(Re({
                    x: i,
                    y: s
                }, e) || Re({
                    x: i,
                    y: o
                }, e) || Re({
                    x: n,
                    y: s
                }, e) || Re({
                    x: n,
                    y: o
                }, e))
            }

            function To(t, e, i) {
                const {
                    left: n,
                    top: o,
                    right: a,
                    bottom: r
                } = i, {
                    backdropColor: l
                } = e;
                if (!s(l)) {
                    const i = wi(e.borderRadius),
                        s = ki(e.backdropPadding);
                    t.fillStyle = l;
                    const h = n - s.left,
                        c = o - s.top,
                        d = a - n + s.width,
                        u = r - o + s.height;
                    Object.values(i).some((t => 0 !== t)) ? (t.beginPath(), He(t, {
                        x: h,
                        y: c,
                        w: d,
                        h: u,
                        radius: i
                    }), t.fill()) : t.fillRect(h, c, d, u)
                }
            }

            function Lo(t, e, i, s) {
                const {
                    ctx: n
                } = t;
                if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);
                else {
                    let i = t.getPointPosition(0, e);
                    n.moveTo(i.x, i.y);
                    for (let o = 1; o < s; o++) i = t.getPointPosition(o, e), n.lineTo(i.x, i.y)
                }
            }
            class Eo extends bo {
                static id = "radialLinear";
                static defaults = {
                    display: !0,
                    animate: !0,
                    position: "chartArea",
                    angleLines: {
                        display: !0,
                        lineWidth: 1,
                        borderDash: [],
                        borderDashOffset: 0
                    },
                    grid: {
                        circular: !1
                    },
                    startAngle: 0,
                    ticks: {
                        showLabelBackdrop: !0,
                        callback: ae.formatters.numeric
                    },
                    pointLabels: {
                        backdropColor: void 0,
                        backdropPadding: 2,
                        display: !0,
                        font: {
                            size: 10
                        },
                        callback: t => t,
                        padding: 5,
                        centerPointLabels: !1
                    }
                };
                static defaultRoutes = {
                    "angleLines.color": "borderColor",
                    "pointLabels.color": "color",
                    "ticks.color": "color"
                };
                static descriptors = {
                    angleLines: {
                        _fallback: "grid"
                    }
                };
                constructor(t) {
                    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
                }
                setDimensions() {
                    const t = this._padding = ki(So(this.options) / 2),
                        e = this.width = this.maxWidth - t.width,
                        i = this.height = this.maxHeight - t.height;
                    this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2)
                }
                determineDataLimits() {
                    const {
                        min: t,
                        max: e
                    } = this.getMinMax(!1);
                    this.min = a(t) && !isNaN(t) ? t : 0, this.max = a(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions()
                }
                computeTickLimit() {
                    return Math.ceil(this.drawingArea / So(this.options))
                }
                generateTickLabels(t) {
                    bo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map(((t, e) => {
                        const i = d(this.options.pointLabels.callback, [t, e], this);
                        return i || 0 === i ? i : ""
                    })).filter(((t, e) => this.chart.getDataVisibility(e)))
                }
                fit() {
                    const t = this.options;
                    t.display && t.pointLabels.display ? Do(this) : this.setCenterPoint(0, 0, 0, 0)
                }
                setCenterPoint(t, e, i, s) {
                    this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s))
                }
                getIndexAngle(t) {
                    return G(t * (O / (this._pointLabels.length || 1)) + $(this.options.startAngle || 0))
                }
                getDistanceFromCenterForValue(t) {
                    if (s(t)) return NaN;
                    const e = this.drawingArea / (this.max - this.min);
                    return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
                }
                getValueForDistanceFromCenter(t) {
                    if (s(t)) return NaN;
                    const e = t / (this.drawingArea / (this.max - this.min));
                    return this.options.reverse ? this.max - e : this.min + e
                }
                getPointLabelContext(t) {
                    const e = this._pointLabels || [];
                    if (t >= 0 && t < e.length) {
                        const i = e[t];
                        return function(t, e, i) {
                            return Ci(t, {
                                label: i,
                                index: e,
                                type: "pointLabel"
                            })
                        }(this.getContext(), t, i)
                    }
                }
                getPointPosition(t, e, i = 0) {
                    const s = this.getIndexAngle(t) - E + i;
                    return {
                        x: Math.cos(s) * e + this.xCenter,
                        y: Math.sin(s) * e + this.yCenter,
                        angle: s
                    }
                }
                getPointPositionForValue(t, e) {
                    return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
                }
                getBasePosition(t) {
                    return this.getPointPositionForValue(t || 0, this.getBaseValue())
                }
                getPointLabelPosition(t) {
                    const {
                        left: e,
                        top: i,
                        right: s,
                        bottom: n
                    } = this._pointLabelItems[t];
                    return {
                        left: e,
                        top: i,
                        right: s,
                        bottom: n
                    }
                }
                drawBackground() {
                    const {
                        backgroundColor: t,
                        grid: {
                            circular: e
                        }
                    } = this.options;
                    if (t) {
                        const i = this.ctx;
                        i.save(), i.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore()
                    }
                }
                drawGrid() {
                    const t = this.ctx,
                        e = this.options,
                        {
                            angleLines: i,
                            grid: s,
                            border: n
                        } = e,
                        o = this._pointLabels.length;
                    let a, r, l;
                    if (e.pointLabels.display && function(t, e) {
                            const {
                                ctx: i,
                                options: {
                                    pointLabels: s
                                }
                            } = t;
                            for (let n = e - 1; n >= 0; n--) {
                                const e = t._pointLabelItems[n];
                                if (!e.visible) continue;
                                const o = s.setContext(t.getPointLabelContext(n));
                                To(i, o, e);
                                const a = Si(o.font),
                                    {
                                        x: r,
                                        y: l,
                                        textAlign: h
                                    } = e;
                                Ne(i, t._pointLabels[n], r, l + a.lineHeight / 2, a, {
                                    color: o.color,
                                    textAlign: h,
                                    textBaseline: "middle"
                                })
                            }
                        }(this, o), s.display && this.ticks.forEach(((t, e) => {
                            if (0 !== e || 0 === e && this.min < 0) {
                                r = this.getDistanceFromCenterForValue(t.value);
                                const i = this.getContext(e),
                                    a = s.setContext(i),
                                    l = n.setContext(i);
                                ! function(t, e, i, s, n) {
                                    const o = t.ctx,
                                        a = e.circular,
                                        {
                                            color: r,
                                            lineWidth: l
                                        } = e;
                                    !a && !s || !r || !l || i < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash), o.lineDashOffset = n.dashOffset, o.beginPath(), Lo(t, i, a, s), o.closePath(), o.stroke(), o.restore())
                                }(this, a, r, o, l)
                            }
                        })), i.display) {
                        for (t.save(), a = o - 1; a >= 0; a--) {
                            const s = i.setContext(this.getPointLabelContext(a)),
                                {
                                    color: n,
                                    lineWidth: o
                                } = s;
                            o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke())
                        }
                        t.restore()
                    }
                }
                drawBorder() {}
                drawLabels() {
                    const t = this.ctx,
                        e = this.options,
                        i = e.ticks;
                    if (!i.display) return;
                    const s = this.getIndexAngle(0);
                    let n, o;
                    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach(((s, a) => {
                        if (0 === a && this.min >= 0 && !e.reverse) return;
                        const r = i.setContext(this.getContext(a)),
                            l = Si(r.font);
                        if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {
                            t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;
                            const e = ki(r.backdropPadding);
                            t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height)
                        }
                        Ne(t, s.label, 0, -n, l, {
                            color: r.color,
                            strokeColor: r.textStrokeColor,
                            strokeWidth: r.textStrokeWidth
                        })
                    })), t.restore()
                }
                drawTitle() {}
            }
            const Ro = {
                    millisecond: {
                        common: !0,
                        size: 1,
                        steps: 1e3
                    },
                    second: {
                        common: !0,
                        size: 1e3,
                        steps: 60
                    },
                    minute: {
                        common: !0,
                        size: 6e4,
                        steps: 60
                    },
                    hour: {
                        common: !0,
                        size: 36e5,
                        steps: 24
                    },
                    day: {
                        common: !0,
                        size: 864e5,
                        steps: 30
                    },
                    week: {
                        common: !1,
                        size: 6048e5,
                        steps: 4
                    },
                    month: {
                        common: !0,
                        size: 2628e6,
                        steps: 12
                    },
                    quarter: {
                        common: !1,
                        size: 7884e6,
                        steps: 4
                    },
                    year: {
                        common: !0,
                        size: 3154e7
                    }
                },
                Io = Object.keys(Ro);

            function zo(t, e) {
                return t - e
            }

            function Fo(t, e) {
                if (s(e)) return null;
                const i = t._adapter,
                    {
                        parser: n,
                        round: o,
                        isoWeekday: r
                    } = t._parseOpts;
                let l = e;
                return "function" == typeof n && (l = n(l)), a(l) || (l = "string" == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o && (l = "week" !== o || !N(r) && !0 !== r ? i.startOf(l, o) : i.startOf(l, "isoWeek", r)), +l)
            }

            function Vo(t, e, i, s) {
                const n = Io.length;
                for (let o = Io.indexOf(t); o < n - 1; ++o) {
                    const t = Ro[Io[o]],
                        n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;
                    if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return Io[o]
                }
                return Io[n - 1]
            }

            function Bo(t, e, i) {
                if (i) {
                    if (i.length) {
                        const {
                            lo: s,
                            hi: n
                        } = et(i, e);
                        t[i[s] >= e ? i[s] : i[n]] = !0
                    }
                } else t[e] = !0
            }

            function Wo(t, e, i) {
                const s = [],
                    n = {},
                    o = e.length;
                let a, r;
                for (a = 0; a < o; ++a) r = e[a], n[r] = a, s.push({
                    value: r,
                    major: !1
                });
                return 0 !== o && i ? function(t, e, i, s) {
                    const n = t._adapter,
                        o = +n.startOf(e[0].value, s),
                        a = e[e.length - 1].value;
                    let r, l;
                    for (r = o; r <= a; r = +n.add(r, 1, s)) l = i[r], l >= 0 && (e[l].major = !0);
                    return e
                }(t, s, n, i) : s
            }
            class No extends Js {
                static id = "time";
                static defaults = {
                    bounds: "data",
                    adapters: {},
                    time: {
                        parser: !1,
                        unit: !1,
                        round: !1,
                        isoWeekday: !1,
                        minUnit: "millisecond",
                        displayFormats: {}
                    },
                    ticks: {
                        source: "auto",
                        callback: !1,
                        major: {
                            enabled: !1
                        }
                    }
                };
                constructor(t) {
                    super(t), this._cache = {
                        data: [],
                        labels: [],
                        all: []
                    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
                }
                init(t, e = {}) {
                    const i = t.time || (t.time = {}),
                        s = this._adapter = new Rn._date(t.adapters.date);
                    s.init(e), x(i.displayFormats, s.formats()), this._parseOpts = {
                        parser: i.parser,
                        round: i.round,
                        isoWeekday: i.isoWeekday
                    }, super.init(t), this._normalized = e.normalized
                }
                parse(t, e) {
                    return void 0 === t ? null : Fo(this, t)
                }
                beforeLayout() {
                    super.beforeLayout(), this._cache = {
                        data: [],
                        labels: [],
                        all: []
                    }
                }
                determineDataLimits() {
                    const t = this.options,
                        e = this._adapter,
                        i = t.time.unit || "day";
                    let {
                        min: s,
                        max: n,
                        minDefined: o,
                        maxDefined: r
                    } = this.getUserBounds();

                    function l(t) {
                        o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max))
                    }
                    o && r || (l(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || l(this.getMinMax(!1))), s = a(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n)
                }
                _getLabelBounds() {
                    const t = this.getLabelTimestamps();
                    let e = Number.POSITIVE_INFINITY,
                        i = Number.NEGATIVE_INFINITY;
                    return t.length && (e = t[0], i = t[t.length - 1]), {
                        min: e,
                        max: i
                    }
                }
                buildTicks() {
                    const t = this.options,
                        e = t.time,
                        i = t.ticks,
                        s = "labels" === i.source ? this.getLabelTimestamps() : this._generate();
                    "ticks" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
                    const n = this.min,
                        o = nt(s, n, this.max);
                    return this._unit = e.unit || (i.autoSkip ? Vo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function(t, e, i, s, n) {
                        for (let o = Io.length - 1; o >= Io.indexOf(i); o--) {
                            const i = Io[o];
                            if (Ro[i].common && t._adapter.diff(n, s, i) >= e - 1) return i
                        }
                        return Io[i ? Io.indexOf(i) : 0]
                    }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && "year" !== this._unit ? function(t) {
                        for (let e = Io.indexOf(t) + 1, i = Io.length; e < i; ++e)
                            if (Ro[Io[e]].common) return Io[e]
                    }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), Wo(this, o, this._majorUnit)
                }
                afterAutoSkip() {
                    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t => +t.value)))
                }
                initOffsets(t = []) {
                    let e, i, s = 0,
                        n = 0;
                    this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);
                    const o = t.length < 3 ? .5 : .25;
                    s = J(s, 0, o), n = J(n, 0, o), this._offsets = {
                        start: s,
                        end: n,
                        factor: 1 / (s + 1 + n)
                    }
                }
                _generate() {
                    const t = this._adapter,
                        e = this.min,
                        i = this.max,
                        s = this.options,
                        n = s.time,
                        o = n.unit || Vo(n.minUnit, e, i, this._getLabelCapacity(e)),
                        a = l(s.ticks.stepSize, 1),
                        r = "week" === o && n.isoWeekday,
                        h = N(r) || !0 === r,
                        c = {};
                    let d, u, f = e;
                    if (h && (f = +t.startOf(f, "isoWeek", r)), f = +t.startOf(f, h ? "day" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + " and " + i + " are too far apart with stepSize of " + a + " " + o);
                    const g = "data" === s.ticks.source && this.getDataTimestamps();
                    for (d = f, u = 0; d < i; d = +t.add(d, a, o), u++) Bo(c, d, g);
                    return d !== i && "ticks" !== s.bounds && 1 !== u || Bo(c, d, g), Object.keys(c).sort(zo).map((t => +t))
                }
                getLabelForValue(t) {
                    const e = this._adapter,
                        i = this.options.time;
                    return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)
                }
                format(t, e) {
                    const i = this.options.time.displayFormats,
                        s = this._unit,
                        n = e || i[s];
                    return this._adapter.format(t, n)
                }
                _tickFormatFunction(t, e, i, s) {
                    const n = this.options,
                        o = n.ticks.callback;
                    if (o) return d(o, [t, e, i], this);
                    const a = n.time.displayFormats,
                        r = this._unit,
                        l = this._majorUnit,
                        h = r && a[r],
                        c = l && a[l],
                        u = i[e],
                        f = l && c && u && u.major;
                    return this._adapter.format(t, s || (f ? c : h))
                }
                generateTickLabels(t) {
                    let e, i, s;
                    for (e = 0, i = t.length; e < i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t)
                }
                getDecimalForValue(t) {
                    return null === t ? NaN : (t - this.min) / (this.max - this.min)
                }
                getPixelForValue(t) {
                    const e = this._offsets,
                        i = this.getDecimalForValue(t);
                    return this.getPixelForDecimal((e.start + i) * e.factor)
                }
                getValueForPixel(t) {
                    const e = this._offsets,
                        i = this.getDecimalForPixel(t) / e.factor - e.end;
                    return this.min + i * (this.max - this.min)
                }
                _getLabelSize(t) {
                    const e = this.options.ticks,
                        i = this.ctx.measureText(t).width,
                        s = $(this.isHorizontal() ? e.maxRotation : e.minRotation),
                        n = Math.cos(s),
                        o = Math.sin(s),
                        a = this._resolveTickFontOptions(0).size;
                    return {
                        w: i * n + a * o,
                        h: i * o + a * n
                    }
                }
                _getLabelCapacity(t) {
                    const e = this.options.time,
                        i = e.displayFormats,
                        s = i[e.unit] || i.millisecond,
                        n = this._tickFormatFunction(t, 0, Wo(this, [t], this._majorUnit), s),
                        o = this._getLabelSize(n),
                        a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
                    return a > 0 ? a : 1
                }
                getDataTimestamps() {
                    let t, e, i = this._cache.data || [];
                    if (i.length) return i;
                    const s = this.getMatchingVisibleMetas();
                    if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);
                    for (t = 0, e = s.length; t < e; ++t) i = i.concat(s[t].controller.getAllParsedValues(this));
                    return this._cache.data = this.normalize(i)
                }
                getLabelTimestamps() {
                    const t = this._cache.labels || [];
                    let e, i;
                    if (t.length) return t;
                    const s = this.getLabels();
                    for (e = 0, i = s.length; e < i; ++e) t.push(Fo(this, s[e]));
                    return this._cache.labels = this._normalized ? t : this.normalize(t)
                }
                normalize(t) {
                    return lt(t.sort(zo))
                }
            }

            function Ho(t, e, i) {
                let s, n, o, a, r = 0,
                    l = t.length - 1;
                i ? (e >= t[r].pos && e <= t[l].pos && ({
                    lo: r,
                    hi: l
                } = it(t, "pos", e)), ({
                    pos: s,
                    time: o
                } = t[r]), ({
                    pos: n,
                    time: a
                } = t[l])) : (e >= t[r].time && e <= t[l].time && ({
                    lo: r,
                    hi: l
                } = it(t, "time", e)), ({
                    time: s,
                    pos: o
                } = t[r]), ({
                    time: n,
                    pos: a
                } = t[l]));
                const h = n - s;
                return h ? o + (a - o) * (e - s) / h : o
            }
            var jo = Object.freeze({
                __proto__: null,
                CategoryScale: class extends Js {
                    static id = "category";
                    static defaults = {
                        ticks: {
                            callback: po
                        }
                    };
                    constructor(t) {
                        super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = []
                    }
                    init(t) {
                        const e = this._addedLabels;
                        if (e.length) {
                            const t = this.getLabels();
                            for (const {
                                    index: i,
                                    label: s
                                }
                                of e) t[i] === s && t.splice(i, 1);
                            this._addedLabels = []
                        }
                        super.init(t)
                    }
                    parse(t, e) {
                        if (s(t)) return null;
                        const i = this.getLabels();
                        return ((t, e) => null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : go(i, t, l(e, t), this._addedLabels), i.length - 1)
                    }
                    determineDataLimits() {
                        const {
                            minDefined: t,
                            maxDefined: e
                        } = this.getUserBounds();
                        let {
                            min: i,
                            max: s
                        } = this.getMinMax(!0);
                        "ticks" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s
                    }
                    buildTicks() {
                        const t = this.min,
                            e = this.max,
                            i = this.options.offset,
                            s = [];
                        let n = this.getLabels();
                        n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);
                        for (let i = t; i <= e; i++) s.push({
                            value: i
                        });
                        return s
                    }
                    getLabelForValue(t) {
                        return po.call(this, t)
                    }
                    configure() {
                        super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
                    }
                    getPixelForValue(t) {
                        return "number" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
                    }
                    getPixelForTick(t) {
                        const e = this.ticks;
                        return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
                    }
                    getValueForPixel(t) {
                        return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
                    }
                    getBasePixel() {
                        return this.bottom
                    }
                },
                LinearScale: xo,
                LogarithmicScale: ko,
                RadialLinearScale: Eo,
                TimeScale: No,
                TimeSeriesScale: class extends No {
                    static id = "timeseries";
                    static defaults = No.defaults;
                    constructor(t) {
                        super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0
                    }
                    initOffsets() {
                        const t = this._getTimestampsForTable(),
                            e = this._table = this.buildLookupTable(t);
                        this._minPos = Ho(e, this.min), this._tableRange = Ho(e, this.max) - this._minPos, super.initOffsets(t)
                    }
                    buildLookupTable(t) {
                        const {
                            min: e,
                            max: i
                        } = this, s = [], n = [];
                        let o, a, r, l, h;
                        for (o = 0, a = t.length; o < a; ++o) l = t[o], l >= e && l <= i && s.push(l);
                        if (s.length < 2) return [{
                            time: e,
                            pos: 0
                        }, {
                            time: i,
                            pos: 1
                        }];
                        for (o = 0, a = s.length; o < a; ++o) h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({
                            time: l,
                            pos: o / (a - 1)
                        });
                        return n
                    }
                    _generate() {
                        const t = this.min,
                            e = this.max;
                        let i = super.getDataTimestamps();
                        return i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort(((t, e) => t - e))
                    }
                    _getTimestampsForTable() {
                        let t = this._cache.all || [];
                        if (t.length) return t;
                        const e = this.getDataTimestamps(),
                            i = this.getLabelTimestamps();
                        return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t
                    }
                    getDecimalForValue(t) {
                        return (Ho(this._table, t) - this._minPos) / this._tableRange
                    }
                    getValueForPixel(t) {
                        const e = this._offsets,
                            i = this.getDecimalForPixel(t) / e.factor - e.end;
                        return Ho(this._table, i * this._tableRange + this._minPos, !0)
                    }
                }
            });
            const $o = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"],
                Yo = $o.map((t => t.replace("rgb(", "rgba(").replace(")", ", 0.5)")));

            function Uo(t) {
                return $o[t % $o.length]
            }

            function Xo(t) {
                return Yo[t % Yo.length]
            }

            function qo(t) {
                let e = 0;
                return (i, s) => {
                    const n = t.getDatasetMeta(s).controller;
                    n instanceof jn ? e = function(t, e) {
                        return t.backgroundColor = t.data.map((() => Uo(e++))), e
                    }(i, e) : n instanceof $n ? e = function(t, e) {
                        return t.backgroundColor = t.data.map((() => Xo(e++))), e
                    }(i, e) : n && (e = function(t, e) {
                        return t.borderColor = Uo(e), t.backgroundColor = Xo(e), ++e
                    }(i, e))
                }
            }

            function Ko(t) {
                let e;
                for (e in t)
                    if (t[e].borderColor || t[e].backgroundColor) return !0;
                return !1
            }
            var Go = {
                id: "colors",
                defaults: {
                    enabled: !0,
                    forceOverride: !1
                },
                beforeLayout(t, e, i) {
                    if (!i.enabled) return;
                    const {
                        data: {
                            datasets: s
                        },
                        options: n
                    } = t.config, {
                        elements: o
                    } = n;
                    if (!i.forceOverride && (Ko(s) || (a = n) && (a.borderColor || a.backgroundColor) || o && Ko(o))) return;
                    var a;
                    const r = qo(t);
                    s.forEach(r)
                }
            };

            function Zo(t) {
                if (t._decimated) {
                    const e = t._data;
                    delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        value: e
                    })
                }
            }

            function Jo(t) {
                t.data.datasets.forEach((t => {
                    Zo(t)
                }))
            }
            var Qo = {
                id: "decimation",
                defaults: {
                    algorithm: "min-max",
                    enabled: !1
                },
                beforeElementsUpdate: (t, e, i) => {
                    if (!i.enabled) return void Jo(t);
                    const n = t.width;
                    t.data.datasets.forEach(((e, o) => {
                        const {
                            _data: a,
                            indexAxis: r
                        } = e, l = t.getDatasetMeta(o), h = a || e.data;
                        if ("y" === Pi([r, t.options.indexAxis])) return;
                        if (!l.controller.supportsDecimation) return;
                        const c = t.scales[l.xAxisID];
                        if ("linear" !== c.type && "time" !== c.type) return;
                        if (t.options.parsing) return;
                        let {
                            start: d,
                            count: u
                        } = function(t, e) {
                            const i = e.length;
                            let s, n = 0;
                            const {
                                iScale: o
                            } = t, {
                                min: a,
                                max: r,
                                minDefined: l,
                                maxDefined: h
                            } = o.getUserBounds();
                            return l && (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n : i - n, {
                                start: n,
                                count: s
                            }
                        }(l, h);
                        if (u <= (i.threshold || 4 * n)) return void Zo(e);
                        let f;
                        switch (s(a) && (e._data = h, delete e.data, Object.defineProperty(e, "data", {
                            configurable: !0,
                            enumerable: !0,
                            get: function() {
                                return this._decimated
                            },
                            set: function(t) {
                                this._data = t
                            }
                        })), i.algorithm) {
                            case "lttb":
                                f = function(t, e, i, s, n) {
                                    const o = n.samples || s;
                                    if (o >= i) return t.slice(e, e + i);
                                    const a = [],
                                        r = (i - 2) / (o - 2);
                                    let l = 0;
                                    const h = e + i - 1;
                                    let c, d, u, f, g, p = e;
                                    for (a[l++] = t[p], c = 0; c < o - 2; c++) {
                                        let s, n = 0,
                                            o = 0;
                                        const h = Math.floor((c + 1) * r) + 1 + e,
                                            m = Math.min(Math.floor((c + 2) * r) + 1, i) + e,
                                            b = m - h;
                                        for (s = h; s < m; s++) n += t[s].x, o += t[s].y;
                                        n /= b, o /= b;
                                        const x = Math.floor(c * r) + 1 + e,
                                            _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e,
                                            {
                                                x: y,
                                                y: v
                                            } = t[p];
                                        for (u = f = -1, s = x; s < _; s++) f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);
                                        a[l++] = d, p = g
                                    }
                                    return a[l++] = t[h], a
                                }(h, d, u, n, i);
                                break;
                            case "min-max":
                                f = function(t, e, i, n) {
                                    let o, a, r, l, h, c, d, u, f, g, p = 0,
                                        m = 0;
                                    const b = [],
                                        x = e + i - 1,
                                        _ = t[e].x,
                                        y = t[x].x - _;
                                    for (o = e; o < e + i; ++o) {
                                        a = t[o], r = (a.x - _) / y * n, l = a.y;
                                        const e = 0 | r;
                                        if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;
                                        else {
                                            const i = o - 1;
                                            if (!s(c) && !s(d)) {
                                                const e = Math.min(c, d),
                                                    s = Math.max(c, d);
                                                e !== u && e !== i && b.push({...t[e],
                                                    x: p
                                                }), s !== u && s !== i && b.push({...t[s],
                                                    x: p
                                                })
                                            }
                                            o > 0 && i !== u && b.push(t[i]), b.push(a), h = e, m = 0, f = g = l, c = d = u = o
                                        }
                                    }
                                    return b
                                }(h, d, u, n);
                                break;
                            default:
                                throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)
                        }
                        e._decimated = f
                    }))
                },
                destroy(t) {
                    Jo(t)
                }
            };

            function ta(t, e, i, s) {
                if (s) return;
                let n = e[t],
                    o = i[t];
                return "angle" === t && (n = G(n), o = G(o)), {
                    property: t,
                    start: n,
                    end: o
                }
            }

            function ea(t, e, i) {
                for (; e > t; e--) {
                    const t = i[e];
                    if (!isNaN(t.x) && !isNaN(t.y)) break
                }
                return e
            }

            function ia(t, e, i, s) {
                return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0
            }

            function sa(t, e) {
                let i = [],
                    s = !1;
                return n(t) ? (s = !0, i = t) : i = function(t, e) {
                    const {
                        x: i = null,
                        y: s = null
                    } = t || {}, n = e.points, o = [];
                    return e.segments.forEach((({
                        start: t,
                        end: e
                    }) => {
                        e = ea(t, e, n);
                        const a = n[t],
                            r = n[e];
                        null !== s ? (o.push({
                            x: a.x,
                            y: s
                        }), o.push({
                            x: r.x,
                            y: s
                        })) : null !== i && (o.push({
                            x: i,
                            y: a.y
                        }), o.push({
                            x: i,
                            y: r.y
                        }))
                    })), o
                }(t, e), i.length ? new no({
                    points: i,
                    options: {
                        tension: 0
                    },
                    _loop: s,
                    _fullLoop: s
                }) : null
            }

            function na(t) {
                return t && !1 !== t.fill
            }

            function oa(t, e, i) {
                let s = t[e].fill;
                const n = [e];
                let o;
                if (!i) return s;
                for (; !1 !== s && -1 === n.indexOf(s);) {
                    if (!a(s)) return s;
                    if (o = t[s], !o) return !1;
                    if (o.visible) return s;
                    n.push(s), s = o.fill
                }
                return !1
            }

            function aa(t, e, i) {
                const s = function(t) {
                    const e = t.options,
                        i = e.fill;
                    let s = l(i && i.target, i);
                    void 0 === s && (s = !!e.backgroundColor);
                    if (!1 === s || null === s) return !1;
                    if (!0 === s) return "origin";
                    return s
                }(t);
                if (o(s)) return !isNaN(s.value) && s;
                let n = parseFloat(s);
                return a(n) && Math.floor(n) === n ? function(t, e, i, s) {
                    "-" !== t && "+" !== t || (i = e + i);
                    if (i === e || i < 0 || i >= s) return !1;
                    return i
                }(s[0], e, n, i) : ["origin", "start", "end", "stack", "shape"].indexOf(s) >= 0 && s
            }

            function ra(t, e, i) {
                const s = [];
                for (let n = 0; n < i.length; n++) {
                    const o = i[n],
                        {
                            first: a,
                            last: r,
                            point: l
                        } = la(o, e, "x");
                    if (!(!l || a && r))
                        if (a) s.unshift(l);
                        else if (t.push(l), !r) break
                }
                t.push(...s)
            }

            function la(t, e, i) {
                const s = t.interpolate(e, i);
                if (!s) return {};
                const n = s[i],
                    o = t.segments,
                    a = t.points;
                let r = !1,
                    l = !1;
                for (let t = 0; t < o.length; t++) {
                    const e = o[t],
                        s = a[e.start][i],
                        h = a[e.end][i];
                    if (tt(n, s, h)) {
                        r = n === s, l = n === h;
                        break
                    }
                }
                return {
                    first: r,
                    last: l,
                    point: s
                }
            }
            class ha {
                constructor(t) {
                    this.x = t.x, this.y = t.y, this.radius = t.radius
                }
                pathSegment(t, e, i) {
                    const {
                        x: s,
                        y: n,
                        radius: o
                    } = this;
                    return e = e || {
                        start: 0,
                        end: O
                    }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds
                }
                interpolate(t) {
                    const {
                        x: e,
                        y: i,
                        radius: s
                    } = this, n = t.angle;
                    return {
                        x: e + Math.cos(n) * s,
                        y: i + Math.sin(n) * s,
                        angle: n
                    }
                }
            }

            function ca(t) {
                const {
                    chart: e,
                    fill: i,
                    line: s
                } = t;
                if (a(i)) return function(t, e) {
                    const i = t.getDatasetMeta(e),
                        s = i && t.isDatasetVisible(e);
                    return s ? i.dataset : null
                }(e, i);
                if ("stack" === i) return function(t) {
                    const {
                        scale: e,
                        index: i,
                        line: s
                    } = t, n = [], o = s.segments, a = s.points, r = function(t, e) {
                        const i = [],
                            s = t.getMatchingVisibleMetas("line");
                        for (let t = 0; t < s.length; t++) {
                            const n = s[t];
                            if (n.index === e) break;
                            n.hidden || i.unshift(n.dataset)
                        }
                        return i
                    }(e, i);
                    r.push(sa({
                        x: null,
                        y: e.bottom
                    }, s));
                    for (let t = 0; t < o.length; t++) {
                        const e = o[t];
                        for (let t = e.start; t <= e.end; t++) ra(n, a[t], r)
                    }
                    return new no({
                        points: n,
                        options: {}
                    })
                }(t);
                if ("shape" === i) return !0;
                const n = function(t) {
                    const e = t.scale || {};
                    if (e.getPointPositionForValue) return function(t) {
                        const {
                            scale: e,
                            fill: i
                        } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function(t, e, i) {
                            let s;
                            return s = "start" === t ? i : "end" === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s
                        }(i, e, a), l = [];
                        if (s.grid.circular) {
                            const t = e.getPointPositionForValue(0, a);
                            return new ha({
                                x: t.x,
                                y: t.y,
                                radius: e.getDistanceFromCenterForValue(r)
                            })
                        }
                        for (let t = 0; t < n; ++t) l.push(e.getPointPositionForValue(t, r));
                        return l
                    }(t);
                    return function(t) {
                        const {
                            scale: e = {},
                            fill: i
                        } = t, s = function(t, e) {
                            let i = null;
                            return "start" === t ? i = e.bottom : "end" === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i
                        }(i, e);
                        if (a(s)) {
                            const t = e.isHorizontal();
                            return {
                                x: t ? s : null,
                                y: t ? null : s
                            }
                        }
                        return null
                    }(t)
                }(t);
                return n instanceof ha ? n : sa(n, s)
            }

            function da(t, e, i) {
                const s = ca(e),
                    {
                        line: n,
                        scale: o,
                        axis: a
                    } = e,
                    r = n.options,
                    l = r.fill,
                    h = r.backgroundColor,
                    {
                        above: c = h,
                        below: d = h
                    } = l || {};
                s && n.points.length && (Ie(t, i), function(t, e) {
                    const {
                        line: i,
                        target: s,
                        above: n,
                        below: o,
                        area: a,
                        scale: r
                    } = e, l = i._loop ? "angle" : e.axis;
                    t.save(), "x" === l && o !== n && (ua(t, s, a.top), fa(t, {
                        line: i,
                        target: s,
                        color: n,
                        scale: r,
                        property: l
                    }), t.restore(), t.save(), ua(t, s, a.bottom));
                    fa(t, {
                        line: i,
                        target: s,
                        color: o,
                        scale: r,
                        property: l
                    }), t.restore()
                }(t, {
                    line: n,
                    target: s,
                    above: c,
                    below: d,
                    area: i,
                    scale: o,
                    axis: a
                }), ze(t))
            }

            function ua(t, e, i) {
                const {
                    segments: s,
                    points: n
                } = e;
                let o = !0,
                    a = !1;
                t.beginPath();
                for (const r of s) {
                    const {
                        start: s,
                        end: l
                    } = r, h = n[s], c = n[ea(s, l, n)];
                    o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {
                        move: a
                    }), a ? t.closePath() : t.lineTo(c.x, i)
                }
                t.lineTo(e.first().x, i), t.closePath(), t.clip()
            }

            function fa(t, e) {
                const {
                    line: i,
                    target: s,
                    property: n,
                    color: o,
                    scale: a
                } = e, r = function(t, e, i) {
                    const s = t.segments,
                        n = t.points,
                        o = e.points,
                        a = [];
                    for (const t of s) {
                        let {
                            start: s,
                            end: r
                        } = t;
                        r = ea(s, r, n);
                        const l = ta(i, n[s], n[r], t.loop);
                        if (!e.segments) {
                            a.push({
                                source: t,
                                target: l,
                                start: n[s],
                                end: n[r]
                            });
                            continue
                        }
                        const h = Ii(e, l);
                        for (const e of h) {
                            const s = ta(i, o[e.start], o[e.end], e.loop),
                                r = Ri(t, n, s);
                            for (const t of r) a.push({
                                source: t,
                                target: e,
                                start: {
                                    [i]: ia(l, s, "start", Math.max)
                                },
                                end: {
                                    [i]: ia(l, s, "end", Math.min)
                                }
                            })
                        }
                    }
                    return a
                }(i, s, n);
                for (const {
                        source: e,
                        target: l,
                        start: h,
                        end: c
                    }
                    of r) {
                    const {
                        style: {
                            backgroundColor: r = o
                        } = {}
                    } = e, d = !0 !== s;
                    t.save(), t.fillStyle = r, ga(t, a, d && ta(n, h, c)), t.beginPath();
                    const u = !!i.pathSegment(t, e);
                    let f;
                    if (d) {
                        u ? t.closePath() : pa(t, s, c, n);
                        const e = !!s.pathSegment(t, l, {
                            move: u,
                            reverse: !0
                        });
                        f = u && e, f || pa(t, s, h, n)
                    }
                    t.closePath(), t.fill(f ? "evenodd" : "nonzero"), t.restore()
                }
            }

            function ga(t, e, i) {
                const {
                    top: s,
                    bottom: n
                } = e.chart.chartArea, {
                    property: o,
                    start: a,
                    end: r
                } = i || {};
                "x" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip())
            }

            function pa(t, e, i, s) {
                const n = e.interpolate(i, s);
                n && t.lineTo(n.x, n.y)
            }
            var ma = {
                id: "filler",
                afterDatasetsUpdate(t, e, i) {
                    const s = (t.data.datasets || []).length,
                        n = [];
                    let o, a, r, l;
                    for (a = 0; a < s; ++a) o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof no && (l = {
                        visible: t.isDatasetVisible(a),
                        index: a,
                        fill: aa(r, a, s),
                        chart: t,
                        axis: o.controller.options.indexAxis,
                        scale: o.vScale,
                        line: r
                    }), o.$filler = l, n.push(l);
                    for (a = 0; a < s; ++a) l = n[a], l && !1 !== l.fill && (l.fill = oa(n, a, i.propagate))
                },
                beforeDraw(t, e, i) {
                    const s = "beforeDraw" === i.drawTime,
                        n = t.getSortedVisibleDatasetMetas(),
                        o = t.chartArea;
                    for (let e = n.length - 1; e >= 0; --e) {
                        const i = n[e].$filler;
                        i && (i.line.updateControlPoints(o, i.axis), s && i.fill && da(t.ctx, i, o))
                    }
                },
                beforeDatasetsDraw(t, e, i) {
                    if ("beforeDatasetsDraw" !== i.drawTime) return;
                    const s = t.getSortedVisibleDatasetMetas();
                    for (let e = s.length - 1; e >= 0; --e) {
                        const i = s[e].$filler;
                        na(i) && da(t.ctx, i, t.chartArea)
                    }
                },
                beforeDatasetDraw(t, e, i) {
                    const s = e.meta.$filler;
                    na(s) && "beforeDatasetDraw" === i.drawTime && da(t.ctx, s, t.chartArea)
                },
                defaults: {
                    propagate: !0,
                    drawTime: "beforeDatasetDraw"
                }
            };
            const ba = (t, e) => {
                let {
                    boxHeight: i = e,
                    boxWidth: s = e
                } = t;
                return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {
                    boxWidth: s,
                    boxHeight: i,
                    itemHeight: Math.max(e, i)
                }
            };
            class xa extends Hs {
                constructor(t) {
                    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
                }
                update(t, e, i) {
                    this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit()
                }
                setDimensions() {
                    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height)
                }
                buildLabels() {
                    const t = this.options.labels || {};
                    let e = d(t.generateLabels, [this.chart], this) || [];
                    t.filter && (e = e.filter((e => t.filter(e, this.chart.data)))), t.sort && (e = e.sort(((e, i) => t.sort(e, i, this.chart.data)))), this.options.reverse && e.reverse(), this.legendItems = e
                }
                fit() {
                    const {
                        options: t,
                        ctx: e
                    } = this;
                    if (!t.display) return void(this.width = this.height = 0);
                    const i = t.labels,
                        s = Si(i.font),
                        n = s.size,
                        o = this._computeTitleHeight(),
                        {
                            boxWidth: a,
                            itemHeight: r
                        } = ba(i, n);
                    let l, h;
                    e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight)
                }
                _fitRows(t, e, i, s) {
                    const {
                        ctx: n,
                        maxWidth: o,
                        options: {
                            labels: {
                                padding: a
                            }
                        }
                    } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [0], h = s + a;
                    let c = t;
                    n.textAlign = "left", n.textBaseline = "middle";
                    let d = -1,
                        u = -h;
                    return this.legendItems.forEach(((t, f) => {
                        const g = i + e / 2 + n.measureText(t.text).width;
                        (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {
                            left: 0,
                            top: u,
                            row: d,
                            width: g,
                            height: s
                        }, l[l.length - 1] += g + a
                    })), c
                }
                _fitCols(t, e, i, s) {
                    const {
                        ctx: n,
                        maxHeight: o,
                        options: {
                            labels: {
                                padding: a
                            }
                        }
                    } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;
                    let c = a,
                        d = 0,
                        u = 0,
                        f = 0,
                        g = 0;
                    return this.legendItems.forEach(((t, o) => {
                        const {
                            itemWidth: p,
                            itemHeight: m
                        } = function(t, e, i, s, n) {
                            const o = function(t, e, i, s) {
                                    let n = t.text;
                                    n && "string" != typeof n && (n = n.reduce(((t, e) => t.length > e.length ? t : e)));
                                    return e + i.size / 2 + s.measureText(n).width
                                }(s, t, e, i),
                                a = function(t, e, i) {
                                    let s = t;
                                    "string" != typeof e.text && (s = _a(e, i));
                                    return s
                                }(n, s, e.lineHeight);
                            return {
                                itemWidth: o,
                                itemHeight: a
                            }
                        }(i, e, n, t, s);
                        o > 0 && u + m + 2 * a > h && (c += d + a, l.push({
                            width: d,
                            height: u
                        }), f += d + a, g++, d = u = 0), r[o] = {
                            left: f,
                            top: u,
                            col: g,
                            width: p,
                            height: m
                        }, d = Math.max(d, p), u += m + a
                    })), c += d, l.push({
                        width: d,
                        height: u
                    }), c
                }
                adjustHitBoxes() {
                    if (!this.options.display) return;
                    const t = this._computeTitleHeight(),
                        {
                            legendHitBoxes: e,
                            options: {
                                align: i,
                                labels: {
                                    padding: s
                                },
                                rtl: n
                            }
                        } = this,
                        o = Oi(n, this.left, this.width);
                    if (this.isHorizontal()) {
                        let n = 0,
                            a = ft(i, this.left + s, this.right - this.lineWidths[n]);
                        for (const r of e) n !== r.row && (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s
                    } else {
                        let n = 0,
                            a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height);
                        for (const r of e) r.col !== n && (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s
                    }
                }
                isHorizontal() {
                    return "top" === this.options.position || "bottom" === this.options.position
                }
                draw() {
                    if (this.options.display) {
                        const t = this.ctx;
                        Ie(t, this), this._draw(), ze(t)
                    }
                }
                _draw() {
                    const {
                        options: t,
                        columnSizes: e,
                        lineWidths: i,
                        ctx: s
                    } = this, {
                        align: n,
                        labels: o
                    } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), {
                        padding: c
                    } = o, d = h.size, u = d / 2;
                    let f;
                    this.drawTitle(), s.textAlign = r.textAlign("left"), s.textBaseline = "middle", s.lineWidth = .5, s.font = h.string;
                    const {
                        boxWidth: g,
                        boxHeight: p,
                        itemHeight: m
                    } = ba(o, d), b = this.isHorizontal(), x = this._computeTitleHeight();
                    f = b ? {
                        x: ft(n, this.left + c, this.right - i[0]),
                        y: this.top + c + x,
                        line: 0
                    } : {
                        x: this.left + c,
                        y: ft(n, this.top + x + c, this.bottom - e[0].height),
                        line: 0
                    }, Ai(this.ctx, t.textDirection);
                    const _ = m + c;
                    this.legendItems.forEach(((y, v) => {
                        s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor;
                        const M = s.measureText(y.text).width,
                            w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)),
                            k = g + u + M;
                        let S = f.x,
                            P = f.y;
                        r.setWidth(this.width), b ? v > 0 && S + k + c > this.right && (P = f.y += _, f.line++, S = f.x = ft(n, this.left + c, this.right - i[f.line])) : v > 0 && P + _ > this.bottom && (S = f.x = S + e[f.line].width + c, f.line++, P = f.y = ft(n, this.top + x + c, this.bottom - e[f.line].height));
                        if (function(t, e, i) {
                                if (isNaN(g) || g <= 0 || isNaN(p) || p < 0) return;
                                s.save();
                                const n = l(i.lineWidth, 1);
                                if (s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, "butt"), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, "miter"), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle) {
                                    const a = {
                                            radius: p * Math.SQRT2 / 2,
                                            pointStyle: i.pointStyle,
                                            rotation: i.rotation,
                                            borderWidth: n
                                        },
                                        l = r.xPlus(t, g / 2);
                                    Ee(s, a, l, e + u, o.pointStyleWidth && g)
                                } else {
                                    const o = e + Math.max((d - p) / 2, 0),
                                        a = r.leftForLtr(t, g),
                                        l = wi(i.borderRadius);
                                    s.beginPath(), Object.values(l).some((t => 0 !== t)) ? He(s, {
                                        x: a,
                                        y: o,
                                        w: g,
                                        h: p,
                                        radius: l
                                    }) : s.rect(a, o, g, p), s.fill(), 0 !== n && s.stroke()
                                }
                                s.restore()
                            }(r.x(S), P, y), S = gt(w, S + g + u, b ? S + k : this.right, t.rtl), function(t, e, i) {
                                Ne(s, i.text, t, e + m / 2, h, {
                                    strikethrough: i.hidden,
                                    textAlign: r.textAlign(i.textAlign)
                                })
                            }(r.x(S), P, y), b) f.x += k + c;
                        else if ("string" != typeof y.text) {
                            const t = h.lineHeight;
                            f.y += _a(y, t) + c
                        } else f.y += _
                    })), Ti(this.ctx, t.textDirection)
                }
                drawTitle() {
                    const t = this.options,
                        e = t.title,
                        i = Si(e.font),
                        s = ki(e.padding);
                    if (!e.display) return;
                    const n = Oi(t.rtl, this.left, this.width),
                        o = this.ctx,
                        a = e.position,
                        r = i.size / 2,
                        l = s.top + r;
                    let h, c = this.left,
                        d = this.width;
                    if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);
                    else {
                        const e = this.columnSizes.reduce(((t, e) => Math.max(t, e.height)), 0);
                        h = l + ft(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight())
                    }
                    const u = ft(a, c, c + d);
                    o.textAlign = n.textAlign(ut(a)), o.textBaseline = "middle", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i)
                }
                _computeTitleHeight() {
                    const t = this.options.title,
                        e = Si(t.font),
                        i = ki(t.padding);
                    return t.display ? e.lineHeight + i.height : 0
                }
                _getLegendItemAt(t, e) {
                    let i, s, n;
                    if (tt(t, this.left, this.right) && tt(e, this.top, this.bottom))
                        for (n = this.legendHitBoxes, i = 0; i < n.length; ++i)
                            if (s = n[i], tt(t, s.left, s.left + s.width) && tt(e, s.top, s.top + s.height)) return this.legendItems[i];
                    return null
                }
                handleEvent(t) {
                    const e = this.options;
                    if (! function(t, e) {
                            if (("mousemove" === t || "mouseout" === t) && (e.onHover || e.onLeave)) return !0;
                            if (e.onClick && ("click" === t || "mouseup" === t)) return !0;
                            return !1
                        }(t.type, e)) return;
                    const i = this._getLegendItemAt(t.x, t.y);
                    if ("mousemove" === t.type || "mouseout" === t.type) {
                        const o = this._hoveredItem,
                            a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);
                        o && !a && d(e.onLeave, [t, o, this], this), this._hoveredItem = i, i && !a && d(e.onHover, [t, i, this], this)
                    } else i && d(e.onClick, [t, i, this], this);
                    var s, n
                }
            }

            function _a(t, e) {
                return e * (t.text ? t.text.length : 0)
            }
            var ya = {
                id: "legend",
                _element: xa,
                start(t, e, i) {
                    const s = t.legend = new xa({
                        ctx: t.ctx,
                        options: i,
                        chart: t
                    });
                    as.configure(t, s, i), as.addBox(t, s)
                },
                stop(t) {
                    as.removeBox(t, t.legend), delete t.legend
                },
                beforeUpdate(t, e, i) {
                    const s = t.legend;
                    as.configure(t, s, i), s.options = i
                },
                afterUpdate(t) {
                    const e = t.legend;
                    e.buildLabels(), e.adjustHitBoxes()
                },
                afterEvent(t, e) {
                    e.replay || t.legend.handleEvent(e.event)
                },
                defaults: {
                    display: !0,
                    position: "top",
                    align: "center",
                    fullSize: !0,
                    reverse: !1,
                    weight: 1e3,
                    onClick(t, e, i) {
                        const s = e.datasetIndex,
                            n = i.chart;
                        n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1)
                    },
                    onHover: null,
                    onLeave: null,
                    labels: {
                        color: t => t.chart.options.color,
                        boxWidth: 40,
                        padding: 10,
                        generateLabels(t) {
                            const e = t.data.datasets,
                                {
                                    labels: {
                                        usePointStyle: i,
                                        pointStyle: s,
                                        textAlign: n,
                                        color: o,
                                        useBorderRadius: a,
                                        borderRadius: r
                                    }
                                } = t.legend.options;
                            return t._getSortedDatasetMetas().map((t => {
                                const l = t.controller.getStyle(i ? 0 : void 0),
                                    h = ki(l.borderWidth);
                                return {
                                    text: e[t.index].label,
                                    fillStyle: l.backgroundColor,
                                    fontColor: o,
                                    hidden: !t.visible,
                                    lineCap: l.borderCapStyle,
                                    lineDash: l.borderDash,
                                    lineDashOffset: l.borderDashOffset,
                                    lineJoin: l.borderJoinStyle,
                                    lineWidth: (h.width + h.height) / 4,
                                    strokeStyle: l.borderColor,
                                    pointStyle: s || l.pointStyle,
                                    rotation: l.rotation,
                                    textAlign: n || l.textAlign,
                                    borderRadius: a && (r || l.borderRadius),
                                    datasetIndex: t.index
                                }
                            }), this)
                        }
                    },
                    title: {
                        color: t => t.chart.options.color,
                        display: !1,
                        position: "center",
                        text: ""
                    }
                },
                descriptors: {
                    _scriptable: t => !t.startsWith("on"),
                    labels: {
                        _scriptable: t => !["generateLabels", "filter", "sort"].includes(t)
                    }
                }
            };
            class va extends Hs {
                constructor(t) {
                    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
                }
                update(t, e) {
                    const i = this.options;
                    if (this.left = 0, this.top = 0, !i.display) return void(this.width = this.height = this.right = this.bottom = 0);
                    this.width = this.right = t, this.height = this.bottom = e;
                    const s = n(i.text) ? i.text.length : 1;
                    this._padding = ki(i.padding);
                    const o = s * Si(i.font).lineHeight + this._padding.height;
                    this.isHorizontal() ? this.height = o : this.width = o
                }
                isHorizontal() {
                    const t = this.options.position;
                    return "top" === t || "bottom" === t
                }
                _drawArgs(t) {
                    const {
                        top: e,
                        left: i,
                        bottom: s,
                        right: n,
                        options: o
                    } = this, a = o.align;
                    let r, l, h, c = 0;
                    return this.isHorizontal() ? (l = ft(a, i, n), h = e + t, r = n - i) : ("left" === o.position ? (l = i + t, h = ft(a, s, e), c = -.5 * C) : (l = n - t, h = ft(a, e, s), c = .5 * C), r = s - e), {
                        titleX: l,
                        titleY: h,
                        maxWidth: r,
                        rotation: c
                    }
                }
                draw() {
                    const t = this.ctx,
                        e = this.options;
                    if (!e.display) return;
                    const i = Si(e.font),
                        s = i.lineHeight / 2 + this._padding.top,
                        {
                            titleX: n,
                            titleY: o,
                            maxWidth: a,
                            rotation: r
                        } = this._drawArgs(s);
                    Ne(t, e.text, 0, 0, i, {
                        color: e.color,
                        maxWidth: a,
                        rotation: r,
                        textAlign: ut(e.align),
                        textBaseline: "middle",
                        translation: [n, o]
                    })
                }
            }
            var Ma = {
                id: "title",
                _element: va,
                start(t, e, i) {
                    ! function(t, e) {
                        const i = new va({
                            ctx: t.ctx,
                            options: e,
                            chart: t
                        });
                        as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i
                    }(t, i)
                },
                stop(t) {
                    const e = t.titleBlock;
                    as.removeBox(t, e), delete t.titleBlock
                },
                beforeUpdate(t, e, i) {
                    const s = t.titleBlock;
                    as.configure(t, s, i), s.options = i
                },
                defaults: {
                    align: "center",
                    display: !1,
                    font: {
                        weight: "bold"
                    },
                    fullSize: !0,
                    padding: 10,
                    position: "top",
                    text: "",
                    weight: 2e3
                },
                defaultRoutes: {
                    color: "color"
                },
                descriptors: {
                    _scriptable: !0,
                    _indexable: !1
                }
            };
            const wa = new WeakMap;
            var ka = {
                id: "subtitle",
                start(t, e, i) {
                    const s = new va({
                        ctx: t.ctx,
                        options: i,
                        chart: t
                    });
                    as.configure(t, s, i), as.addBox(t, s), wa.set(t, s)
                },
                stop(t) {
                    as.removeBox(t, wa.get(t)), wa.delete(t)
                },
                beforeUpdate(t, e, i) {
                    const s = wa.get(t);
                    as.configure(t, s, i), s.options = i
                },
                defaults: {
                    align: "center",
                    display: !1,
                    font: {
                        weight: "normal"
                    },
                    fullSize: !0,
                    padding: 0,
                    position: "top",
                    text: "",
                    weight: 1500
                },
                defaultRoutes: {
                    color: "color"
                },
                descriptors: {
                    _scriptable: !0,
                    _indexable: !1
                }
            };
            const Sa = {
                average(t) {
                    if (!t.length) return !1;
                    let e, i, s = new Set,
                        n = 0,
                        o = 0;
                    for (e = 0, i = t.length; e < i; ++e) {
                        const i = t[e].element;
                        if (i && i.hasValue()) {
                            const t = i.tooltipPosition();
                            s.add(t.x), n += t.y, ++o
                        }
                    }
                    return {
                        x: [...s].reduce(((t, e) => t + e)) / s.size,
                        y: n / o
                    }
                },
                nearest(t, e) {
                    if (!t.length) return !1;
                    let i, s, n, o = e.x,
                        a = e.y,
                        r = Number.POSITIVE_INFINITY;
                    for (i = 0, s = t.length; i < s; ++i) {
                        const s = t[i].element;
                        if (s && s.hasValue()) {
                            const t = q(e, s.getCenterPoint());
                            t < r && (r = t, n = s)
                        }
                    }
                    if (n) {
                        const t = n.tooltipPosition();
                        o = t.x, a = t.y
                    }
                    return {
                        x: o,
                        y: a
                    }
                }
            };

            function Pa(t, e) {
                return e && (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
            }

            function Da(t) {
                return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t
            }

            function Ca(t, e) {
                const {
                    element: i,
                    datasetIndex: s,
                    index: n
                } = e, o = t.getDatasetMeta(s).controller, {
                    label: a,
                    value: r
                } = o.getLabelAndValue(n);
                return {
                    chart: t,
                    label: a,
                    parsed: o.getParsed(n),
                    raw: t.data.datasets[s].data[n],
                    formattedValue: r,
                    dataset: o.getDataset(),
                    dataIndex: n,
                    datasetIndex: s,
                    element: i
                }
            }

            function Oa(t, e) {
                const i = t.chart.ctx,
                    {
                        body: s,
                        footer: n,
                        title: o
                    } = t,
                    {
                        boxWidth: a,
                        boxHeight: r
                    } = e,
                    l = Si(e.bodyFont),
                    h = Si(e.titleFont),
                    c = Si(e.footerFont),
                    d = o.length,
                    f = n.length,
                    g = s.length,
                    p = ki(e.padding);
                let m = p.height,
                    b = 0,
                    x = s.reduce(((t, e) => t + e.before.length + e.lines.length + e.after.length), 0);
                if (x += t.beforeBody.length + t.afterBody.length, d && (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), x) {
                    m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (x - g) * l.lineHeight + (x - 1) * e.bodySpacing
                }
                f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);
                let _ = 0;
                const y = function(t) {
                    b = Math.max(b, i.measureText(t).width + _)
                };
                return i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t => {
                    u(t.before, y), u(t.lines, y), u(t.after, y)
                })), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), b += p.width, {
                    width: b,
                    height: m
                }
            }

            function Aa(t, e, i, s) {
                const {
                    x: n,
                    width: o
                } = i, {
                    width: a,
                    chartArea: {
                        left: r,
                        right: l
                    }
                } = t;
                let h = "center";
                return "center" === s ? h = n <= (r + l) / 2 ? "left" : "right" : n <= o / 2 ? h = "left" : n >= a - o / 2 && (h = "right"),
                    function(t, e, i, s) {
                        const {
                            x: n,
                            width: o
                        } = s, a = i.caretSize + i.caretPadding;
                        return "left" === t && n + o + a > e.width || "right" === t && n - o - a < 0 || void 0
                    }(h, t, e, i) && (h = "center"), h
            }

            function Ta(t, e, i) {
                const s = i.yAlign || e.yAlign || function(t, e) {
                    const {
                        y: i,
                        height: s
                    } = e;
                    return i < s / 2 ? "top" : i > t.height - s / 2 ? "bottom" : "center"
                }(t, i);
                return {
                    xAlign: i.xAlign || e.xAlign || Aa(t, e, i, s),
                    yAlign: s
                }
            }

            function La(t, e, i, s) {
                const {
                    caretSize: n,
                    caretPadding: o,
                    cornerRadius: a
                } = t, {
                    xAlign: r,
                    yAlign: l
                } = i, h = n + o, {
                    topLeft: c,
                    topRight: d,
                    bottomLeft: u,
                    bottomRight: f
                } = wi(a);
                let g = function(t, e) {
                    let {
                        x: i,
                        width: s
                    } = t;
                    return "right" === e ? i -= s : "center" === e && (i -= s / 2), i
                }(e, r);
                const p = function(t, e, i) {
                    let {
                        y: s,
                        height: n
                    } = t;
                    return "top" === e ? s += i : s -= "bottom" === e ? n + i : n / 2, s
                }(e, l, h);
                return "center" === l ? "left" === r ? g += h : "right" === r && (g -= h) : "left" === r ? g -= Math.max(c, u) + n : "right" === r && (g += Math.max(d, f) + n), {
                    x: J(g, 0, s.width - e.width),
                    y: J(p, 0, s.height - e.height)
                }
            }

            function Ea(t, e, i) {
                const s = ki(i.padding);
                return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - s.right : t.x + s.left
            }

            function Ra(t) {
                return Pa([], Da(t))
            }

            function Ia(t, e) {
                const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
                return i ? t.override(i) : t
            }
            const za = {
                beforeTitle: e,
                title(t) {
                    if (t.length > 0) {
                        const e = t[0],
                            i = e.chart.data.labels,
                            s = i ? i.length : 0;
                        if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || "";
                        if (e.label) return e.label;
                        if (s > 0 && e.dataIndex < s) return i[e.dataIndex]
                    }
                    return ""
                },
                afterTitle: e,
                beforeBody: e,
                beforeLabel: e,
                label(t) {
                    if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue;
                    let e = t.dataset.label || "";
                    e && (e += ": ");
                    const i = t.formattedValue;
                    return s(i) || (e += i), e
                },
                labelColor(t) {
                    const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
                    return {
                        borderColor: e.borderColor,
                        backgroundColor: e.backgroundColor,
                        borderWidth: e.borderWidth,
                        borderDash: e.borderDash,
                        borderDashOffset: e.borderDashOffset,
                        borderRadius: 0
                    }
                },
                labelTextColor() {
                    return this.options.bodyColor
                },
                labelPointStyle(t) {
                    const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
                    return {
                        pointStyle: e.pointStyle,
                        rotation: e.rotation
                    }
                },
                afterLabel: e,
                afterBody: e,
                beforeFooter: e,
                footer: e,
                afterFooter: e
            };

            function Fa(t, e, i, s) {
                const n = t[e].call(i, s);
                return void 0 === n ? za[e].call(i, s) : n
            }
            class Va extends Hs {
                static positioners = Sa;
                constructor(t) {
                    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
                }
                initialize(t) {
                    this.options = t, this._cachedAnimations = void 0, this.$context = void 0
                }
                _resolveAnimations() {
                    const t = this._cachedAnimations;
                    if (t) return t;
                    const e = this.chart,
                        i = this.options.setContext(this.getContext()),
                        s = i.enabled && e.options.animation && i.animations,
                        n = new Os(this.chart, s);
                    return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n
                }
                getContext() {
                    return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ci(t, {
                        tooltip: e,
                        tooltipItems: i,
                        type: "tooltip"
                    })));
                    var t, e, i
                }
                getTitle(t, e) {
                    const {
                        callbacks: i
                    } = e, s = Fa(i, "beforeTitle", this, t), n = Fa(i, "title", this, t), o = Fa(i, "afterTitle", this, t);
                    let a = [];
                    return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a
                }
                getBeforeBody(t, e) {
                    return Ra(Fa(e.callbacks, "beforeBody", this, t))
                }
                getBody(t, e) {
                    const {
                        callbacks: i
                    } = e, s = [];
                    return u(t, (t => {
                        const e = {
                                before: [],
                                lines: [],
                                after: []
                            },
                            n = Ia(i, t);
                        Pa(e.before, Da(Fa(n, "beforeLabel", this, t))), Pa(e.lines, Fa(n, "label", this, t)), Pa(e.after, Da(Fa(n, "afterLabel", this, t))), s.push(e)
                    })), s
                }
                getAfterBody(t, e) {
                    return Ra(Fa(e.callbacks, "afterBody", this, t))
                }
                getFooter(t, e) {
                    const {
                        callbacks: i
                    } = e, s = Fa(i, "beforeFooter", this, t), n = Fa(i, "footer", this, t), o = Fa(i, "afterFooter", this, t);
                    let a = [];
                    return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a
                }
                _createItems(t) {
                    const e = this._active,
                        i = this.chart.data,
                        s = [],
                        n = [],
                        o = [];
                    let a, r, l = [];
                    for (a = 0, r = e.length; a < r; ++a) l.push(Ca(this.chart, e[a]));
                    return t.filter && (l = l.filter(((e, s, n) => t.filter(e, s, n, i)))), t.itemSort && (l = l.sort(((e, s) => t.itemSort(e, s, i)))), u(l, (e => {
                        const i = Ia(t.callbacks, e);
                        s.push(Fa(i, "labelColor", this, e)), n.push(Fa(i, "labelPointStyle", this, e)), o.push(Fa(i, "labelTextColor", this, e))
                    })), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l
                }
                update(t, e) {
                    const i = this.options.setContext(this.getContext()),
                        s = this._active;
                    let n, o = [];
                    if (s.length) {
                        const t = Sa[i.position].call(this, s, this._eventPosition);
                        o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);
                        const e = this._size = Oa(this, i),
                            a = Object.assign({}, t, e),
                            r = Ta(this.chart, i, a),
                            l = La(i, a, r, this.chart);
                        this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {
                            opacity: 1,
                            x: l.x,
                            y: l.y,
                            width: e.width,
                            height: e.height,
                            caretX: t.x,
                            caretY: t.y
                        }
                    } else 0 !== this.opacity && (n = {
                        opacity: 0
                    });
                    this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {
                        chart: this.chart,
                        tooltip: this,
                        replay: e
                    })
                }
                drawCaret(t, e, i, s) {
                    const n = this.getCaretPosition(t, i, s);
                    e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3)
                }
                getCaretPosition(t, e, i) {
                    const {
                        xAlign: s,
                        yAlign: n
                    } = this, {
                        caretSize: o,
                        cornerRadius: a
                    } = i, {
                        topLeft: r,
                        topRight: l,
                        bottomLeft: h,
                        bottomRight: c
                    } = wi(a), {
                        x: d,
                        y: u
                    } = t, {
                        width: f,
                        height: g
                    } = e;
                    let p, m, b, x, _, y;
                    return "center" === n ? (_ = u + g / 2, "left" === s ? (p = d, m = p - o, x = _ + o, y = _ - o) : (p = d + f, m = p + o, x = _ - o, y = _ + o), b = p) : (m = "left" === s ? d + Math.max(r, h) + o : "right" === s ? d + f - Math.max(l, c) - o : this.caretX, "top" === n ? (x = u, _ = x - o, p = m - o, b = m + o) : (x = u + g, _ = x + o, p = m + o, b = m - o), y = x), {
                        x1: p,
                        x2: m,
                        x3: b,
                        y1: x,
                        y2: _,
                        y3: y
                    }
                }
                drawTitle(t, e, i) {
                    const s = this.title,
                        n = s.length;
                    let o, a, r;
                    if (n) {
                        const l = Oi(i.rtl, this.x, this.width);
                        for (t.x = Ea(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = "middle", o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r) e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a)
                    }
                }
                _drawColorBox(t, e, i, s, n) {
                    const a = this.labelColors[i],
                        r = this.labelPointStyles[i],
                        {
                            boxHeight: l,
                            boxWidth: h
                        } = n,
                        c = Si(n.bodyFont),
                        d = Ea(this, "left", n),
                        u = s.x(d),
                        f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0,
                        g = e.y + f;
                    if (n.usePointStyle) {
                        const e = {
                                radius: Math.min(h, l) / 2,
                                pointStyle: r.pointStyle,
                                rotation: r.rotation,
                                borderWidth: 1
                            },
                            i = s.leftForLtr(u, h) + h / 2,
                            o = g + l / 2;
                        t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o)
                    } else {
                        t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;
                        const e = s.leftForLtr(u, h),
                            i = s.leftForLtr(s.xPlus(u, 1), h - 2),
                            r = wi(a.borderRadius);
                        Object.values(r).some((t => 0 !== t)) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, {
                            x: e,
                            y: g,
                            w: h,
                            h: l,
                            radius: r
                        }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, {
                            x: i,
                            y: g + 1,
                            w: h - 2,
                            h: l - 2,
                            radius: r
                        }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2))
                    }
                    t.fillStyle = this.labelTextColors[i]
                }
                drawBody(t, e, i) {
                    const {
                        body: s
                    } = this, {
                        bodySpacing: n,
                        bodyAlign: o,
                        displayColors: a,
                        boxHeight: r,
                        boxWidth: l,
                        boxPadding: h
                    } = i, c = Si(i.bodyFont);
                    let d = c.lineHeight,
                        f = 0;
                    const g = Oi(i.rtl, this.x, this.width),
                        p = function(i) {
                            e.fillText(i, g.x(t.x + f), t.y + d / 2), t.y += d + n
                        },
                        m = g.textAlign(o);
                    let b, x, _, y, v, M, w;
                    for (e.textAlign = o, e.textBaseline = "middle", e.font = c.string, t.x = Ea(this, m, i), e.fillStyle = i.bodyColor, u(this.beforeBody, p), f = a && "right" !== m ? "center" === o ? l / 2 + h : l + 2 + h : 0, y = 0, M = s.length; y < M; ++y) {
                        for (b = s[y], x = this.labelTextColors[y], e.fillStyle = x, u(b.before, p), _ = b.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.length; v < w; ++v) p(_[v]), d = c.lineHeight;
                        u(b.after, p)
                    }
                    f = 0, d = c.lineHeight, u(this.afterBody, p), t.y -= n
                }
                drawFooter(t, e, i) {
                    const s = this.footer,
                        n = s.length;
                    let o, a;
                    if (n) {
                        const r = Oi(i.rtl, this.x, this.width);
                        for (t.x = Ea(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = "middle", o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a) e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing
                    }
                }
                drawBackground(t, e, i, s) {
                    const {
                        xAlign: n,
                        yAlign: o
                    } = this, {
                        x: a,
                        y: r
                    } = t, {
                        width: l,
                        height: h
                    } = i, {
                        topLeft: c,
                        topRight: d,
                        bottomLeft: u,
                        bottomRight: f
                    } = wi(s.cornerRadius);
                    e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), "top" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), "center" === o && "right" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), "bottom" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), "center" === o && "left" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke()
                }
                _updateAnimationTarget(t) {
                    const e = this.chart,
                        i = this.$animations,
                        s = i && i.x,
                        n = i && i.y;
                    if (s || n) {
                        const i = Sa[t.position].call(this, this._active, this._eventPosition);
                        if (!i) return;
                        const o = this._size = Oa(this, t),
                            a = Object.assign({}, i, this._size),
                            r = Ta(e, t, a),
                            l = La(t, a, r, e);
                        s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l))
                    }
                }
                _willRender() {
                    return !!this.opacity
                }
                draw(t) {
                    const e = this.options.setContext(this.getContext());
                    let i = this.opacity;
                    if (!i) return;
                    this._updateAnimationTarget(e);
                    const s = {
                            width: this.width,
                            height: this.height
                        },
                        n = {
                            x: this.x,
                            y: this.y
                        };
                    i = Math.abs(i) < .001 ? 0 : i;
                    const o = ki(e.padding),
                        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
                    e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore())
                }
                getActiveElements() {
                    return this._active || []
                }
                setActiveElements(t, e) {
                    const i = this._active,
                        s = t.map((({
                            datasetIndex: t,
                            index: e
                        }) => {
                            const i = this.chart.getDatasetMeta(t);
                            if (!i) throw new Error("Cannot find a dataset at index " + t);
                            return {
                                datasetIndex: t,
                                element: i.data[e],
                                index: e
                            }
                        })),
                        n = !f(i, s),
                        o = this._positionChanged(s, e);
                    (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0))
                }
                handleEvent(t, e, i = !0) {
                    if (e && this._ignoreReplayEvents) return !1;
                    this._ignoreReplayEvents = !1;
                    const s = this.options,
                        n = this._active || [],
                        o = this._getActiveElements(t, n, e, i),
                        a = this._positionChanged(o, t),
                        r = e || !f(o, n) || a;
                    return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {
                        x: t.x,
                        y: t.y
                    }, this.update(!0, e))), r
                }
                _getActiveElements(t, e, i, s) {
                    const n = this.options;
                    if ("mouseout" === t.type) return [];
                    if (!s) return e.filter((t => this.chart.data.datasets[t.datasetIndex] && void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)));
                    const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);
                    return n.reverse && o.reverse(), o
                }
                _positionChanged(t, e) {
                    const {
                        caretX: i,
                        caretY: s,
                        options: n
                    } = this, o = Sa[n.position].call(this, t, e);
                    return !1 !== o && (i !== o.x || s !== o.y)
                }
            }
            var Ba = {
                id: "tooltip",
                _element: Va,
                positioners: Sa,
                afterInit(t, e, i) {
                    i && (t.tooltip = new Va({
                        chart: t,
                        options: i
                    }))
                },
                beforeUpdate(t, e, i) {
                    t.tooltip && t.tooltip.initialize(i)
                },
                reset(t, e, i) {
                    t.tooltip && t.tooltip.initialize(i)
                },
                afterDraw(t) {
                    const e = t.tooltip;
                    if (e && e._willRender()) {
                        const i = {
                            tooltip: e
                        };
                        if (!1 === t.notifyPlugins("beforeTooltipDraw", {...i,
                                cancelable: !0
                            })) return;
                        e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i)
                    }
                },
                afterEvent(t, e) {
                    if (t.tooltip) {
                        const i = e.replay;
                        t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0)
                    }
                },
                defaults: {
                    enabled: !0,
                    external: null,
                    position: "average",
                    backgroundColor: "rgba(0,0,0,0.8)",
                    titleColor: "#fff",
                    titleFont: {
                        weight: "bold"
                    },
                    titleSpacing: 2,
                    titleMarginBottom: 6,
                    titleAlign: "left",
                    bodyColor: "#fff",
                    bodySpacing: 2,
                    bodyFont: {},
                    bodyAlign: "left",
                    footerColor: "#fff",
                    footerSpacing: 2,
                    footerMarginTop: 6,
                    footerFont: {
                        weight: "bold"
                    },
                    footerAlign: "left",
                    padding: 6,
                    caretPadding: 2,
                    caretSize: 5,
                    cornerRadius: 6,
                    boxHeight: (t, e) => e.bodyFont.size,
                    boxWidth: (t, e) => e.bodyFont.size,
                    multiKeyBackground: "#fff",
                    displayColors: !0,
                    boxPadding: 0,
                    borderColor: "rgba(0,0,0,0)",
                    borderWidth: 0,
                    animation: {
                        duration: 400,
                        easing: "easeOutQuart"
                    },
                    animations: {
                        numbers: {
                            type: "number",
                            properties: ["x", "y", "width", "height", "caretX", "caretY"]
                        },
                        opacity: {
                            easing: "linear",
                            duration: 200
                        }
                    },
                    callbacks: za
                },
                defaultRoutes: {
                    bodyFont: "font",
                    footerFont: "font",
                    titleFont: "font"
                },
                descriptors: {
                    _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t,
                    _indexable: !1,
                    callbacks: {
                        _scriptable: !1,
                        _indexable: !1
                    },
                    animation: {
                        _fallback: !1
                    },
                    animations: {
                        _fallback: "animation"
                    }
                },
                additionalOptionScopes: ["interaction"]
            };
            return An.register(Yn, jo, fo, t), An.helpers = {...Wi
            }, An._adapters = Rn, An.Animation = Cs, An.Animations = Os, An.animator = xt, An.controllers = en.controllers.items, An.DatasetController = Ns, An.Element = Hs, An.elements = fo, An.Interaction = Xi, An.layouts = as, An.platforms = Ss, An.Scale = Js, An.Ticks = ae, Object.assign(An, Yn, jo, fo, t, Ss), An.Chart = An, "undefined" != typeof window && (window.Chart = An), An
        })); //# sourceMappingURL=chart.umd.js.map
    </script>
    <!-- jquery.js -->
    <script>
        /*! jQuery v3.7.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */ ! function(e, t) {
            "use strict";
            "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
                if (!e.document) throw new Error("jQuery requires a window with a document");
                return t(e)
            } : t(e)
        }("undefined" != typeof window ? window : this, function(ie, e) {
            "use strict";
            var oe = [],
                r = Object.getPrototypeOf,
                ae = oe.slice,
                g = oe.flat ? function(e) {
                    return oe.flat.call(e)
                } : function(e) {
                    return oe.concat.apply([], e)
                },
                s = oe.push,
                se = oe.indexOf,
                n = {},
                i = n.toString,
                ue = n.hasOwnProperty,
                o = ue.toString,
                a = o.call(Object),
                le = {},
                v = function(e) {
                    return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
                },
                y = function(e) {
                    return null != e && e === e.window
                },
                C = ie.document,
                u = {
                    type: !0,
                    src: !0,
                    nonce: !0,
                    noModule: !0
                };

            function m(e, t, n) {
                var r, i, o = (n = n || C).createElement("script");
                if (o.text = e, t)
                    for (r in u)(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
                n.head.appendChild(o).parentNode.removeChild(o)
            }

            function x(e) {
                return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[i.call(e)] || "object" : typeof e
            }
            var t = "3.7.1",
                l = /HTML$/i,
                ce = function(e, t) {
                    return new ce.fn.init(e, t)
                };

            function c(e) {
                var t = !!e && "length" in e && e.length,
                    n = x(e);
                return !v(e) && !y(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
            }

            function fe(e, t) {
                return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
            }
            ce.fn = ce.prototype = {
                jquery: t,
                constructor: ce,
                length: 0,
                toArray: function() {
                    return ae.call(this)
                },
                get: function(e) {
                    return null == e ? ae.call(this) : e < 0 ? this[e + this.length] : this[e]
                },
                pushStack: function(e) {
                    var t = ce.merge(this.constructor(), e);
                    return t.prevObject = this, t
                },
                each: function(e) {
                    return ce.each(this, e)
                },
                map: function(n) {
                    return this.pushStack(ce.map(this, function(e, t) {
                        return n.call(e, t, e)
                    }))
                },
                slice: function() {
                    return this.pushStack(ae.apply(this, arguments))
                },
                first: function() {
                    return this.eq(0)
                },
                last: function() {
                    return this.eq(-1)
                },
                even: function() {
                    return this.pushStack(ce.grep(this, function(e, t) {
                        return (t + 1) % 2
                    }))
                },
                odd: function() {
                    return this.pushStack(ce.grep(this, function(e, t) {
                        return t % 2
                    }))
                },
                eq: function(e) {
                    var t = this.length,
                        n = +e + (e < 0 ? t : 0);
                    return this.pushStack(0 <= n && n < t ? [this[n]] : [])
                },
                end: function() {
                    return this.prevObject || this.constructor()
                },
                push: s,
                sort: oe.sort,
                splice: oe.splice
            }, ce.extend = ce.fn.extend = function() {
                var e, t, n, r, i, o, a = arguments[0] || {},
                    s = 1,
                    u = arguments.length,
                    l = !1;
                for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || v(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
                    if (null != (e = arguments[s]))
                        for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (ce.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || ce.isPlainObject(n) ? n : {}, i = !1, a[t] = ce.extend(l, o, r)) : void 0 !== r && (a[t] = r));
                return a
            }, ce.extend({
                expando: "jQuery" + (t + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function(e) {
                    throw new Error(e)
                },
                noop: function() {},
                isPlainObject: function(e) {
                    var t, n;
                    return !(!e || "[object Object]" !== i.call(e)) && (!(t = r(e)) || "function" == typeof(n = ue.call(t, "constructor") && t.constructor) && o.call(n) === a)
                },
                isEmptyObject: function(e) {
                    var t;
                    for (t in e) return !1;
                    return !0
                },
                globalEval: function(e, t, n) {
                    m(e, {
                        nonce: t && t.nonce
                    }, n)
                },
                each: function(e, t) {
                    var n, r = 0;
                    if (c(e)) {
                        for (n = e.length; r < n; r++)
                            if (!1 === t.call(e[r], r, e[r])) break
                    } else
                        for (r in e)
                            if (!1 === t.call(e[r], r, e[r])) break; return e
                },
                text: function(e) {
                    var t, n = "",
                        r = 0,
                        i = e.nodeType;
                    if (!i)
                        while (t = e[r++]) n += ce.text(t);
                    return 1 === i || 11 === i ? e.textContent : 9 === i ? e.documentElement.textContent : 3 === i || 4 === i ? e.nodeValue : n
                },
                makeArray: function(e, t) {
                    var n = t || [];
                    return null != e && (c(Object(e)) ? ce.merge(n, "string" == typeof e ? [e] : e) : s.call(n, e)), n
                },
                inArray: function(e, t, n) {
                    return null == t ? -1 : se.call(t, e, n)
                },
                isXMLDoc: function(e) {
                    var t = e && e.namespaceURI,
                        n = e && (e.ownerDocument || e).documentElement;
                    return !l.test(t || n && n.nodeName || "HTML")
                },
                merge: function(e, t) {
                    for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r];
                    return e.length = i, e
                },
                grep: function(e, t, n) {
                    for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]);
                    return r
                },
                map: function(e, t, n) {
                    var r, i, o = 0,
                        a = [];
                    if (c(e))
                        for (r = e.length; o < r; o++) null != (i = t(e[o], o, n)) && a.push(i);
                    else
                        for (o in e) null != (i = t(e[o], o, n)) && a.push(i);
                    return g(a)
                },
                guid: 1,
                support: le
            }), "function" == typeof Symbol && (ce.fn[Symbol.iterator] = oe[Symbol.iterator]), ce.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
                n["[object " + t + "]"] = t.toLowerCase()
            });
            var pe = oe.pop,
                de = oe.sort,
                he = oe.splice,
                ge = "[\\x20\\t\\r\\n\\f]",
                ve = new RegExp("^" + ge + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ge + "+$", "g");
            ce.contains = function(e, t) {
                var n = t && t.parentNode;
                return e === n || !(!n || 1 !== n.nodeType || !(e.contains ? e.contains(n) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(n)))
            };
            var f = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

            function p(e, t) {
                return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
            }
            ce.escapeSelector = function(e) {
                return (e + "").replace(f, p)
            };
            var ye = C,
                me = s;
            ! function() {
                var e, b, w, o, a, T, r, C, d, i, k = me,
                    S = ce.expando,
                    E = 0,
                    n = 0,
                    s = W(),
                    c = W(),
                    u = W(),
                    h = W(),
                    l = function(e, t) {
                        return e === t && (a = !0), 0
                    },
                    f = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    t = "(?:\\\\[\\da-fA-F]{1,6}" + ge + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                    p = "\\[" + ge + "*(" + t + ")(?:" + ge + "*([*^$|!~]?=)" + ge + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + t + "))|)" + ge + "*\\]",
                    g = ":(" + t + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + p + ")*)|.*)\\)|)",
                    v = new RegExp(ge + "+", "g"),
                    y = new RegExp("^" + ge + "*," + ge + "*"),
                    m = new RegExp("^" + ge + "*([>+~]|" + ge + ")" + ge + "*"),
                    x = new RegExp(ge + "|>"),
                    j = new RegExp(g),
                    A = new RegExp("^" + t + "$"),
                    D = {
                        ID: new RegExp("^#(" + t + ")"),
                        CLASS: new RegExp("^\\.(" + t + ")"),
                        TAG: new RegExp("^(" + t + "|[*])"),
                        ATTR: new RegExp("^" + p),
                        PSEUDO: new RegExp("^" + g),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ge + "*(even|odd|(([+-]|)(\\d*)n|)" + ge + "*(?:([+-]|)" + ge + "*(\\d+)|))" + ge + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + f + ")$", "i"),
                        needsContext: new RegExp("^" + ge + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ge + "*((?:-\\d)?\\d*)" + ge + "*\\)|)(?=[^-]|$)", "i")
                    },
                    N = /^(?:input|select|textarea|button)$/i,
                    q = /^h\d$/i,
                    L = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    H = /[+~]/,
                    O = new RegExp("\\\\[\\da-fA-F]{1,6}" + ge + "?|\\\\([^\\r\\n\\f])", "g"),
                    P = function(e, t) {
                        var n = "0x" + e.slice(1) - 65536;
                        return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                    },
                    M = function() {
                        V()
                    },
                    R = J(function(e) {
                        return !0 === e.disabled && fe(e, "fieldset")
                    }, {
                        dir: "parentNode",
                        next: "legend"
                    });
                try {
                    k.apply(oe = ae.call(ye.childNodes), ye.childNodes), oe[ye.childNodes.length].nodeType
                } catch (e) {
                    k = {
                        apply: function(e, t) {
                            me.apply(e, ae.call(t))
                        },
                        call: function(e) {
                            me.apply(e, ae.call(arguments, 1))
                        }
                    }
                }

                function I(t, e, n, r) {
                    var i, o, a, s, u, l, c, f = e && e.ownerDocument,
                        p = e ? e.nodeType : 9;
                    if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;
                    if (!r && (V(e), e = e || T, C)) {
                        if (11 !== p && (u = L.exec(t)))
                            if (i = u[1]) {
                                if (9 === p) {
                                    if (!(a = e.getElementById(i))) return n;
                                    if (a.id === i) return k.call(n, a), n
                                } else if (f && (a = f.getElementById(i)) && I.contains(e, a) && a.id === i) return k.call(n, a), n
                            } else {
                                if (u[2]) return k.apply(n, e.getElementsByTagName(t)), n;
                                if ((i = u[3]) && e.getElementsByClassName) return k.apply(n, e.getElementsByClassName(i)), n
                            }
                        if (!(h[t + " "] || d && d.test(t))) {
                            if (c = t, f = e, 1 === p && (x.test(t) || m.test(t))) {
                                (f = H.test(t) && U(e.parentNode) || e) == e && le.scope || ((s = e.getAttribute("id")) ? s = ce.escapeSelector(s) : e.setAttribute("id", s = S)), o = (l = Y(t)).length;
                                while (o--) l[o] = (s ? "#" + s : ":scope") + " " + Q(l[o]);
                                c = l.join(",")
                            }
                            try {
                                return k.apply(n, f.querySelectorAll(c)), n
                            } catch (e) {
                                h(t, !0)
                            } finally {
                                s === S && e.removeAttribute("id")
                            }
                        }
                    }
                    return re(t.replace(ve, "$1"), e, n, r)
                }

                function W() {
                    var r = [];
                    return function e(t, n) {
                        return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n
                    }
                }

                function F(e) {
                    return e[S] = !0, e
                }

                function $(e) {
                    var t = T.createElement("fieldset");
                    try {
                        return !!e(t)
                    } catch (e) {
                        return !1
                    } finally {
                        t.parentNode && t.parentNode.removeChild(t), t = null
                    }
                }

                function B(t) {
                    return function(e) {
                        return fe(e, "input") && e.type === t
                    }
                }

                function _(t) {
                    return function(e) {
                        return (fe(e, "input") || fe(e, "button")) && e.type === t
                    }
                }

                function z(t) {
                    return function(e) {
                        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && R(e) === t : e.disabled === t : "label" in e && e.disabled === t
                    }
                }

                function X(a) {
                    return F(function(o) {
                        return o = +o, F(function(e, t) {
                            var n, r = a([], e.length, o),
                                i = r.length;
                            while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n]))
                        })
                    })
                }

                function U(e) {
                    return e && "undefined" != typeof e.getElementsByTagName && e
                }

                function V(e) {
                    var t, n = e ? e.ownerDocument || e : ye;
                    return n != T && 9 === n.nodeType && n.documentElement && (r = (T = n).documentElement, C = !ce.isXMLDoc(T), i = r.matches || r.webkitMatchesSelector || r.msMatchesSelector, r.msMatchesSelector && ye != T && (t = T.defaultView) && t.top !== t && t.addEventListener("unload", M), le.getById = $(function(e) {
                        return r.appendChild(e).id = ce.expando, !T.getElementsByName || !T.getElementsByName(ce.expando).length
                    }), le.disconnectedMatch = $(function(e) {
                        return i.call(e, "*")
                    }), le.scope = $(function() {
                        return T.querySelectorAll(":scope")
                    }), le.cssHas = $(function() {
                        try {
                            return T.querySelector(":has(*,:jqfake)"), !1
                        } catch (e) {
                            return !0
                        }
                    }), le.getById ? (b.filter.ID = function(e) {
                        var t = e.replace(O, P);
                        return function(e) {
                            return e.getAttribute("id") === t
                        }
                    }, b.find.ID = function(e, t) {
                        if ("undefined" != typeof t.getElementById && C) {
                            var n = t.getElementById(e);
                            return n ? [n] : []
                        }
                    }) : (b.filter.ID = function(e) {
                        var n = e.replace(O, P);
                        return function(e) {
                            var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                            return t && t.value === n
                        }
                    }, b.find.ID = function(e, t) {
                        if ("undefined" != typeof t.getElementById && C) {
                            var n, r, i, o = t.getElementById(e);
                            if (o) {
                                if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
                                i = t.getElementsByName(e), r = 0;
                                while (o = i[r++])
                                    if ((n = o.getAttributeNode("id")) && n.value === e) return [o]
                            }
                            return []
                        }
                    }), b.find.TAG = function(e, t) {
                        return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : t.querySelectorAll(e)
                    }, b.find.CLASS = function(e, t) {
                        if ("undefined" != typeof t.getElementsByClassName && C) return t.getElementsByClassName(e)
                    }, d = [], $(function(e) {
                        var t;
                        r.appendChild(e).innerHTML = "<a id='" + S + "' href='' disabled='disabled'></a><select id='" + S + "-\r\\' disabled='disabled'><option selected=''></option></select>", e.querySelectorAll("[selected]").length || d.push("\\[" + ge + "*(?:value|" + f + ")"), e.querySelectorAll("[id~=" + S + "-]").length || d.push("~="), e.querySelectorAll("a#" + S + "+*").length || d.push(".#.+[+~]"), e.querySelectorAll(":checked").length || d.push(":checked"), (t = T.createElement("input")).setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), r.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && d.push(":enabled", ":disabled"), (t = T.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || d.push("\\[" + ge + "*name" + ge + "*=" + ge + "*(?:''|\"\")")
                    }), le.cssHas || d.push(":has"), d = d.length && new RegExp(d.join("|")), l = function(e, t) {
                        if (e === t) return a = !0, 0;
                        var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                        return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !le.sortDetached && t.compareDocumentPosition(e) === n ? e === T || e.ownerDocument == ye && I.contains(ye, e) ? -1 : t === T || t.ownerDocument == ye && I.contains(ye, t) ? 1 : o ? se.call(o, e) - se.call(o, t) : 0 : 4 & n ? -1 : 1)
                    }), T
                }
                for (e in I.matches = function(e, t) {
                        return I(e, null, null, t)
                    }, I.matchesSelector = function(e, t) {
                        if (V(e), C && !h[t + " "] && (!d || !d.test(t))) try {
                            var n = i.call(e, t);
                            if (n || le.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n
                        } catch (e) {
                            h(t, !0)
                        }
                        return 0 < I(t, T, null, [e]).length
                    }, I.contains = function(e, t) {
                        return (e.ownerDocument || e) != T && V(e), ce.contains(e, t)
                    }, I.attr = function(e, t) {
                        (e.ownerDocument || e) != T && V(e);
                        var n = b.attrHandle[t.toLowerCase()],
                            r = n && ue.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !C) : void 0;
                        return void 0 !== r ? r : e.getAttribute(t)
                    }, I.error = function(e) {
                        throw new Error("Syntax error, unrecognized expression: " + e)
                    }, ce.uniqueSort = function(e) {
                        var t, n = [],
                            r = 0,
                            i = 0;
                        if (a = !le.sortStable, o = !le.sortStable && ae.call(e, 0), de.call(e, l), a) {
                            while (t = e[i++]) t === e[i] && (r = n.push(i));
                            while (r--) he.call(e, n[r], 1)
                        }
                        return o = null, e
                    }, ce.fn.uniqueSort = function() {
                        return this.pushStack(ce.uniqueSort(ae.apply(this)))
                    }, (b = ce.expr = {
                        cacheLength: 50,
                        createPseudo: F,
                        match: D,
                        attrHandle: {},
                        find: {},
                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: !0
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: !0
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },
                        preFilter: {
                            ATTR: function(e) {
                                return e[1] = e[1].replace(O, P), e[3] = (e[3] || e[4] || e[5] || "").replace(O, P), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                            },
                            CHILD: function(e) {
                                return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || I.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && I.error(e[0]), e
                            },
                            PSEUDO: function(e) {
                                var t, n = !e[6] && e[2];
                                return D.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && j.test(n) && (t = Y(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                            }
                        },
                        filter: {
                            TAG: function(e) {
                                var t = e.replace(O, P).toLowerCase();
                                return "*" === e ? function() {
                                    return !0
                                } : function(e) {
                                    return fe(e, t)
                                }
                            },
                            CLASS: function(e) {
                                var t = s[e + " "];
                                return t || (t = new RegExp("(^|" + ge + ")" + e + "(" + ge + "|$)")) && s(e, function(e) {
                                    return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                                })
                            },
                            ATTR: function(n, r, i) {
                                return function(e) {
                                    var t = I.attr(e, n);
                                    return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(v, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"))
                                }
                            },
                            CHILD: function(d, e, t, h, g) {
                                var v = "nth" !== d.slice(0, 3),
                                    y = "last" !== d.slice(-4),
                                    m = "of-type" === e;
                                return 1 === h && 0 === g ? function(e) {
                                    return !!e.parentNode
                                } : function(e, t, n) {
                                    var r, i, o, a, s, u = v !== y ? "nextSibling" : "previousSibling",
                                        l = e.parentNode,
                                        c = m && e.nodeName.toLowerCase(),
                                        f = !n && !m,
                                        p = !1;
                                    if (l) {
                                        if (v) {
                                            while (u) {
                                                o = e;
                                                while (o = o[u])
                                                    if (m ? fe(o, c) : 1 === o.nodeType) return !1;
                                                s = u = "only" === d && !s && "nextSibling"
                                            }
                                            return !0
                                        }
                                        if (s = [y ? l.firstChild : l.lastChild], y && f) {
                                            p = (a = (r = (i = l[S] || (l[S] = {}))[d] || [])[0] === E && r[1]) && r[2], o = a && l.childNodes[a];
                                            while (o = ++a && o && o[u] || (p = a = 0) || s.pop())
                                                if (1 === o.nodeType && ++p && o === e) {
                                                    i[d] = [E, a, p];
                                                    break
                                                }
                                        } else if (f && (p = a = (r = (i = e[S] || (e[S] = {}))[d] || [])[0] === E && r[1]), !1 === p)
                                            while (o = ++a && o && o[u] || (p = a = 0) || s.pop())
                                                if ((m ? fe(o, c) : 1 === o.nodeType) && ++p && (f && ((i = o[S] || (o[S] = {}))[d] = [E, p]), o === e)) break;
                                        return (p -= g) === h || p % h == 0 && 0 <= p / h
                                    }
                                }
                            },
                            PSEUDO: function(e, o) {
                                var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || I.error("unsupported pseudo: " + e);
                                return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? F(function(e, t) {
                                    var n, r = a(e, o),
                                        i = r.length;
                                    while (i--) e[n = se.call(e, r[i])] = !(t[n] = r[i])
                                }) : function(e) {
                                    return a(e, 0, t)
                                }) : a
                            }
                        },
                        pseudos: {
                            not: F(function(e) {
                                var r = [],
                                    i = [],
                                    s = ne(e.replace(ve, "$1"));
                                return s[S] ? F(function(e, t, n, r) {
                                    var i, o = s(e, null, r, []),
                                        a = e.length;
                                    while (a--)(i = o[a]) && (e[a] = !(t[a] = i))
                                }) : function(e, t, n) {
                                    return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop()
                                }
                            }),
                            has: F(function(t) {
                                return function(e) {
                                    return 0 < I(t, e).length
                                }
                            }),
                            contains: F(function(t) {
                                return t = t.replace(O, P),
                                    function(e) {
                                        return -1 < (e.textContent || ce.text(e)).indexOf(t)
                                    }
                            }),
                            lang: F(function(n) {
                                return A.test(n || "") || I.error("unsupported lang: " + n), n = n.replace(O, P).toLowerCase(),
                                    function(e) {
                                        var t;
                                        do {
                                            if (t = C ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-")
                                        } while ((e = e.parentNode) && 1 === e.nodeType);
                                        return !1
                                    }
                            }),
                            target: function(e) {
                                var t = ie.location && ie.location.hash;
                                return t && t.slice(1) === e.id
                            },
                            root: function(e) {
                                return e === r
                            },
                            focus: function(e) {
                                return e === function() {
                                    try {
                                        return T.activeElement
                                    } catch (e) {}
                                }() && T.hasFocus() && !!(e.type || e.href || ~e.tabIndex)
                            },
                            enabled: z(!1),
                            disabled: z(!0),
                            checked: function(e) {
                                return fe(e, "input") && !!e.checked || fe(e, "option") && !!e.selected
                            },
                            selected: function(e) {
                                return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
                            },
                            empty: function(e) {
                                for (e = e.firstChild; e; e = e.nextSibling)
                                    if (e.nodeType < 6) return !1;
                                return !0
                            },
                            parent: function(e) {
                                return !b.pseudos.empty(e)
                            },
                            header: function(e) {
                                return q.test(e.nodeName)
                            },
                            input: function(e) {
                                return N.test(e.nodeName)
                            },
                            button: function(e) {
                                return fe(e, "input") && "button" === e.type || fe(e, "button")
                            },
                            text: function(e) {
                                var t;
                                return fe(e, "input") && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                            },
                            first: X(function() {
                                return [0]
                            }),
                            last: X(function(e, t) {
                                return [t - 1]
                            }),
                            eq: X(function(e, t, n) {
                                return [n < 0 ? n + t : n]
                            }),
                            even: X(function(e, t) {
                                for (var n = 0; n < t; n += 2) e.push(n);
                                return e
                            }),
                            odd: X(function(e, t) {
                                for (var n = 1; n < t; n += 2) e.push(n);
                                return e
                            }),
                            lt: X(function(e, t, n) {
                                var r;
                                for (r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) e.push(r);
                                return e
                            }),
                            gt: X(function(e, t, n) {
                                for (var r = n < 0 ? n + t : n; ++r < t;) e.push(r);
                                return e
                            })
                        }
                    }).pseudos.nth = b.pseudos.eq, {
                        radio: !0,
                        checkbox: !0,
                        file: !0,
                        password: !0,
                        image: !0
                    }) b.pseudos[e] = B(e);
                for (e in {
                        submit: !0,
                        reset: !0
                    }) b.pseudos[e] = _(e);

                function G() {}

                function Y(e, t) {
                    var n, r, i, o, a, s, u, l = c[e + " "];
                    if (l) return t ? 0 : l.slice(0);
                    a = e, s = [], u = b.preFilter;
                    while (a) {
                        for (o in n && !(r = y.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = m.exec(a)) && (n = r.shift(), i.push({
                                value: n,
                                type: r[0].replace(ve, " ")
                            }), a = a.slice(n.length)), b.filter) !(r = D[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
                            value: n,
                            type: o,
                            matches: r
                        }), a = a.slice(n.length));
                        if (!n) break
                    }
                    return t ? a.length : a ? I.error(e) : c(e, s).slice(0)
                }

                function Q(e) {
                    for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
                    return r
                }

                function J(a, e, t) {
                    var s = e.dir,
                        u = e.next,
                        l = u || s,
                        c = t && "parentNode" === l,
                        f = n++;
                    return e.first ? function(e, t, n) {
                        while (e = e[s])
                            if (1 === e.nodeType || c) return a(e, t, n);
                        return !1
                    } : function(e, t, n) {
                        var r, i, o = [E, f];
                        if (n) {
                            while (e = e[s])
                                if ((1 === e.nodeType || c) && a(e, t, n)) return !0
                        } else
                            while (e = e[s])
                                if (1 === e.nodeType || c)
                                    if (i = e[S] || (e[S] = {}), u && fe(e, u)) e = e[s] || e;
                                    else {
                                        if ((r = i[l]) && r[0] === E && r[1] === f) return o[2] = r[2];
                                        if ((i[l] = o)[2] = a(e, t, n)) return !0
                                    } return !1
                    }
                }

                function K(i) {
                    return 1 < i.length ? function(e, t, n) {
                        var r = i.length;
                        while (r--)
                            if (!i[r](e, t, n)) return !1;
                        return !0
                    } : i[0]
                }

                function Z(e, t, n, r, i) {
                    for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
                    return a
                }

                function ee(d, h, g, v, y, e) {
                    return v && !v[S] && (v = ee(v)), y && !y[S] && (y = ee(y, e)), F(function(e, t, n, r) {
                        var i, o, a, s, u = [],
                            l = [],
                            c = t.length,
                            f = e || function(e, t, n) {
                                for (var r = 0, i = t.length; r < i; r++) I(e, t[r], n);
                                return n
                            }(h || "*", n.nodeType ? [n] : n, []),
                            p = !d || !e && h ? f : Z(f, u, d, n, r);
                        if (g ? g(p, s = y || (e ? d : c || v) ? [] : t, n, r) : s = p, v) {
                            i = Z(s, l), v(i, [], n, r), o = i.length;
                            while (o--)(a = i[o]) && (s[l[o]] = !(p[l[o]] = a))
                        }
                        if (e) {
                            if (y || d) {
                                if (y) {
                                    i = [], o = s.length;
                                    while (o--)(a = s[o]) && i.push(p[o] = a);
                                    y(null, s = [], i, r)
                                }
                                o = s.length;
                                while (o--)(a = s[o]) && -1 < (i = y ? se.call(e, a) : u[o]) && (e[i] = !(t[i] = a))
                            }
                        } else s = Z(s === t ? s.splice(c, s.length) : s), y ? y(null, t, s, r) : k.apply(t, s)
                    })
                }

                function te(e) {
                    for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = J(function(e) {
                            return e === i
                        }, a, !0), l = J(function(e) {
                            return -1 < se.call(i, e)
                        }, a, !0), c = [function(e, t, n) {
                            var r = !o && (n || t != w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
                            return i = null, r
                        }]; s < r; s++)
                        if (t = b.relative[e[s].type]) c = [J(K(c), t)];
                        else {
                            if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
                                for (n = ++s; n < r; n++)
                                    if (b.relative[e[n].type]) break;
                                return ee(1 < s && K(c), 1 < s && Q(e.slice(0, s - 1).concat({
                                    value: " " === e[s - 2].type ? "*" : ""
                                })).replace(ve, "$1"), t, s < n && te(e.slice(s, n)), n < r && te(e = e.slice(n)), n < r && Q(e))
                            }
                            c.push(t)
                        }
                    return K(c)
                }

                function ne(e, t) {
                    var n, v, y, m, x, r, i = [],
                        o = [],
                        a = u[e + " "];
                    if (!a) {
                        t || (t = Y(e)), n = t.length;
                        while (n--)(a = te(t[n]))[S] ? i.push(a) : o.push(a);
                        (a = u(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function(e, t, n, r, i) {
                            var o, a, s, u = 0,
                                l = "0",
                                c = e && [],
                                f = [],
                                p = w,
                                d = e || x && b.find.TAG("*", i),
                                h = E += null == p ? 1 : Math.random() || .1,
                                g = d.length;
                            for (i && (w = t == T || t || i); l !== g && null != (o = d[l]); l++) {
                                if (x && o) {
                                    a = 0, t || o.ownerDocument == T || (V(o), n = !C);
                                    while (s = v[a++])
                                        if (s(o, t || T, n)) {
                                            k.call(r, o);
                                            break
                                        }
                                    i && (E = h)
                                }
                                m && ((o = !s && o) && u--, e && c.push(o))
                            }
                            if (u += l, m && l !== u) {
                                a = 0;
                                while (s = y[a++]) s(c, f, t, n);
                                if (e) {
                                    if (0 < u)
                                        while (l--) c[l] || f[l] || (f[l] = pe.call(r));
                                    f = Z(f)
                                }
                                k.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && ce.uniqueSort(r)
                            }
                            return i && (E = h, w = p), c
                        }, m ? F(r) : r))).selector = e
                    }
                    return a
                }

                function re(e, t, n, r) {
                    var i, o, a, s, u, l = "function" == typeof e && e,
                        c = !r && Y(e = l.selector || e);
                    if (n = n || [], 1 === c.length) {
                        if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && C && b.relative[o[1].type]) {
                            if (!(t = (b.find.ID(a.matches[0].replace(O, P), t) || [])[0])) return n;
                            l && (t = t.parentNode), e = e.slice(o.shift().value.length)
                        }
                        i = D.needsContext.test(e) ? 0 : o.length;
                        while (i--) {
                            if (a = o[i], b.relative[s = a.type]) break;
                            if ((u = b.find[s]) && (r = u(a.matches[0].replace(O, P), H.test(o[0].type) && U(t.parentNode) || t))) {
                                if (o.splice(i, 1), !(e = r.length && Q(o))) return k.apply(n, r), n;
                                break
                            }
                        }
                    }
                    return (l || ne(e, c))(r, t, !C, n, !t || H.test(e) && U(t.parentNode) || t), n
                }
                G.prototype = b.filters = b.pseudos, b.setFilters = new G, le.sortStable = S.split("").sort(l).join("") === S, V(), le.sortDetached = $(function(e) {
                    return 1 & e.compareDocumentPosition(T.createElement("fieldset"))
                }), ce.find = I, ce.expr[":"] = ce.expr.pseudos, ce.unique = ce.uniqueSort, I.compile = ne, I.select = re, I.setDocument = V, I.tokenize = Y, I.escape = ce.escapeSelector, I.getText = ce.text, I.isXML = ce.isXMLDoc, I.selectors = ce.expr, I.support = ce.support, I.uniqueSort = ce.uniqueSort
            }();
            var d = function(e, t, n) {
                    var r = [],
                        i = void 0 !== n;
                    while ((e = e[t]) && 9 !== e.nodeType)
                        if (1 === e.nodeType) {
                            if (i && ce(e).is(n)) break;
                            r.push(e)
                        }
                    return r
                },
                h = function(e, t) {
                    for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
                    return n
                },
                b = ce.expr.match.needsContext,
                w = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

            function T(e, n, r) {
                return v(n) ? ce.grep(e, function(e, t) {
                    return !!n.call(e, t, e) !== r
                }) : n.nodeType ? ce.grep(e, function(e) {
                    return e === n !== r
                }) : "string" != typeof n ? ce.grep(e, function(e) {
                    return -1 < se.call(n, e) !== r
                }) : ce.filter(n, e, r)
            }
            ce.filter = function(e, t, n) {
                var r = t[0];
                return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? ce.find.matchesSelector(r, e) ? [r] : [] : ce.find.matches(e, ce.grep(t, function(e) {
                    return 1 === e.nodeType
                }))
            }, ce.fn.extend({
                find: function(e) {
                    var t, n, r = this.length,
                        i = this;
                    if ("string" != typeof e) return this.pushStack(ce(e).filter(function() {
                        for (t = 0; t < r; t++)
                            if (ce.contains(i[t], this)) return !0
                    }));
                    for (n = this.pushStack([]), t = 0; t < r; t++) ce.find(e, i[t], n);
                    return 1 < r ? ce.uniqueSort(n) : n
                },
                filter: function(e) {
                    return this.pushStack(T(this, e || [], !1))
                },
                not: function(e) {
                    return this.pushStack(T(this, e || [], !0))
                },
                is: function(e) {
                    return !!T(this, "string" == typeof e && b.test(e) ? ce(e) : e || [], !1).length
                }
            });
            var k, S = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
            (ce.fn.init = function(e, t, n) {
                var r, i;
                if (!e) return this;
                if (n = n || k, "string" == typeof e) {
                    if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : S.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
                    if (r[1]) {
                        if (t = t instanceof ce ? t[0] : t, ce.merge(this, ce.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : C, !0)), w.test(r[1]) && ce.isPlainObject(t))
                            for (r in t) v(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                        return this
                    }
                    return (i = C.getElementById(r[2])) && (this[0] = i, this.length = 1), this
                }
                return e.nodeType ? (this[0] = e, this.length = 1, this) : v(e) ? void 0 !== n.ready ? n.ready(e) : e(ce) : ce.makeArray(e, this)
            }).prototype = ce.fn, k = ce(C);
            var E = /^(?:parents|prev(?:Until|All))/,
                j = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };

            function A(e, t) {
                while ((e = e[t]) && 1 !== e.nodeType);
                return e
            }
            ce.fn.extend({
                has: function(e) {
                    var t = ce(e, this),
                        n = t.length;
                    return this.filter(function() {
                        for (var e = 0; e < n; e++)
                            if (ce.contains(this, t[e])) return !0
                    })
                },
                closest: function(e, t) {
                    var n, r = 0,
                        i = this.length,
                        o = [],
                        a = "string" != typeof e && ce(e);
                    if (!b.test(e))
                        for (; r < i; r++)
                            for (n = this[r]; n && n !== t; n = n.parentNode)
                                if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && ce.find.matchesSelector(n, e))) {
                                    o.push(n);
                                    break
                                }
                    return this.pushStack(1 < o.length ? ce.uniqueSort(o) : o)
                },
                index: function(e) {
                    return e ? "string" == typeof e ? se.call(ce(e), this[0]) : se.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function(e, t) {
                    return this.pushStack(ce.uniqueSort(ce.merge(this.get(), ce(e, t))))
                },
                addBack: function(e) {
                    return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
                }
            }), ce.each({
                parent: function(e) {
                    var t = e.parentNode;
                    return t && 11 !== t.nodeType ? t : null
                },
                parents: function(e) {
                    return d(e, "parentNode")
                },
                parentsUntil: function(e, t, n) {
                    return d(e, "parentNode", n)
                },
                next: function(e) {
                    return A(e, "nextSibling")
                },
                prev: function(e) {
                    return A(e, "previousSibling")
                },
                nextAll: function(e) {
                    return d(e, "nextSibling")
                },
                prevAll: function(e) {
                    return d(e, "previousSibling")
                },
                nextUntil: function(e, t, n) {
                    return d(e, "nextSibling", n)
                },
                prevUntil: function(e, t, n) {
                    return d(e, "previousSibling", n)
                },
                siblings: function(e) {
                    return h((e.parentNode || {}).firstChild, e)
                },
                children: function(e) {
                    return h(e.firstChild)
                },
                contents: function(e) {
                    return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (fe(e, "template") && (e = e.content || e), ce.merge([], e.childNodes))
                }
            }, function(r, i) {
                ce.fn[r] = function(e, t) {
                    var n = ce.map(this, i, e);
                    return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = ce.filter(t, n)), 1 < this.length && (j[r] || ce.uniqueSort(n), E.test(r) && n.reverse()), this.pushStack(n)
                }
            });
            var D = /[^\x20\t\r\n\f]+/g;

            function N(e) {
                return e
            }

            function q(e) {
                throw e
            }

            function L(e, t, n, r) {
                var i;
                try {
                    e && v(i = e.promise) ? i.call(e).done(t).fail(n) : e && v(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r))
                } catch (e) {
                    n.apply(void 0, [e])
                }
            }
            ce.Callbacks = function(r) {
                var e, n;
                r = "string" == typeof r ? (e = r, n = {}, ce.each(e.match(D) || [], function(e, t) {
                    n[t] = !0
                }), n) : ce.extend({}, r);
                var i, t, o, a, s = [],
                    u = [],
                    l = -1,
                    c = function() {
                        for (a = a || r.once, o = i = !0; u.length; l = -1) {
                            t = u.shift();
                            while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1)
                        }
                        r.memory || (t = !1), i = !1, a && (s = t ? [] : "")
                    },
                    f = {
                        add: function() {
                            return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
                                ce.each(e, function(e, t) {
                                    v(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== x(t) && n(t)
                                })
                            }(arguments), t && !i && c()), this
                        },
                        remove: function() {
                            return ce.each(arguments, function(e, t) {
                                var n;
                                while (-1 < (n = ce.inArray(t, s, n))) s.splice(n, 1), n <= l && l--
                            }), this
                        },
                        has: function(e) {
                            return e ? -1 < ce.inArray(e, s) : 0 < s.length
                        },
                        empty: function() {
                            return s && (s = []), this
                        },
                        disable: function() {
                            return a = u = [], s = t = "", this
                        },
                        disabled: function() {
                            return !s
                        },
                        lock: function() {
                            return a = u = [], t || i || (s = t = ""), this
                        },
                        locked: function() {
                            return !!a
                        },
                        fireWith: function(e, t) {
                            return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this
                        },
                        fire: function() {
                            return f.fireWith(this, arguments), this
                        },
                        fired: function() {
                            return !!o
                        }
                    };
                return f
            }, ce.extend({
                Deferred: function(e) {
                    var o = [
                            ["notify", "progress", ce.Callbacks("memory"), ce.Callbacks("memory"), 2],
                            ["resolve", "done", ce.Callbacks("once memory"), ce.Callbacks("once memory"), 0, "resolved"],
                            ["reject", "fail", ce.Callbacks("once memory"), ce.Callbacks("once memory"), 1, "rejected"]
                        ],
                        i = "pending",
                        a = {
                            state: function() {
                                return i
                            },
                            always: function() {
                                return s.done(arguments).fail(arguments), this
                            },
                            "catch": function(e) {
                                return a.then(null, e)
                            },
                            pipe: function() {
                                var i = arguments;
                                return ce.Deferred(function(r) {
                                    ce.each(o, function(e, t) {
                                        var n = v(i[t[4]]) && i[t[4]];
                                        s[t[1]](function() {
                                            var e = n && n.apply(this, arguments);
                                            e && v(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments)
                                        })
                                    }), i = null
                                }).promise()
                            },
                            then: function(t, n, r) {
                                var u = 0;

                                function l(i, o, a, s) {
                                    return function() {
                                        var n = this,
                                            r = arguments,
                                            e = function() {
                                                var e, t;
                                                if (!(i < u)) {
                                                    if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                                                    t = e && ("object" == typeof e || "function" == typeof e) && e.then, v(t) ? s ? t.call(e, l(u, o, N, s), l(u, o, q, s)) : (u++, t.call(e, l(u, o, N, s), l(u, o, q, s), l(u, o, N, o.notifyWith))) : (a !== N && (n = void 0, r = [e]), (s || o.resolveWith)(n, r))
                                                }
                                            },
                                            t = s ? e : function() {
                                                try {
                                                    e()
                                                } catch (e) {
                                                    ce.Deferred.exceptionHook && ce.Deferred.exceptionHook(e, t.error), u <= i + 1 && (a !== q && (n = void 0, r = [e]), o.rejectWith(n, r))
                                                }
                                            };
                                        i ? t() : (ce.Deferred.getErrorHook ? t.error = ce.Deferred.getErrorHook() : ce.Deferred.getStackHook && (t.error = ce.Deferred.getStackHook()), ie.setTimeout(t))
                                    }
                                }
                                return ce.Deferred(function(e) {
                                    o[0][3].add(l(0, e, v(r) ? r : N, e.notifyWith)), o[1][3].add(l(0, e, v(t) ? t : N)), o[2][3].add(l(0, e, v(n) ? n : q))
                                }).promise()
                            },
                            promise: function(e) {
                                return null != e ? ce.extend(e, a) : a
                            }
                        },
                        s = {};
                    return ce.each(o, function(e, t) {
                        var n = t[2],
                            r = t[5];
                        a[t[1]] = n.add, r && n.add(function() {
                            i = r
                        }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function() {
                            return s[t[0] + "With"](this === s ? void 0 : this, arguments), this
                        }, s[t[0] + "With"] = n.fireWith
                    }), a.promise(s), e && e.call(s, s), s
                },
                when: function(e) {
                    var n = arguments.length,
                        t = n,
                        r = Array(t),
                        i = ae.call(arguments),
                        o = ce.Deferred(),
                        a = function(t) {
                            return function(e) {
                                r[t] = this, i[t] = 1 < arguments.length ? ae.call(arguments) : e, --n || o.resolveWith(r, i)
                            }
                        };
                    if (n <= 1 && (L(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || v(i[t] && i[t].then))) return o.then();
                    while (t--) L(i[t], a(t), o.reject);
                    return o.promise()
                }
            });
            var H = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            ce.Deferred.exceptionHook = function(e, t) {
                ie.console && ie.console.warn && e && H.test(e.name) && ie.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
            }, ce.readyException = function(e) {
                ie.setTimeout(function() {
                    throw e
                })
            };
            var O = ce.Deferred();

            function P() {
                C.removeEventListener("DOMContentLoaded", P), ie.removeEventListener("load", P), ce.ready()
            }
            ce.fn.ready = function(e) {
                return O.then(e)["catch"](function(e) {
                    ce.readyException(e)
                }), this
            }, ce.extend({
                isReady: !1,
                readyWait: 1,
                ready: function(e) {
                    (!0 === e ? --ce.readyWait : ce.isReady) || (ce.isReady = !0) !== e && 0 < --ce.readyWait || O.resolveWith(C, [ce])
                }
            }), ce.ready.then = O.then, "complete" === C.readyState || "loading" !== C.readyState && !C.documentElement.doScroll ? ie.setTimeout(ce.ready) : (C.addEventListener("DOMContentLoaded", P), ie.addEventListener("load", P));
            var M = function(e, t, n, r, i, o, a) {
                    var s = 0,
                        u = e.length,
                        l = null == n;
                    if ("object" === x(n))
                        for (s in i = !0, n) M(e, t, s, n[s], !0, o, a);
                    else if (void 0 !== r && (i = !0, v(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
                            return l.call(ce(e), n)
                        })), t))
                        for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
                    return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
                },
                R = /^-ms-/,
                I = /-([a-z])/g;

            function W(e, t) {
                return t.toUpperCase()
            }

            function F(e) {
                return e.replace(R, "ms-").replace(I, W)
            }
            var $ = function(e) {
                return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
            };

            function B() {
                this.expando = ce.expando + B.uid++
            }
            B.uid = 1, B.prototype = {
                cache: function(e) {
                    var t = e[this.expando];
                    return t || (t = {}, $(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                        value: t,
                        configurable: !0
                    }))), t
                },
                set: function(e, t, n) {
                    var r, i = this.cache(e);
                    if ("string" == typeof t) i[F(t)] = n;
                    else
                        for (r in t) i[F(r)] = t[r];
                    return i
                },
                get: function(e, t) {
                    return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][F(t)]
                },
                access: function(e, t, n) {
                    return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
                },
                remove: function(e, t) {
                    var n, r = e[this.expando];
                    if (void 0 !== r) {
                        if (void 0 !== t) {
                            n = (t = Array.isArray(t) ? t.map(F) : (t = F(t)) in r ? [t] : t.match(D) || []).length;
                            while (n--) delete r[t[n]]
                        }(void 0 === t || ce.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
                    }
                },
                hasData: function(e) {
                    var t = e[this.expando];
                    return void 0 !== t && !ce.isEmptyObject(t)
                }
            };
            var _ = new B,
                z = new B,
                X = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                U = /[A-Z]/g;

            function V(e, t, n) {
                var r, i;
                if (void 0 === n && 1 === e.nodeType)
                    if (r = "data-" + t.replace(U, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) {
                        try {
                            n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : X.test(i) ? JSON.parse(i) : i)
                        } catch (e) {}
                        z.set(e, t, n)
                    } else n = void 0;
                return n
            }
            ce.extend({
                hasData: function(e) {
                    return z.hasData(e) || _.hasData(e)
                },
                data: function(e, t, n) {
                    return z.access(e, t, n)
                },
                removeData: function(e, t) {
                    z.remove(e, t)
                },
                _data: function(e, t, n) {
                    return _.access(e, t, n)
                },
                _removeData: function(e, t) {
                    _.remove(e, t)
                }
            }), ce.fn.extend({
                data: function(n, e) {
                    var t, r, i, o = this[0],
                        a = o && o.attributes;
                    if (void 0 === n) {
                        if (this.length && (i = z.get(o), 1 === o.nodeType && !_.get(o, "hasDataAttrs"))) {
                            t = a.length;
                            while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = F(r.slice(5)), V(o, r, i[r]));
                            _.set(o, "hasDataAttrs", !0)
                        }
                        return i
                    }
                    return "object" == typeof n ? this.each(function() {
                        z.set(this, n)
                    }) : M(this, function(e) {
                        var t;
                        if (o && void 0 === e) return void 0 !== (t = z.get(o, n)) ? t : void 0 !== (t = V(o, n)) ? t : void 0;
                        this.each(function() {
                            z.set(this, n, e)
                        })
                    }, null, e, 1 < arguments.length, null, !0)
                },
                removeData: function(e) {
                    return this.each(function() {
                        z.remove(this, e)
                    })
                }
            }), ce.extend({
                queue: function(e, t, n) {
                    var r;
                    if (e) return t = (t || "fx") + "queue", r = _.get(e, t), n && (!r || Array.isArray(n) ? r = _.access(e, t, ce.makeArray(n)) : r.push(n)), r || []
                },
                dequeue: function(e, t) {
                    t = t || "fx";
                    var n = ce.queue(e, t),
                        r = n.length,
                        i = n.shift(),
                        o = ce._queueHooks(e, t);
                    "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function() {
                        ce.dequeue(e, t)
                    }, o)), !r && o && o.empty.fire()
                },
                _queueHooks: function(e, t) {
                    var n = t + "queueHooks";
                    return _.get(e, n) || _.access(e, n, {
                        empty: ce.Callbacks("once memory").add(function() {
                            _.remove(e, [t + "queue", n])
                        })
                    })
                }
            }), ce.fn.extend({
                queue: function(t, n) {
                    var e = 2;
                    return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? ce.queue(this[0], t) : void 0 === n ? this : this.each(function() {
                        var e = ce.queue(this, t, n);
                        ce._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && ce.dequeue(this, t)
                    })
                },
                dequeue: function(e) {
                    return this.each(function() {
                        ce.dequeue(this, e)
                    })
                },
                clearQueue: function(e) {
                    return this.queue(e || "fx", [])
                },
                promise: function(e, t) {
                    var n, r = 1,
                        i = ce.Deferred(),
                        o = this,
                        a = this.length,
                        s = function() {
                            --r || i.resolveWith(o, [o])
                        };
                    "string" != typeof e && (t = e, e = void 0), e = e || "fx";
                    while (a--)(n = _.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
                    return s(), i.promise(t)
                }
            });
            var G = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                Y = new RegExp("^(?:([+-])=|)(" + G + ")([a-z%]*)$", "i"),
                Q = ["Top", "Right", "Bottom", "Left"],
                J = C.documentElement,
                K = function(e) {
                    return ce.contains(e.ownerDocument, e)
                },
                Z = {
                    composed: !0
                };
            J.getRootNode && (K = function(e) {
                return ce.contains(e.ownerDocument, e) || e.getRootNode(Z) === e.ownerDocument
            });
            var ee = function(e, t) {
                return "none" === (e = t || e).style.display || "" === e.style.display && K(e) && "none" === ce.css(e, "display")
            };

            function te(e, t, n, r) {
                var i, o, a = 20,
                    s = r ? function() {
                        return r.cur()
                    } : function() {
                        return ce.css(e, t, "")
                    },
                    u = s(),
                    l = n && n[3] || (ce.cssNumber[t] ? "" : "px"),
                    c = e.nodeType && (ce.cssNumber[t] || "px" !== l && +u) && Y.exec(ce.css(e, t));
                if (c && c[3] !== l) {
                    u /= 2, l = l || c[3], c = +u || 1;
                    while (a--) ce.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
                    c *= 2, ce.style(e, t, c + l), n = n || []
                }
                return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i
            }
            var ne = {};

            function re(e, t) {
                for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = _.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ee(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ne[s]) || (o = a.body.appendChild(a.createElement(s)), u = ce.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ne[s] = u)))) : "none" !== n && (l[c] = "none", _.set(r, "display", n)));
                for (c = 0; c < f; c++) null != l[c] && (e[c].style.display = l[c]);
                return e
            }
            ce.fn.extend({
                show: function() {
                    return re(this, !0)
                },
                hide: function() {
                    return re(this)
                },
                toggle: function(e) {
                    return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                        ee(this) ? ce(this).show() : ce(this).hide()
                    })
                }
            });
            var xe, be, we = /^(?:checkbox|radio)$/i,
                Te = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
                Ce = /^$|^module$|\/(?:java|ecma)script/i;
            xe = C.createDocumentFragment().appendChild(C.createElement("div")), (be = C.createElement("input")).setAttribute("type", "radio"), be.setAttribute("checked", "checked"), be.setAttribute("name", "t"), xe.appendChild(be), le.checkClone = xe.cloneNode(!0).cloneNode(!0).lastChild.checked, xe.innerHTML = "<textarea>x</textarea>", le.noCloneChecked = !!xe.cloneNode(!0).lastChild.defaultValue, xe.innerHTML = "<option></option>", le.option = !!xe.lastChild;
            var ke = {
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };

            function Se(e, t) {
                var n;
                return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && fe(e, t) ? ce.merge([e], n) : n
            }

            function Ee(e, t) {
                for (var n = 0, r = e.length; n < r; n++) _.set(e[n], "globalEval", !t || _.get(t[n], "globalEval"))
            }
            ke.tbody = ke.tfoot = ke.colgroup = ke.caption = ke.thead, ke.th = ke.td, le.option || (ke.optgroup = ke.option = [1, "<select multiple='multiple'>", "</select>"]);
            var je = /<|&#?\w+;/;

            function Ae(e, t, n, r, i) {
                for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
                    if ((o = e[d]) || 0 === o)
                        if ("object" === x(o)) ce.merge(p, o.nodeType ? [o] : o);
                        else if (je.test(o)) {
                    a = a || f.appendChild(t.createElement("div")), s = (Te.exec(o) || ["", ""])[1].toLowerCase(), u = ke[s] || ke._default, a.innerHTML = u[1] + ce.htmlPrefilter(o) + u[2], c = u[0];
                    while (c--) a = a.lastChild;
                    ce.merge(p, a.childNodes), (a = f.firstChild).textContent = ""
                } else p.push(t.createTextNode(o));
                f.textContent = "", d = 0;
                while (o = p[d++])
                    if (r && -1 < ce.inArray(o, r)) i && i.push(o);
                    else if (l = K(o), a = Se(f.appendChild(o), "script"), l && Ee(a), n) {
                    c = 0;
                    while (o = a[c++]) Ce.test(o.type || "") && n.push(o)
                }
                return f
            }
            var De = /^([^.]*)(?:\.(.+)|)/;

            function Ne() {
                return !0
            }

            function qe() {
                return !1
            }

            function Le(e, t, n, r, i, o) {
                var a, s;
                if ("object" == typeof t) {
                    for (s in "string" != typeof n && (r = r || n, n = void 0), t) Le(e, s, n, r, t[s], o);
                    return e
                }
                if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = qe;
                else if (!i) return e;
                return 1 === o && (a = i, (i = function(e) {
                    return ce().off(e), a.apply(this, arguments)
                }).guid = a.guid || (a.guid = ce.guid++)), e.each(function() {
                    ce.event.add(this, t, i, r, n)
                })
            }

            function He(e, r, t) {
                t ? (_.set(e, r, !1), ce.event.add(e, r, {
                    namespace: !1,
                    handler: function(e) {
                        var t, n = _.get(this, r);
                        if (1 & e.isTrigger && this[r]) {
                            if (n)(ce.event.special[r] || {}).delegateType && e.stopPropagation();
                            else if (n = ae.call(arguments), _.set(this, r, n), this[r](), t = _.get(this, r), _.set(this, r, !1), n !== t) return e.stopImmediatePropagation(), e.preventDefault(), t
                        } else n && (_.set(this, r, ce.event.trigger(n[0], n.slice(1), this)), e.stopPropagation(), e.isImmediatePropagationStopped = Ne)
                    }
                })) : void 0 === _.get(e, r) && ce.event.add(e, r, Ne)
            }
            ce.event = {
                global: {},
                add: function(t, e, n, r, i) {
                    var o, a, s, u, l, c, f, p, d, h, g, v = _.get(t);
                    if ($(t)) {
                        n.handler && (n = (o = n).handler, i = o.selector), i && ce.find.matchesSelector(J, i), n.guid || (n.guid = ce.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function(e) {
                            return "undefined" != typeof ce && ce.event.triggered !== e.type ? ce.event.dispatch.apply(t, arguments) : void 0
                        }), l = (e = (e || "").match(D) || [""]).length;
                        while (l--) d = g = (s = De.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = ce.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = ce.event.special[d] || {}, c = ce.extend({
                            type: d,
                            origType: g,
                            data: r,
                            handler: n,
                            guid: n.guid,
                            selector: i,
                            needsContext: i && ce.expr.match.needsContext.test(i),
                            namespace: h.join(".")
                        }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), ce.event.global[d] = !0)
                    }
                },
                remove: function(e, t, n, r, i) {
                    var o, a, s, u, l, c, f, p, d, h, g, v = _.hasData(e) && _.get(e);
                    if (v && (u = v.events)) {
                        l = (t = (t || "").match(D) || [""]).length;
                        while (l--)
                            if (d = g = (s = De.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
                                f = ce.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;
                                while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
                                a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || ce.removeEvent(e, d, v.handle), delete u[d])
                            } else
                                for (d in u) ce.event.remove(e, d + t[l], n, r, !0);
                        ce.isEmptyObject(u) && _.remove(e, "handle events")
                    }
                },
                dispatch: function(e) {
                    var t, n, r, i, o, a, s = new Array(arguments.length),
                        u = ce.event.fix(e),
                        l = (_.get(this, "events") || Object.create(null))[u.type] || [],
                        c = ce.event.special[u.type] || {};
                    for (s[0] = u, t = 1; t < arguments.length; t++) s[t] = arguments[t];
                    if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
                        a = ce.event.handlers.call(this, u, l), t = 0;
                        while ((i = a[t++]) && !u.isPropagationStopped()) {
                            u.currentTarget = i.elem, n = 0;
                            while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((ce.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()))
                        }
                        return c.postDispatch && c.postDispatch.call(this, u), u.result
                    }
                },
                handlers: function(e, t) {
                    var n, r, i, o, a, s = [],
                        u = t.delegateCount,
                        l = e.target;
                    if (u && l.nodeType && !("click" === e.type && 1 <= e.button))
                        for (; l !== this; l = l.parentNode || this)
                            if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
                                for (o = [], a = {}, n = 0; n < u; n++) void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < ce(i, this).index(l) : ce.find(i, this, null, [l]).length), a[i] && o.push(r);
                                o.length && s.push({
                                    elem: l,
                                    handlers: o
                                })
                            }
                    return l = this, u < t.length && s.push({
                        elem: l,
                        handlers: t.slice(u)
                    }), s
                },
                addProp: function(t, e) {
                    Object.defineProperty(ce.Event.prototype, t, {
                        enumerable: !0,
                        configurable: !0,
                        get: v(e) ? function() {
                            if (this.originalEvent) return e(this.originalEvent)
                        } : function() {
                            if (this.originalEvent) return this.originalEvent[t]
                        },
                        set: function(e) {
                            Object.defineProperty(this, t, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: e
                            })
                        }
                    })
                },
                fix: function(e) {
                    return e[ce.expando] ? e : new ce.Event(e)
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    click: {
                        setup: function(e) {
                            var t = this || e;
                            return we.test(t.type) && t.click && fe(t, "input") && He(t, "click", !0), !1
                        },
                        trigger: function(e) {
                            var t = this || e;
                            return we.test(t.type) && t.click && fe(t, "input") && He(t, "click"), !0
                        },
                        _default: function(e) {
                            var t = e.target;
                            return we.test(t.type) && t.click && fe(t, "input") && _.get(t, "click") || fe(t, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function(e) {
                            void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                        }
                    }
                }
            }, ce.removeEvent = function(e, t, n) {
                e.removeEventListener && e.removeEventListener(t, n)
            }, ce.Event = function(e, t) {
                if (!(this instanceof ce.Event)) return new ce.Event(e, t);
                e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ne : qe, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && ce.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[ce.expando] = !0
            }, ce.Event.prototype = {
                constructor: ce.Event,
                isDefaultPrevented: qe,
                isPropagationStopped: qe,
                isImmediatePropagationStopped: qe,
                isSimulated: !1,
                preventDefault: function() {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = Ne, e && !this.isSimulated && e.preventDefault()
                },
                stopPropagation: function() {
                    var e = this.originalEvent;
                    this.isPropagationStopped = Ne, e && !this.isSimulated && e.stopPropagation()
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = Ne, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
                }
            }, ce.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                "char": !0,
                code: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: !0
            }, ce.event.addProp), ce.each({
                focus: "focusin",
                blur: "focusout"
            }, function(r, i) {
                function o(e) {
                    if (C.documentMode) {
                        var t = _.get(this, "handle"),
                            n = ce.event.fix(e);
                        n.type = "focusin" === e.type ? "focus" : "blur", n.isSimulated = !0, t(e), n.target === n.currentTarget && t(n)
                    } else ce.event.simulate(i, e.target, ce.event.fix(e))
                }
                ce.event.special[r] = {
                    setup: function() {
                        var e;
                        if (He(this, r, !0), !C.documentMode) return !1;
                        (e = _.get(this, i)) || this.addEventListener(i, o), _.set(this, i, (e || 0) + 1)
                    },
                    trigger: function() {
                        return He(this, r), !0
                    },
                    teardown: function() {
                        var e;
                        if (!C.documentMode) return !1;
                        (e = _.get(this, i) - 1) ? _.set(this, i, e): (this.removeEventListener(i, o), _.remove(this, i))
                    },
                    _default: function(e) {
                        return _.get(e.target, r)
                    },
                    delegateType: i
                }, ce.event.special[i] = {
                    setup: function() {
                        var e = this.ownerDocument || this.document || this,
                            t = C.documentMode ? this : e,
                            n = _.get(t, i);
                        n || (C.documentMode ? this.addEventListener(i, o) : e.addEventListener(r, o, !0)), _.set(t, i, (n || 0) + 1)
                    },
                    teardown: function() {
                        var e = this.ownerDocument || this.document || this,
                            t = C.documentMode ? this : e,
                            n = _.get(t, i) - 1;
                        n ? _.set(t, i, n) : (C.documentMode ? this.removeEventListener(i, o) : e.removeEventListener(r, o, !0), _.remove(t, i))
                    }
                }
            }), ce.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(e, i) {
                ce.event.special[e] = {
                    delegateType: i,
                    bindType: i,
                    handle: function(e) {
                        var t, n = e.relatedTarget,
                            r = e.handleObj;
                        return n && (n === this || ce.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t
                    }
                }
            }), ce.fn.extend({
                on: function(e, t, n, r) {
                    return Le(this, e, t, n, r)
                },
                one: function(e, t, n, r) {
                    return Le(this, e, t, n, r, 1)
                },
                off: function(e, t, n) {
                    var r, i;
                    if (e && e.preventDefault && e.handleObj) return r = e.handleObj, ce(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
                    if ("object" == typeof e) {
                        for (i in e) this.off(i, t, e[i]);
                        return this
                    }
                    return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = qe), this.each(function() {
                        ce.event.remove(this, e, n, t)
                    })
                }
            });
            var Oe = /<script|<style|<link/i,
                Pe = /checked\s*(?:[^=]|=\s*.checked.)/i,
                Me = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

            function Re(e, t) {
                return fe(e, "table") && fe(11 !== t.nodeType ? t : t.firstChild, "tr") && ce(e).children("tbody")[0] || e
            }

            function Ie(e) {
                return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
            }

            function We(e) {
                return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
            }

            function Fe(e, t) {
                var n, r, i, o, a, s;
                if (1 === t.nodeType) {
                    if (_.hasData(e) && (s = _.get(e).events))
                        for (i in _.remove(t, "handle events"), s)
                            for (n = 0, r = s[i].length; n < r; n++) ce.event.add(t, i, s[i][n]);
                    z.hasData(e) && (o = z.access(e), a = ce.extend({}, o), z.set(t, a))
                }
            }

            function $e(n, r, i, o) {
                r = g(r);
                var e, t, a, s, u, l, c = 0,
                    f = n.length,
                    p = f - 1,
                    d = r[0],
                    h = v(d);
                if (h || 1 < f && "string" == typeof d && !le.checkClone && Pe.test(d)) return n.each(function(e) {
                    var t = n.eq(e);
                    h && (r[0] = d.call(this, e, t.html())), $e(t, r, i, o)
                });
                if (f && (t = (e = Ae(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
                    for (s = (a = ce.map(Se(e, "script"), Ie)).length; c < f; c++) u = e, c !== p && (u = ce.clone(u, !0, !0), s && ce.merge(a, Se(u, "script"))), i.call(n[c], u, c);
                    if (s)
                        for (l = a[a.length - 1].ownerDocument, ce.map(a, We), c = 0; c < s; c++) u = a[c], Ce.test(u.type || "") && !_.access(u, "globalEval") && ce.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? ce._evalUrl && !u.noModule && ce._evalUrl(u.src, {
                            nonce: u.nonce || u.getAttribute("nonce")
                        }, l) : m(u.textContent.replace(Me, ""), u, l))
                }
                return n
            }

            function Be(e, t, n) {
                for (var r, i = t ? ce.filter(t, e) : e, o = 0; null != (r = i[o]); o++) n || 1 !== r.nodeType || ce.cleanData(Se(r)), r.parentNode && (n && K(r) && Ee(Se(r, "script")), r.parentNode.removeChild(r));
                return e
            }
            ce.extend({
                htmlPrefilter: function(e) {
                    return e
                },
                clone: function(e, t, n) {
                    var r, i, o, a, s, u, l, c = e.cloneNode(!0),
                        f = K(e);
                    if (!(le.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || ce.isXMLDoc(e)))
                        for (a = Se(c), r = 0, i = (o = Se(e)).length; r < i; r++) s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && we.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
                    if (t)
                        if (n)
                            for (o = o || Se(e), a = a || Se(c), r = 0, i = o.length; r < i; r++) Fe(o[r], a[r]);
                        else Fe(e, c);
                    return 0 < (a = Se(c, "script")).length && Ee(a, !f && Se(e, "script")), c
                },
                cleanData: function(e) {
                    for (var t, n, r, i = ce.event.special, o = 0; void 0 !== (n = e[o]); o++)
                        if ($(n)) {
                            if (t = n[_.expando]) {
                                if (t.events)
                                    for (r in t.events) i[r] ? ce.event.remove(n, r) : ce.removeEvent(n, r, t.handle);
                                n[_.expando] = void 0
                            }
                            n[z.expando] && (n[z.expando] = void 0)
                        }
                }
            }), ce.fn.extend({
                detach: function(e) {
                    return Be(this, e, !0)
                },
                remove: function(e) {
                    return Be(this, e)
                },
                text: function(e) {
                    return M(this, function(e) {
                        return void 0 === e ? ce.text(this) : this.empty().each(function() {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                        })
                    }, null, e, arguments.length)
                },
                append: function() {
                    return $e(this, arguments, function(e) {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Re(this, e).appendChild(e)
                    })
                },
                prepend: function() {
                    return $e(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var t = Re(this, e);
                            t.insertBefore(e, t.firstChild)
                        }
                    })
                },
                before: function() {
                    return $e(this, arguments, function(e) {
                        this.parentNode && this.parentNode.insertBefore(e, this)
                    })
                },
                after: function() {
                    return $e(this, arguments, function(e) {
                        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                    })
                },
                empty: function() {
                    for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (ce.cleanData(Se(e, !1)), e.textContent = "");
                    return this
                },
                clone: function(e, t) {
                    return e = null != e && e, t = null == t ? e : t, this.map(function() {
                        return ce.clone(this, e, t)
                    })
                },
                html: function(e) {
                    return M(this, function(e) {
                        var t = this[0] || {},
                            n = 0,
                            r = this.length;
                        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                        if ("string" == typeof e && !Oe.test(e) && !ke[(Te.exec(e) || ["", ""])[1].toLowerCase()]) {
                            e = ce.htmlPrefilter(e);
                            try {
                                for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (ce.cleanData(Se(t, !1)), t.innerHTML = e);
                                t = 0
                            } catch (e) {}
                        }
                        t && this.empty().append(e)
                    }, null, e, arguments.length)
                },
                replaceWith: function() {
                    var n = [];
                    return $e(this, arguments, function(e) {
                        var t = this.parentNode;
                        ce.inArray(this, n) < 0 && (ce.cleanData(Se(this)), t && t.replaceChild(e, this))
                    }, n)
                }
            }), ce.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(e, a) {
                ce.fn[e] = function(e) {
                    for (var t, n = [], r = ce(e), i = r.length - 1, o = 0; o <= i; o++) t = o === i ? this : this.clone(!0), ce(r[o])[a](t), s.apply(n, t.get());
                    return this.pushStack(n)
                }
            });
            var _e = new RegExp("^(" + G + ")(?!px)[a-z%]+$", "i"),
                ze = /^--/,
                Xe = function(e) {
                    var t = e.ownerDocument.defaultView;
                    return t && t.opener || (t = ie), t.getComputedStyle(e)
                },
                Ue = function(e, t, n) {
                    var r, i, o = {};
                    for (i in t) o[i] = e.style[i], e.style[i] = t[i];
                    for (i in r = n.call(e), t) e.style[i] = o[i];
                    return r
                },
                Ve = new RegExp(Q.join("|"), "i");

            function Ge(e, t, n) {
                var r, i, o, a, s = ze.test(t),
                    u = e.style;
                return (n = n || Xe(e)) && (a = n.getPropertyValue(t) || n[t], s && a && (a = a.replace(ve, "$1") || void 0), "" !== a || K(e) || (a = ce.style(e, t)), !le.pixelBoxStyles() && _e.test(a) && Ve.test(t) && (r = u.width, i = u.minWidth, o = u.maxWidth, u.minWidth = u.maxWidth = u.width = a, a = n.width, u.width = r, u.minWidth = i, u.maxWidth = o)), void 0 !== a ? a + "" : a
            }

            function Ye(e, t) {
                return {
                    get: function() {
                        if (!e()) return (this.get = t).apply(this, arguments);
                        delete this.get
                    }
                }
            }! function() {
                function e() {
                    if (l) {
                        u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", J.appendChild(u).appendChild(l);
                        var e = ie.getComputedStyle(l);
                        n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), J.removeChild(u), l = null
                    }
                }

                function t(e) {
                    return Math.round(parseFloat(e))
                }
                var n, r, i, o, a, s, u = C.createElement("div"),
                    l = C.createElement("div");
                l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", le.clearCloneStyle = "content-box" === l.style.backgroundClip, ce.extend(le, {
                    boxSizingReliable: function() {
                        return e(), r
                    },
                    pixelBoxStyles: function() {
                        return e(), o
                    },
                    pixelPosition: function() {
                        return e(), n
                    },
                    reliableMarginLeft: function() {
                        return e(), s
                    },
                    scrollboxSize: function() {
                        return e(), i
                    },
                    reliableTrDimensions: function() {
                        var e, t, n, r;
                        return null == a && (e = C.createElement("table"), t = C.createElement("tr"), n = C.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "box-sizing:content-box;border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", J.appendChild(e).appendChild(t).appendChild(n), r = ie.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, J.removeChild(e)), a
                    }
                }))
            }();
            var Qe = ["Webkit", "Moz", "ms"],
                Je = C.createElement("div").style,
                Ke = {};

            function Ze(e) {
                var t = ce.cssProps[e] || Ke[e];
                return t || (e in Je ? e : Ke[e] = function(e) {
                    var t = e[0].toUpperCase() + e.slice(1),
                        n = Qe.length;
                    while (n--)
                        if ((e = Qe[n] + t) in Je) return e
                }(e) || e)
            }
            var et = /^(none|table(?!-c[ea]).+)/,
                tt = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                nt = {
                    letterSpacing: "0",
                    fontWeight: "400"
                };

            function rt(e, t, n) {
                var r = Y.exec(t);
                return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t
            }

            function it(e, t, n, r, i, o) {
                var a = "width" === t ? 1 : 0,
                    s = 0,
                    u = 0,
                    l = 0;
                if (n === (r ? "border" : "content")) return 0;
                for (; a < 4; a += 2) "margin" === n && (l += ce.css(e, n + Q[a], !0, i)), r ? ("content" === n && (u -= ce.css(e, "padding" + Q[a], !0, i)), "margin" !== n && (u -= ce.css(e, "border" + Q[a] + "Width", !0, i))) : (u += ce.css(e, "padding" + Q[a], !0, i), "padding" !== n ? u += ce.css(e, "border" + Q[a] + "Width", !0, i) : s += ce.css(e, "border" + Q[a] + "Width", !0, i));
                return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u + l
            }

            function ot(e, t, n) {
                var r = Xe(e),
                    i = (!le.boxSizingReliable() || n) && "border-box" === ce.css(e, "boxSizing", !1, r),
                    o = i,
                    a = Ge(e, t, r),
                    s = "offset" + t[0].toUpperCase() + t.slice(1);
                if (_e.test(a)) {
                    if (!n) return a;
                    a = "auto"
                }
                return (!le.boxSizingReliable() && i || !le.reliableTrDimensions() && fe(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === ce.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === ce.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + it(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
            }

            function at(e, t, n, r, i) {
                return new at.prototype.init(e, t, n, r, i)
            }
            ce.extend({
                cssHooks: {
                    opacity: {
                        get: function(e, t) {
                            if (t) {
                                var n = Ge(e, "opacity");
                                return "" === n ? "1" : n
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    aspectRatio: !0,
                    borderImageSlice: !0,
                    columnCount: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    gridArea: !0,
                    gridColumn: !0,
                    gridColumnEnd: !0,
                    gridColumnStart: !0,
                    gridRow: !0,
                    gridRowEnd: !0,
                    gridRowStart: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    scale: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0,
                    fillOpacity: !0,
                    floodOpacity: !0,
                    stopOpacity: !0,
                    strokeMiterlimit: !0,
                    strokeOpacity: !0
                },
                cssProps: {},
                style: function(e, t, n, r) {
                    if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                        var i, o, a, s = F(t),
                            u = ze.test(t),
                            l = e.style;
                        if (u || (t = Ze(s)), a = ce.cssHooks[t] || ce.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
                        "string" === (o = typeof n) && (i = Y.exec(n)) && i[1] && (n = te(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (ce.cssNumber[s] ? "" : "px")), le.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n))
                    }
                },
                css: function(e, t, n, r) {
                    var i, o, a, s = F(t);
                    return ze.test(t) || (t = Ze(s)), (a = ce.cssHooks[t] || ce.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = Ge(e, t, r)), "normal" === i && t in nt && (i = nt[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
                }
            }), ce.each(["height", "width"], function(e, u) {
                ce.cssHooks[u] = {
                    get: function(e, t, n) {
                        if (t) return !et.test(ce.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? ot(e, u, n) : Ue(e, tt, function() {
                            return ot(e, u, n)
                        })
                    },
                    set: function(e, t, n) {
                        var r, i = Xe(e),
                            o = !le.scrollboxSize() && "absolute" === i.position,
                            a = (o || n) && "border-box" === ce.css(e, "boxSizing", !1, i),
                            s = n ? it(e, u, n, a, i) : 0;
                        return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - it(e, u, "border", !1, i) - .5)), s && (r = Y.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = ce.css(e, u)), rt(0, t, s)
                    }
                }
            }), ce.cssHooks.marginLeft = Ye(le.reliableMarginLeft, function(e, t) {
                if (t) return (parseFloat(Ge(e, "marginLeft")) || e.getBoundingClientRect().left - Ue(e, {
                    marginLeft: 0
                }, function() {
                    return e.getBoundingClientRect().left
                })) + "px"
            }), ce.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(i, o) {
                ce.cssHooks[i + o] = {
                    expand: function(e) {
                        for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) n[i + Q[t] + o] = r[t] || r[t - 2] || r[0];
                        return n
                    }
                }, "margin" !== i && (ce.cssHooks[i + o].set = rt)
            }), ce.fn.extend({
                css: function(e, t) {
                    return M(this, function(e, t, n) {
                        var r, i, o = {},
                            a = 0;
                        if (Array.isArray(t)) {
                            for (r = Xe(e), i = t.length; a < i; a++) o[t[a]] = ce.css(e, t[a], !1, r);
                            return o
                        }
                        return void 0 !== n ? ce.style(e, t, n) : ce.css(e, t)
                    }, e, t, 1 < arguments.length)
                }
            }), ((ce.Tween = at).prototype = {
                constructor: at,
                init: function(e, t, n, r, i, o) {
                    this.elem = e, this.prop = n, this.easing = i || ce.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (ce.cssNumber[n] ? "" : "px")
                },
                cur: function() {
                    var e = at.propHooks[this.prop];
                    return e && e.get ? e.get(this) : at.propHooks._default.get(this)
                },
                run: function(e) {
                    var t, n = at.propHooks[this.prop];
                    return this.options.duration ? this.pos = t = ce.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : at.propHooks._default.set(this), this
                }
            }).init.prototype = at.prototype, (at.propHooks = {
                _default: {
                    get: function(e) {
                        var t;
                        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = ce.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
                    },
                    set: function(e) {
                        ce.fx.step[e.prop] ? ce.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !ce.cssHooks[e.prop] && null == e.elem.style[Ze(e.prop)] ? e.elem[e.prop] = e.now : ce.style(e.elem, e.prop, e.now + e.unit)
                    }
                }
            }).scrollTop = at.propHooks.scrollLeft = {
                set: function(e) {
                    e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
                }
            }, ce.easing = {
                linear: function(e) {
                    return e
                },
                swing: function(e) {
                    return .5 - Math.cos(e * Math.PI) / 2
                },
                _default: "swing"
            }, ce.fx = at.prototype.init, ce.fx.step = {};
            var st, ut, lt, ct, ft = /^(?:toggle|show|hide)$/,
                pt = /queueHooks$/;

            function dt() {
                ut && (!1 === C.hidden && ie.requestAnimationFrame ? ie.requestAnimationFrame(dt) : ie.setTimeout(dt, ce.fx.interval), ce.fx.tick())
            }

            function ht() {
                return ie.setTimeout(function() {
                    st = void 0
                }), st = Date.now()
            }

            function gt(e, t) {
                var n, r = 0,
                    i = {
                        height: e
                    };
                for (t = t ? 1 : 0; r < 4; r += 2 - t) i["margin" + (n = Q[r])] = i["padding" + n] = e;
                return t && (i.opacity = i.width = e), i
            }

            function vt(e, t, n) {
                for (var r, i = (yt.tweeners[t] || []).concat(yt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
                    if (r = i[o].call(n, t, e)) return r
            }

            function yt(o, e, t) {
                var n, a, r = 0,
                    i = yt.prefilters.length,
                    s = ce.Deferred().always(function() {
                        delete u.elem
                    }),
                    u = function() {
                        if (a) return !1;
                        for (var e = st || ht(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) l.tweens[r].run(n);
                        return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1)
                    },
                    l = s.promise({
                        elem: o,
                        props: ce.extend({}, e),
                        opts: ce.extend(!0, {
                            specialEasing: {},
                            easing: ce.easing._default
                        }, t),
                        originalProperties: e,
                        originalOptions: t,
                        startTime: st || ht(),
                        duration: t.duration,
                        tweens: [],
                        createTween: function(e, t) {
                            var n = ce.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
                            return l.tweens.push(n), n
                        },
                        stop: function(e) {
                            var t = 0,
                                n = e ? l.tweens.length : 0;
                            if (a) return this;
                            for (a = !0; t < n; t++) l.tweens[t].run(1);
                            return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this
                        }
                    }),
                    c = l.props;
                for (! function(e, t) {
                        var n, r, i, o, a;
                        for (n in e)
                            if (i = t[r = F(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = ce.cssHooks[r]) && "expand" in a)
                                for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i);
                            else t[r] = i
                    }(c, l.opts.specialEasing); r < i; r++)
                    if (n = yt.prefilters[r].call(l, o, c, l.opts)) return v(n.stop) && (ce._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
                return ce.map(c, vt, l), v(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), ce.fx.timer(ce.extend(u, {
                    elem: o,
                    anim: l,
                    queue: l.opts.queue
                })), l
            }
            ce.Animation = ce.extend(yt, {
                tweeners: {
                    "*": [function(e, t) {
                        var n = this.createTween(e, t);
                        return te(n.elem, e, Y.exec(t), n), n
                    }]
                },
                tweener: function(e, t) {
                    v(e) ? (t = e, e = ["*"]) : e = e.match(D);
                    for (var n, r = 0, i = e.length; r < i; r++) n = e[r], yt.tweeners[n] = yt.tweeners[n] || [], yt.tweeners[n].unshift(t)
                },
                prefilters: [function(e, t, n) {
                    var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t,
                        p = this,
                        d = {},
                        h = e.style,
                        g = e.nodeType && ee(e),
                        v = _.get(e, "fxshow");
                    for (r in n.queue || (null == (a = ce._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
                            a.unqueued || s()
                        }), a.unqueued++, p.always(function() {
                            p.always(function() {
                                a.unqueued--, ce.queue(e, "fx").length || a.empty.fire()
                            })
                        })), t)
                        if (i = t[r], ft.test(i)) {
                            if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                                if ("show" !== i || !v || void 0 === v[r]) continue;
                                g = !0
                            }
                            d[r] = v && v[r] || ce.style(e, r)
                        }
                    if ((u = !ce.isEmptyObject(t)) || !ce.isEmptyObject(d))
                        for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = _.get(e, "display")), "none" === (c = ce.css(e, "display")) && (l ? c = l : (re([e], !0), l = e.style.display || l, c = ce.css(e, "display"), re([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === ce.css(e, "float") && (u || (p.done(function() {
                                h.display = l
                            }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function() {
                                h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2]
                            })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = _.access(e, "fxshow", {
                            display: l
                        }), o && (v.hidden = !g), g && re([e], !0), p.done(function() {
                            for (r in g || re([e]), _.remove(e, "fxshow"), d) ce.style(e, r, d[r])
                        })), u = vt(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0))
                }],
                prefilter: function(e, t) {
                    t ? yt.prefilters.unshift(e) : yt.prefilters.push(e)
                }
            }), ce.speed = function(e, t, n) {
                var r = e && "object" == typeof e ? ce.extend({}, e) : {
                    complete: n || !n && t || v(e) && e,
                    duration: e,
                    easing: n && t || t && !v(t) && t
                };
                return ce.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in ce.fx.speeds ? r.duration = ce.fx.speeds[r.duration] : r.duration = ce.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
                    v(r.old) && r.old.call(this), r.queue && ce.dequeue(this, r.queue)
                }, r
            }, ce.fn.extend({
                fadeTo: function(e, t, n, r) {
                    return this.filter(ee).css("opacity", 0).show().end().animate({
                        opacity: t
                    }, e, n, r)
                },
                animate: function(t, e, n, r) {
                    var i = ce.isEmptyObject(t),
                        o = ce.speed(e, n, r),
                        a = function() {
                            var e = yt(this, ce.extend({}, t), o);
                            (i || _.get(this, "finish")) && e.stop(!0)
                        };
                    return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
                },
                stop: function(i, e, o) {
                    var a = function(e) {
                        var t = e.stop;
                        delete e.stop, t(o)
                    };
                    return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function() {
                        var e = !0,
                            t = null != i && i + "queueHooks",
                            n = ce.timers,
                            r = _.get(this);
                        if (t) r[t] && r[t].stop && a(r[t]);
                        else
                            for (t in r) r[t] && r[t].stop && pt.test(t) && a(r[t]);
                        for (t = n.length; t--;) n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
                        !e && o || ce.dequeue(this, i)
                    })
                },
                finish: function(a) {
                    return !1 !== a && (a = a || "fx"), this.each(function() {
                        var e, t = _.get(this),
                            n = t[a + "queue"],
                            r = t[a + "queueHooks"],
                            i = ce.timers,
                            o = n ? n.length : 0;
                        for (t.finish = !0, ce.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
                        for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);
                        delete t.finish
                    })
                }
            }), ce.each(["toggle", "show", "hide"], function(e, r) {
                var i = ce.fn[r];
                ce.fn[r] = function(e, t, n) {
                    return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(gt(r, !0), e, t, n)
                }
            }), ce.each({
                slideDown: gt("show"),
                slideUp: gt("hide"),
                slideToggle: gt("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(e, r) {
                ce.fn[e] = function(e, t, n) {
                    return this.animate(r, e, t, n)
                }
            }), ce.timers = [], ce.fx.tick = function() {
                var e, t = 0,
                    n = ce.timers;
                for (st = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1);
                n.length || ce.fx.stop(), st = void 0
            }, ce.fx.timer = function(e) {
                ce.timers.push(e), ce.fx.start()
            }, ce.fx.interval = 13, ce.fx.start = function() {
                ut || (ut = !0, dt())
            }, ce.fx.stop = function() {
                ut = null
            }, ce.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, ce.fn.delay = function(r, e) {
                return r = ce.fx && ce.fx.speeds[r] || r, e = e || "fx", this.queue(e, function(e, t) {
                    var n = ie.setTimeout(e, r);
                    t.stop = function() {
                        ie.clearTimeout(n)
                    }
                })
            }, lt = C.createElement("input"), ct = C.createElement("select").appendChild(C.createElement("option")), lt.type = "checkbox", le.checkOn = "" !== lt.value, le.optSelected = ct.selected, (lt = C.createElement("input")).value = "t", lt.type = "radio", le.radioValue = "t" === lt.value;
            var mt, xt = ce.expr.attrHandle;
            ce.fn.extend({
                attr: function(e, t) {
                    return M(this, ce.attr, e, t, 1 < arguments.length)
                },
                removeAttr: function(e) {
                    return this.each(function() {
                        ce.removeAttr(this, e)
                    })
                }
            }), ce.extend({
                attr: function(e, t, n) {
                    var r, i, o = e.nodeType;
                    if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? ce.prop(e, t, n) : (1 === o && ce.isXMLDoc(e) || (i = ce.attrHooks[t.toLowerCase()] || (ce.expr.match.bool.test(t) ? mt : void 0)), void 0 !== n ? null === n ? void ce.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = ce.find.attr(e, t)) ? void 0 : r)
                },
                attrHooks: {
                    type: {
                        set: function(e, t) {
                            if (!le.radioValue && "radio" === t && fe(e, "input")) {
                                var n = e.value;
                                return e.setAttribute("type", t), n && (e.value = n), t
                            }
                        }
                    }
                },
                removeAttr: function(e, t) {
                    var n, r = 0,
                        i = t && t.match(D);
                    if (i && 1 === e.nodeType)
                        while (n = i[r++]) e.removeAttribute(n)
                }
            }), mt = {
                set: function(e, t, n) {
                    return !1 === t ? ce.removeAttr(e, n) : e.setAttribute(n, n), n
                }
            }, ce.each(ce.expr.match.bool.source.match(/\w+/g), function(e, t) {
                var a = xt[t] || ce.find.attr;
                xt[t] = function(e, t, n) {
                    var r, i, o = t.toLowerCase();
                    return n || (i = xt[o], xt[o] = r, r = null != a(e, t, n) ? o : null, xt[o] = i), r
                }
            });
            var bt = /^(?:input|select|textarea|button)$/i,
                wt = /^(?:a|area)$/i;

            function Tt(e) {
                return (e.match(D) || []).join(" ")
            }

            function Ct(e) {
                return e.getAttribute && e.getAttribute("class") || ""
            }

            function kt(e) {
                return Array.isArray(e) ? e : "string" == typeof e && e.match(D) || []
            }
            ce.fn.extend({
                prop: function(e, t) {
                    return M(this, ce.prop, e, t, 1 < arguments.length)
                },
                removeProp: function(e) {
                    return this.each(function() {
                        delete this[ce.propFix[e] || e]
                    })
                }
            }), ce.extend({
                prop: function(e, t, n) {
                    var r, i, o = e.nodeType;
                    if (3 !== o && 8 !== o && 2 !== o) return 1 === o && ce.isXMLDoc(e) || (t = ce.propFix[t] || t, i = ce.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
                },
                propHooks: {
                    tabIndex: {
                        get: function(e) {
                            var t = ce.find.attr(e, "tabindex");
                            return t ? parseInt(t, 10) : bt.test(e.nodeName) || wt.test(e.nodeName) && e.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                }
            }), le.optSelected || (ce.propHooks.selected = {
                get: function(e) {
                    var t = e.parentNode;
                    return t && t.parentNode && t.parentNode.selectedIndex, null
                },
                set: function(e) {
                    var t = e.parentNode;
                    t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
                }
            }), ce.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                ce.propFix[this.toLowerCase()] = this
            }), ce.fn.extend({
                addClass: function(t) {
                    var e, n, r, i, o, a;
                    return v(t) ? this.each(function(e) {
                        ce(this).addClass(t.call(this, e, Ct(this)))
                    }) : (e = kt(t)).length ? this.each(function() {
                        if (r = Ct(this), n = 1 === this.nodeType && " " + Tt(r) + " ") {
                            for (o = 0; o < e.length; o++) i = e[o], n.indexOf(" " + i + " ") < 0 && (n += i + " ");
                            a = Tt(n), r !== a && this.setAttribute("class", a)
                        }
                    }) : this
                },
                removeClass: function(t) {
                    var e, n, r, i, o, a;
                    return v(t) ? this.each(function(e) {
                        ce(this).removeClass(t.call(this, e, Ct(this)))
                    }) : arguments.length ? (e = kt(t)).length ? this.each(function() {
                        if (r = Ct(this), n = 1 === this.nodeType && " " + Tt(r) + " ") {
                            for (o = 0; o < e.length; o++) {
                                i = e[o];
                                while (-1 < n.indexOf(" " + i + " ")) n = n.replace(" " + i + " ", " ")
                            }
                            a = Tt(n), r !== a && this.setAttribute("class", a)
                        }
                    }) : this : this.attr("class", "")
                },
                toggleClass: function(t, n) {
                    var e, r, i, o, a = typeof t,
                        s = "string" === a || Array.isArray(t);
                    return v(t) ? this.each(function(e) {
                        ce(this).toggleClass(t.call(this, e, Ct(this), n), n)
                    }) : "boolean" == typeof n && s ? n ? this.addClass(t) : this.removeClass(t) : (e = kt(t), this.each(function() {
                        if (s)
                            for (o = ce(this), i = 0; i < e.length; i++) r = e[i], o.hasClass(r) ? o.removeClass(r) : o.addClass(r);
                        else void 0 !== t && "boolean" !== a || ((r = Ct(this)) && _.set(this, "__className__", r), this.setAttribute && this.setAttribute("class", r || !1 === t ? "" : _.get(this, "__className__") || ""))
                    }))
                },
                hasClass: function(e) {
                    var t, n, r = 0;
                    t = " " + e + " ";
                    while (n = this[r++])
                        if (1 === n.nodeType && -1 < (" " + Tt(Ct(n)) + " ").indexOf(t)) return !0;
                    return !1
                }
            });
            var St = /\r/g;
            ce.fn.extend({
                val: function(n) {
                    var r, e, i, t = this[0];
                    return arguments.length ? (i = v(n), this.each(function(e) {
                        var t;
                        1 === this.nodeType && (null == (t = i ? n.call(this, e, ce(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = ce.map(t, function(e) {
                            return null == e ? "" : e + ""
                        })), (r = ce.valHooks[this.type] || ce.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t))
                    })) : t ? (r = ce.valHooks[t.type] || ce.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof(e = t.value) ? e.replace(St, "") : null == e ? "" : e : void 0
                }
            }), ce.extend({
                valHooks: {
                    option: {
                        get: function(e) {
                            var t = ce.find.attr(e, "value");
                            return null != t ? t : Tt(ce.text(e))
                        }
                    },
                    select: {
                        get: function(e) {
                            var t, n, r, i = e.options,
                                o = e.selectedIndex,
                                a = "select-one" === e.type,
                                s = a ? null : [],
                                u = a ? o + 1 : i.length;
                            for (r = o < 0 ? u : a ? o : 0; r < u; r++)
                                if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !fe(n.parentNode, "optgroup"))) {
                                    if (t = ce(n).val(), a) return t;
                                    s.push(t)
                                }
                            return s
                        },
                        set: function(e, t) {
                            var n, r, i = e.options,
                                o = ce.makeArray(t),
                                a = i.length;
                            while (a--)((r = i[a]).selected = -1 < ce.inArray(ce.valHooks.option.get(r), o)) && (n = !0);
                            return n || (e.selectedIndex = -1), o
                        }
                    }
                }
            }), ce.each(["radio", "checkbox"], function() {
                ce.valHooks[this] = {
                    set: function(e, t) {
                        if (Array.isArray(t)) return e.checked = -1 < ce.inArray(ce(e).val(), t)
                    }
                }, le.checkOn || (ce.valHooks[this].get = function(e) {
                    return null === e.getAttribute("value") ? "on" : e.value
                })
            });
            var Et = ie.location,
                jt = {
                    guid: Date.now()
                },
                At = /\?/;
            ce.parseXML = function(e) {
                var t, n;
                if (!e || "string" != typeof e) return null;
                try {
                    t = (new ie.DOMParser).parseFromString(e, "text/xml")
                } catch (e) {}
                return n = t && t.getElementsByTagName("parsererror")[0], t && !n || ce.error("Invalid XML: " + (n ? ce.map(n.childNodes, function(e) {
                    return e.textContent
                }).join("\n") : e)), t
            };
            var Dt = /^(?:focusinfocus|focusoutblur)$/,
                Nt = function(e) {
                    e.stopPropagation()
                };
            ce.extend(ce.event, {
                trigger: function(e, t, n, r) {
                    var i, o, a, s, u, l, c, f, p = [n || C],
                        d = ue.call(e, "type") ? e.type : e,
                        h = ue.call(e, "namespace") ? e.namespace.split(".") : [];
                    if (o = f = a = n = n || C, 3 !== n.nodeType && 8 !== n.nodeType && !Dt.test(d + ce.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[ce.expando] ? e : new ce.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : ce.makeArray(t, [e]), c = ce.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
                        if (!r && !c.noBubble && !y(n)) {
                            for (s = c.delegateType || d, Dt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) p.push(o), a = o;
                            a === (n.ownerDocument || C) && p.push(a.defaultView || a.parentWindow || ie)
                        }
                        i = 0;
                        while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (_.get(o, "events") || Object.create(null))[e.type] && _.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && $(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
                        return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !$(n) || u && v(n[d]) && !y(n) && ((a = n[u]) && (n[u] = null), ce.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, Nt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, Nt), ce.event.triggered = void 0, a && (n[u] = a)), e.result
                    }
                },
                simulate: function(e, t, n) {
                    var r = ce.extend(new ce.Event, n, {
                        type: e,
                        isSimulated: !0
                    });
                    ce.event.trigger(r, null, t)
                }
            }), ce.fn.extend({
                trigger: function(e, t) {
                    return this.each(function() {
                        ce.event.trigger(e, t, this)
                    })
                },
                triggerHandler: function(e, t) {
                    var n = this[0];
                    if (n) return ce.event.trigger(e, t, n, !0)
                }
            });
            var qt = /\[\]$/,
                Lt = /\r?\n/g,
                Ht = /^(?:submit|button|image|reset|file)$/i,
                Ot = /^(?:input|select|textarea|keygen)/i;

            function Pt(n, e, r, i) {
                var t;
                if (Array.isArray(e)) ce.each(e, function(e, t) {
                    r || qt.test(n) ? i(n, t) : Pt(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i)
                });
                else if (r || "object" !== x(e)) i(n, e);
                else
                    for (t in e) Pt(n + "[" + t + "]", e[t], r, i)
            }
            ce.param = function(e, t) {
                var n, r = [],
                    i = function(e, t) {
                        var n = v(t) ? t() : t;
                        r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
                    };
                if (null == e) return "";
                if (Array.isArray(e) || e.jquery && !ce.isPlainObject(e)) ce.each(e, function() {
                    i(this.name, this.value)
                });
                else
                    for (n in e) Pt(n, e[n], t, i);
                return r.join("&")
            }, ce.fn.extend({
                serialize: function() {
                    return ce.param(this.serializeArray())
                },
                serializeArray: function() {
                    return this.map(function() {
                        var e = ce.prop(this, "elements");
                        return e ? ce.makeArray(e) : this
                    }).filter(function() {
                        var e = this.type;
                        return this.name && !ce(this).is(":disabled") && Ot.test(this.nodeName) && !Ht.test(e) && (this.checked || !we.test(e))
                    }).map(function(e, t) {
                        var n = ce(this).val();
                        return null == n ? null : Array.isArray(n) ? ce.map(n, function(e) {
                            return {
                                name: t.name,
                                value: e.replace(Lt, "\r\n")
                            }
                        }) : {
                            name: t.name,
                            value: n.replace(Lt, "\r\n")
                        }
                    }).get()
                }
            });
            var Mt = /%20/g,
                Rt = /#.*$/,
                It = /([?&])_=[^&]*/,
                Wt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                Ft = /^(?:GET|HEAD)$/,
                $t = /^\/\//,
                Bt = {},
                _t = {},
                zt = "*/".concat("*"),
                Xt = C.createElement("a");

            function Ut(o) {
                return function(e, t) {
                    "string" != typeof e && (t = e, e = "*");
                    var n, r = 0,
                        i = e.toLowerCase().match(D) || [];
                    if (v(t))
                        while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t)
                }
            }

            function Vt(t, i, o, a) {
                var s = {},
                    u = t === _t;

                function l(e) {
                    var r;
                    return s[e] = !0, ce.each(t[e] || [], function(e, t) {
                        var n = t(i, o, a);
                        return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1)
                    }), r
                }
                return l(i.dataTypes[0]) || !s["*"] && l("*")
            }

            function Gt(e, t) {
                var n, r, i = ce.ajaxSettings.flatOptions || {};
                for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
                return r && ce.extend(!0, e, r), e
            }
            Xt.href = Et.href, ce.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: Et.href,
                    type: "GET",
                    isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": zt,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": JSON.parse,
                        "text xml": ce.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: function(e, t) {
                    return t ? Gt(Gt(e, ce.ajaxSettings), t) : Gt(ce.ajaxSettings, e)
                },
                ajaxPrefilter: Ut(Bt),
                ajaxTransport: Ut(_t),
                ajax: function(e, t) {
                    "object" == typeof e && (t = e, e = void 0), t = t || {};
                    var c, f, p, n, d, r, h, g, i, o, v = ce.ajaxSetup({}, t),
                        y = v.context || v,
                        m = v.context && (y.nodeType || y.jquery) ? ce(y) : ce.event,
                        x = ce.Deferred(),
                        b = ce.Callbacks("once memory"),
                        w = v.statusCode || {},
                        a = {},
                        s = {},
                        u = "canceled",
                        T = {
                            readyState: 0,
                            getResponseHeader: function(e) {
                                var t;
                                if (h) {
                                    if (!n) {
                                        n = {};
                                        while (t = Wt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2])
                                    }
                                    t = n[e.toLowerCase() + " "]
                                }
                                return null == t ? null : t.join(", ")
                            },
                            getAllResponseHeaders: function() {
                                return h ? p : null
                            },
                            setRequestHeader: function(e, t) {
                                return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this
                            },
                            overrideMimeType: function(e) {
                                return null == h && (v.mimeType = e), this
                            },
                            statusCode: function(e) {
                                var t;
                                if (e)
                                    if (h) T.always(e[T.status]);
                                    else
                                        for (t in e) w[t] = [w[t], e[t]];
                                return this
                            },
                            abort: function(e) {
                                var t = e || u;
                                return c && c.abort(t), l(0, t), this
                            }
                        };
                    if (x.promise(T), v.url = ((e || v.url || Et.href) + "").replace($t, Et.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(D) || [""], null == v.crossDomain) {
                        r = C.createElement("a");
                        try {
                            r.href = v.url, r.href = r.href, v.crossDomain = Xt.protocol + "//" + Xt.host != r.protocol + "//" + r.host
                        } catch (e) {
                            v.crossDomain = !0
                        }
                    }
                    if (v.data && v.processData && "string" != typeof v.data && (v.data = ce.param(v.data, v.traditional)), Vt(Bt, v, t, T), h) return T;
                    for (i in (g = ce.event && v.global) && 0 == ce.active++ && ce.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Ft.test(v.type), f = v.url.replace(Rt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Mt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (At.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(It, "$1"), o = (At.test(f) ? "&" : "?") + "_=" + jt.guid++ + o), v.url = f + o), v.ifModified && (ce.lastModified[f] && T.setRequestHeader("If-Modified-Since", ce.lastModified[f]), ce.etag[f] && T.setRequestHeader("If-None-Match", ce.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + zt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]);
                    if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();
                    if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Vt(_t, v, t, T)) {
                        if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
                        v.async && 0 < v.timeout && (d = ie.setTimeout(function() {
                            T.abort("timeout")
                        }, v.timeout));
                        try {
                            h = !1, c.send(a, l)
                        } catch (e) {
                            if (h) throw e;
                            l(-1, e)
                        }
                    } else l(-1, "No Transport");

                    function l(e, t, n, r) {
                        var i, o, a, s, u, l = t;
                        h || (h = !0, d && ie.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function(e, t, n) {
                            var r, i, o, a, s = e.contents,
                                u = e.dataTypes;
                            while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                            if (r)
                                for (i in s)
                                    if (s[i] && s[i].test(r)) {
                                        u.unshift(i);
                                        break
                                    }
                            if (u[0] in n) o = u[0];
                            else {
                                for (i in n) {
                                    if (!u[0] || e.converters[i + " " + u[0]]) {
                                        o = i;
                                        break
                                    }
                                    a || (a = i)
                                }
                                o = o || a
                            }
                            if (o) return o !== u[0] && u.unshift(o), n[o]
                        }(v, T, n)), !i && -1 < ce.inArray("script", v.dataTypes) && ce.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function() {}), s = function(e, t, n, r) {
                            var i, o, a, s, u, l = {},
                                c = e.dataTypes.slice();
                            if (c[1])
                                for (a in e.converters) l[a.toLowerCase()] = e.converters[a];
                            o = c.shift();
                            while (o)
                                if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
                                    if ("*" === o) o = u;
                                    else if ("*" !== u && u !== o) {
                                if (!(a = l[u + " " + o] || l["* " + o]))
                                    for (i in l)
                                        if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
                                            !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
                                            break
                                        }
                                if (!0 !== a)
                                    if (a && e["throws"]) t = a(t);
                                    else try {
                                        t = a(t)
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: a ? e : "No conversion from " + u + " to " + o
                                        }
                                    }
                            }
                            return {
                                state: "success",
                                data: t
                            }
                        }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (ce.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (ce.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --ce.active || ce.event.trigger("ajaxStop")))
                    }
                    return T
                },
                getJSON: function(e, t, n) {
                    return ce.get(e, t, n, "json")
                },
                getScript: function(e, t) {
                    return ce.get(e, void 0, t, "script")
                }
            }), ce.each(["get", "post"], function(e, i) {
                ce[i] = function(e, t, n, r) {
                    return v(t) && (r = r || n, n = t, t = void 0), ce.ajax(ce.extend({
                        url: e,
                        type: i,
                        dataType: r,
                        data: t,
                        success: n
                    }, ce.isPlainObject(e) && e))
                }
            }), ce.ajaxPrefilter(function(e) {
                var t;
                for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
            }), ce._evalUrl = function(e, t, n) {
                return ce.ajax({
                    url: e,
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    converters: {
                        "text script": function() {}
                    },
                    dataFilter: function(e) {
                        ce.globalEval(e, t, n)
                    }
                })
            }, ce.fn.extend({
                wrapAll: function(e) {
                    var t;
                    return this[0] && (v(e) && (e = e.call(this[0])), t = ce(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                        var e = this;
                        while (e.firstElementChild) e = e.firstElementChild;
                        return e
                    }).append(this)), this
                },
                wrapInner: function(n) {
                    return v(n) ? this.each(function(e) {
                        ce(this).wrapInner(n.call(this, e))
                    }) : this.each(function() {
                        var e = ce(this),
                            t = e.contents();
                        t.length ? t.wrapAll(n) : e.append(n)
                    })
                },
                wrap: function(t) {
                    var n = v(t);
                    return this.each(function(e) {
                        ce(this).wrapAll(n ? t.call(this, e) : t)
                    })
                },
                unwrap: function(e) {
                    return this.parent(e).not("body").each(function() {
                        ce(this).replaceWith(this.childNodes)
                    }), this
                }
            }), ce.expr.pseudos.hidden = function(e) {
                return !ce.expr.pseudos.visible(e)
            }, ce.expr.pseudos.visible = function(e) {
                return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
            }, ce.ajaxSettings.xhr = function() {
                try {
                    return new ie.XMLHttpRequest
                } catch (e) {}
            };
            var Yt = {
                    0: 200,
                    1223: 204
                },
                Qt = ce.ajaxSettings.xhr();
            le.cors = !!Qt && "withCredentials" in Qt, le.ajax = Qt = !!Qt, ce.ajaxTransport(function(i) {
                var o, a;
                if (le.cors || Qt && !i.crossDomain) return {
                    send: function(e, t) {
                        var n, r = i.xhr();
                        if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields)
                            for (n in i.xhrFields) r[n] = i.xhrFields[n];
                        for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]);
                        o = function(e) {
                            return function() {
                                o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Yt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
                                    binary: r.response
                                } : {
                                    text: r.responseText
                                }, r.getAllResponseHeaders()))
                            }
                        }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function() {
                            4 === r.readyState && ie.setTimeout(function() {
                                o && a()
                            })
                        }, o = o("abort");
                        try {
                            r.send(i.hasContent && i.data || null)
                        } catch (e) {
                            if (o) throw e
                        }
                    },
                    abort: function() {
                        o && o()
                    }
                }
            }), ce.ajaxPrefilter(function(e) {
                e.crossDomain && (e.contents.script = !1)
            }), ce.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(e) {
                        return ce.globalEval(e), e
                    }
                }
            }), ce.ajaxPrefilter("script", function(e) {
                void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
            }), ce.ajaxTransport("script", function(n) {
                var r, i;
                if (n.crossDomain || n.scriptAttrs) return {
                    send: function(e, t) {
                        r = ce("<script>").attr(n.scriptAttrs || {}).prop({
                            charset: n.scriptCharset,
                            src: n.url
                        }).on("load error", i = function(e) {
                            r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type)
                        }), C.head.appendChild(r[0])
                    },
                    abort: function() {
                        i && i()
                    }
                }
            });
            var Jt, Kt = [],
                Zt = /(=)\?(?=&|$)|\?\?/;
            ce.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var e = Kt.pop() || ce.expando + "_" + jt.guid++;
                    return this[e] = !0, e
                }
            }), ce.ajaxPrefilter("json jsonp", function(e, t, n) {
                var r, i, o, a = !1 !== e.jsonp && (Zt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Zt.test(e.data) && "data");
                if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = v(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Zt, "$1" + r) : !1 !== e.jsonp && (e.url += (At.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() {
                    return o || ce.error(r + " was not called"), o[0]
                }, e.dataTypes[0] = "json", i = ie[r], ie[r] = function() {
                    o = arguments
                }, n.always(function() {
                    void 0 === i ? ce(ie).removeProp(r) : ie[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Kt.push(r)), o && v(i) && i(o[0]), o = i = void 0
                }), "script"
            }), le.createHTMLDocument = ((Jt = C.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Jt.childNodes.length), ce.parseHTML = function(e, t, n) {
                return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (le.createHTMLDocument ? ((r = (t = C.implementation.createHTMLDocument("")).createElement("base")).href = C.location.href, t.head.appendChild(r)) : t = C), o = !n && [], (i = w.exec(e)) ? [t.createElement(i[1])] : (i = Ae([e], t, o), o && o.length && ce(o).remove(), ce.merge([], i.childNodes)));
                var r, i, o
            }, ce.fn.load = function(e, t, n) {
                var r, i, o, a = this,
                    s = e.indexOf(" ");
                return -1 < s && (r = Tt(e.slice(s)), e = e.slice(0, s)), v(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && ce.ajax({
                    url: e,
                    type: i || "GET",
                    dataType: "html",
                    data: t
                }).done(function(e) {
                    o = arguments, a.html(r ? ce("<div>").append(ce.parseHTML(e)).find(r) : e)
                }).always(n && function(e, t) {
                    a.each(function() {
                        n.apply(this, o || [e.responseText, t, e])
                    })
                }), this
            }, ce.expr.pseudos.animated = function(t) {
                return ce.grep(ce.timers, function(e) {
                    return t === e.elem
                }).length
            }, ce.offset = {
                setOffset: function(e, t, n) {
                    var r, i, o, a, s, u, l = ce.css(e, "position"),
                        c = ce(e),
                        f = {};
                    "static" === l && (e.style.position = "relative"), s = c.offset(), o = ce.css(e, "top"), u = ce.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), v(t) && (t = t.call(e, n, ce.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f)
                }
            }, ce.fn.extend({
                offset: function(t) {
                    if (arguments.length) return void 0 === t ? this : this.each(function(e) {
                        ce.offset.setOffset(this, t, e)
                    });
                    var e, n, r = this[0];
                    return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
                        top: e.top + n.pageYOffset,
                        left: e.left + n.pageXOffset
                    }) : {
                        top: 0,
                        left: 0
                    } : void 0
                },
                position: function() {
                    if (this[0]) {
                        var e, t, n, r = this[0],
                            i = {
                                top: 0,
                                left: 0
                            };
                        if ("fixed" === ce.css(r, "position")) t = r.getBoundingClientRect();
                        else {
                            t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;
                            while (e && (e === n.body || e === n.documentElement) && "static" === ce.css(e, "position")) e = e.parentNode;
                            e && e !== r && 1 === e.nodeType && ((i = ce(e).offset()).top += ce.css(e, "borderTopWidth", !0), i.left += ce.css(e, "borderLeftWidth", !0))
                        }
                        return {
                            top: t.top - i.top - ce.css(r, "marginTop", !0),
                            left: t.left - i.left - ce.css(r, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function() {
                    return this.map(function() {
                        var e = this.offsetParent;
                        while (e && "static" === ce.css(e, "position")) e = e.offsetParent;
                        return e || J
                    })
                }
            }), ce.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(t, i) {
                var o = "pageYOffset" === i;
                ce.fn[t] = function(e) {
                    return M(this, function(e, t, n) {
                        var r;
                        if (y(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
                        r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n
                    }, t, e, arguments.length)
                }
            }), ce.each(["top", "left"], function(e, n) {
                ce.cssHooks[n] = Ye(le.pixelPosition, function(e, t) {
                    if (t) return t = Ge(e, n), _e.test(t) ? ce(e).position()[n] + "px" : t
                })
            }), ce.each({
                Height: "height",
                Width: "width"
            }, function(a, s) {
                ce.each({
                    padding: "inner" + a,
                    content: s,
                    "": "outer" + a
                }, function(r, o) {
                    ce.fn[o] = function(e, t) {
                        var n = arguments.length && (r || "boolean" != typeof e),
                            i = r || (!0 === e || !0 === t ? "margin" : "border");
                        return M(this, function(e, t, n) {
                            var r;
                            return y(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? ce.css(e, t, i) : ce.style(e, t, n, i)
                        }, s, n ? e : void 0, n)
                    }
                })
            }), ce.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
                ce.fn[t] = function(e) {
                    return this.on(t, e)
                }
            }), ce.fn.extend({
                bind: function(e, t, n) {
                    return this.on(e, null, t, n)
                },
                unbind: function(e, t) {
                    return this.off(e, null, t)
                },
                delegate: function(e, t, n, r) {
                    return this.on(t, e, n, r)
                },
                undelegate: function(e, t, n) {
                    return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
                },
                hover: function(e, t) {
                    return this.on("mouseenter", e).on("mouseleave", t || e)
                }
            }), ce.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(e, n) {
                ce.fn[n] = function(e, t) {
                    return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n)
                }
            });
            var en = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
            ce.proxy = function(e, t) {
                var n, r, i;
                if ("string" == typeof t && (n = e[t], t = e, e = n), v(e)) return r = ae.call(arguments, 2), (i = function() {
                    return e.apply(t || this, r.concat(ae.call(arguments)))
                }).guid = e.guid = e.guid || ce.guid++, i
            }, ce.holdReady = function(e) {
                e ? ce.readyWait++ : ce.ready(!0)
            }, ce.isArray = Array.isArray, ce.parseJSON = JSON.parse, ce.nodeName = fe, ce.isFunction = v, ce.isWindow = y, ce.camelCase = F, ce.type = x, ce.now = Date.now, ce.isNumeric = function(e) {
                var t = ce.type(e);
                return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
            }, ce.trim = function(e) {
                return null == e ? "" : (e + "").replace(en, "$1")
            }, "function" == typeof define && define.amd && define("jquery", [], function() {
                return ce
            });
            var tn = ie.jQuery,
                nn = ie.$;
            return ce.noConflict = function(e) {
                return ie.$ === ce && (ie.$ = nn), e && ie.jQuery === ce && (ie.jQuery = tn), ce
            }, "undefined" == typeof e && (ie.jQuery = ie.$ = ce), ce
        });
    </script>
    <!-- jquery-ui.js -->
    <script>
        /*! jQuery UI - v1.13.2 - 2022-07-14 * http://jqueryui.com * Copyright jQuery Foundation and other contributors; Licensed MIT */ ! function(t) {
            "use strict";
            "function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery)
        }(function(V) {
            "use strict";
            V.ui = V.ui || {};
            V.ui.version = "1.13.2";
            var n, i = 0,
                a = Array.prototype.hasOwnProperty,
                r = Array.prototype.slice;
            V.cleanData = (n = V.cleanData, function(t) {
                for (var e, i, s = 0; null != (i = t[s]); s++)(e = V._data(i, "events")) && e.remove && V(i).triggerHandler("remove");
                n(t)
            }), V.widget = function(t, i, e) {
                var s, n, o, a = {},
                    r = t.split(".")[0],
                    l = r + "-" + (t = t.split(".")[1]);
                return e || (e = i, i = V.Widget), Array.isArray(e) && (e = V.extend.apply(null, [{}].concat(e))), V.expr.pseudos[l.toLowerCase()] = function(t) {
                    return !!V.data(t, l)
                }, V[r] = V[r] || {}, s = V[r][t], n = V[r][t] = function(t, e) {
                    if (!this || !this._createWidget) return new n(t, e);
                    arguments.length && this._createWidget(t, e)
                }, V.extend(n, s, {
                    version: e.version,
                    _proto: V.extend({}, e),
                    _childConstructors: []
                }), (o = new i).options = V.widget.extend({}, o.options), V.each(e, function(e, s) {
                    function n() {
                        return i.prototype[e].apply(this, arguments)
                    }

                    function o(t) {
                        return i.prototype[e].apply(this, t)
                    }
                    a[e] = "function" == typeof s ? function() {
                        var t, e = this._super,
                            i = this._superApply;
                        return this._super = n, this._superApply = o, t = s.apply(this, arguments), this._super = e, this._superApply = i, t
                    } : s
                }), n.prototype = V.widget.extend(o, {
                    widgetEventPrefix: s && o.widgetEventPrefix || t
                }, a, {
                    constructor: n,
                    namespace: r,
                    widgetName: t,
                    widgetFullName: l
                }), s ? (V.each(s._childConstructors, function(t, e) {
                    var i = e.prototype;
                    V.widget(i.namespace + "." + i.widgetName, n, e._proto)
                }), delete s._childConstructors) : i._childConstructors.push(n), V.widget.bridge(t, n), n
            }, V.widget.extend = function(t) {
                for (var e, i, s = r.call(arguments, 1), n = 0, o = s.length; n < o; n++)
                    for (e in s[n]) i = s[n][e], a.call(s[n], e) && void 0 !== i && (V.isPlainObject(i) ? t[e] = V.isPlainObject(t[e]) ? V.widget.extend({}, t[e], i) : V.widget.extend({}, i) : t[e] = i);
                return t
            }, V.widget.bridge = function(o, e) {
                var a = e.prototype.widgetFullName || o;
                V.fn[o] = function(i) {
                    var t = "string" == typeof i,
                        s = r.call(arguments, 1),
                        n = this;
                    return t ? this.length || "instance" !== i ? this.each(function() {
                        var t, e = V.data(this, a);
                        return "instance" === i ? (n = e, !1) : e ? "function" != typeof e[i] || "_" === i.charAt(0) ? V.error("no such method '" + i + "' for " + o + " widget instance") : (t = e[i].apply(e, s)) !== e && void 0 !== t ? (n = t && t.jquery ? n.pushStack(t.get()) : t, !1) : void 0 : V.error("cannot call methods on " + o + " prior to initialization; attempted to call method '" + i + "'")
                    }) : n = void 0 : (s.length && (i = V.widget.extend.apply(null, [i].concat(s))), this.each(function() {
                        var t = V.data(this, a);
                        t ? (t.option(i || {}), t._init && t._init()) : V.data(this, a, new e(i, this))
                    })), n
                }
            }, V.Widget = function() {}, V.Widget._childConstructors = [], V.Widget.prototype = {
                widgetName: "widget",
                widgetEventPrefix: "",
                defaultElement: "<div>",
                options: {
                    classes: {},
                    disabled: !1,
                    create: null
                },
                _createWidget: function(t, e) {
                    e = V(e || this.defaultElement || this)[0], this.element = V(e), this.uuid = i++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = V(), this.hoverable = V(), this.focusable = V(), this.classesElementLookup = {}, e !== this && (V.data(e, this.widgetFullName, this), this._on(!0, this.element, {
                        remove: function(t) {
                            t.target === e && this.destroy()
                        }
                    }), this.document = V(e.style ? e.ownerDocument : e.document || e), this.window = V(this.document[0].defaultView || this.document[0].parentWindow)), this.options = V.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init()
                },
                _getCreateOptions: function() {
                    return {}
                },
                _getCreateEventData: V.noop,
                _create: V.noop,
                _init: V.noop,
                destroy: function() {
                    var i = this;
                    this._destroy(), V.each(this.classesElementLookup, function(t, e) {
                        i._removeClass(e, t)
                    }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace)
                },
                _destroy: V.noop,
                widget: function() {
                    return this.element
                },
                option: function(t, e) {
                    var i, s, n, o = t;
                    if (0 === arguments.length) return V.widget.extend({}, this.options);
                    if ("string" == typeof t)
                        if (o = {}, t = (i = t.split(".")).shift(), i.length) {
                            for (s = o[t] = V.widget.extend({}, this.options[t]), n = 0; n < i.length - 1; n++) s[i[n]] = s[i[n]] || {}, s = s[i[n]];
                            if (t = i.pop(), 1 === arguments.length) return void 0 === s[t] ? null : s[t];
                            s[t] = e
                        } else {
                            if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
                            o[t] = e
                        }
                    return this._setOptions(o), this
                },
                _setOptions: function(t) {
                    for (var e in t) this._setOption(e, t[e]);
                    return this
                },
                _setOption: function(t, e) {
                    return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this
                },
                _setOptionClasses: function(t) {
                    var e, i, s;
                    for (e in t) s = this.classesElementLookup[e], t[e] !== this.options.classes[e] && s && s.length && (i = V(s.get()), this._removeClass(s, e), i.addClass(this._classes({
                        element: i,
                        keys: e,
                        classes: t,
                        add: !0
                    })))
                },
                _setOptionDisabled: function(t) {
                    this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"))
                },
                enable: function() {
                    return this._setOptions({
                        disabled: !1
                    })
                },
                disable: function() {
                    return this._setOptions({
                        disabled: !0
                    })
                },
                _classes: function(n) {
                    var o = [],
                        a = this;

                    function t(t, e) {
                        for (var i, s = 0; s < t.length; s++) i = a.classesElementLookup[t[s]] || V(), i = n.add ? (function() {
                            var i = [];
                            n.element.each(function(t, e) {
                                V.map(a.classesElementLookup, function(t) {
                                    return t
                                }).some(function(t) {
                                    return t.is(e)
                                }) || i.push(e)
                            }), a._on(V(i), {
                                remove: "_untrackClassesElement"
                            })
                        }(), V(V.uniqueSort(i.get().concat(n.element.get())))) : V(i.not(n.element).get()), a.classesElementLookup[t[s]] = i, o.push(t[s]), e && n.classes[t[s]] && o.push(n.classes[t[s]])
                    }
                    return (n = V.extend({
                        element: this.element,
                        classes: this.options.classes || {}
                    }, n)).keys && t(n.keys.match(/\S+/g) || [], !0), n.extra && t(n.extra.match(/\S+/g) || []), o.join(" ")
                },
                _untrackClassesElement: function(i) {
                    var s = this;
                    V.each(s.classesElementLookup, function(t, e) {
                        -1 !== V.inArray(i.target, e) && (s.classesElementLookup[t] = V(e.not(i.target).get()))
                    }), this._off(V(i.target))
                },
                _removeClass: function(t, e, i) {
                    return this._toggleClass(t, e, i, !1)
                },
                _addClass: function(t, e, i) {
                    return this._toggleClass(t, e, i, !0)
                },
                _toggleClass: function(t, e, i, s) {
                    var n = "string" == typeof t || null === t,
                        i = {
                            extra: n ? e : i,
                            keys: n ? t : e,
                            element: n ? this.element : t,
                            add: s = "boolean" == typeof s ? s : i
                        };
                    return i.element.toggleClass(this._classes(i), s), this
                },
                _on: function(n, o, t) {
                    var a, r = this;
                    "boolean" != typeof n && (t = o, o = n, n = !1), t ? (o = a = V(o), this.bindings = this.bindings.add(o)) : (t = o, o = this.element, a = this.widget()), V.each(t, function(t, e) {
                        function i() {
                            if (n || !0 !== r.options.disabled && !V(this).hasClass("ui-state-disabled")) return ("string" == typeof e ? r[e] : e).apply(r, arguments)
                        }
                        "string" != typeof e && (i.guid = e.guid = e.guid || i.guid || V.guid++);
                        var s = t.match(/^([\w:-]*)\s*(.*)$/),
                            t = s[1] + r.eventNamespace,
                            s = s[2];
                        s ? a.on(t, s, i) : o.on(t, i)
                    })
                },
                _off: function(t, e) {
                    e = (e || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(e), this.bindings = V(this.bindings.not(t).get()), this.focusable = V(this.focusable.not(t).get()), this.hoverable = V(this.hoverable.not(t).get())
                },
                _delay: function(t, e) {
                    var i = this;
                    return setTimeout(function() {
                        return ("string" == typeof t ? i[t] : t).apply(i, arguments)
                    }, e || 0)
                },
                _hoverable: function(t) {
                    this.hoverable = this.hoverable.add(t), this._on(t, {
                        mouseenter: function(t) {
                            this._addClass(V(t.currentTarget), null, "ui-state-hover")
                        },
                        mouseleave: function(t) {
                            this._removeClass(V(t.currentTarget), null, "ui-state-hover")
                        }
                    })
                },
                _focusable: function(t) {
                    this.focusable = this.focusable.add(t), this._on(t, {
                        focusin: function(t) {
                            this._addClass(V(t.currentTarget), null, "ui-state-focus")
                        },
                        focusout: function(t) {
                            this._removeClass(V(t.currentTarget), null, "ui-state-focus")
                        }
                    })
                },
                _trigger: function(t, e, i) {
                    var s, n, o = this.options[t];
                    if (i = i || {}, (e = V.Event(e)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), e.target = this.element[0], n = e.originalEvent)
                        for (s in n) s in e || (e[s] = n[s]);
                    return this.element.trigger(e, i), !("function" == typeof o && !1 === o.apply(this.element[0], [e].concat(i)) || e.isDefaultPrevented())
                }
            }, V.each({
                show: "fadeIn",
                hide: "fadeOut"
            }, function(o, a) {
                V.Widget.prototype["_" + o] = function(e, t, i) {
                    var s, n = (t = "string" == typeof t ? {
                        effect: t
                    } : t) ? !0 !== t && "number" != typeof t && t.effect || a : o;
                    "number" == typeof(t = t || {}) ? t = {
                        duration: t
                    }: !0 === t && (t = {}), s = !V.isEmptyObject(t), t.complete = i, t.delay && e.delay(t.delay), s && V.effects && V.effects.effect[n] ? e[o](t) : n !== o && e[n] ? e[n](t.duration, t.easing, i) : e.queue(function(t) {
                        V(this)[o](), i && i.call(e[0]), t()
                    })
                }
            });
            var s, x, k, o, l, h, c, u, C;
            V.widget;

            function D(t, e, i) {
                return [parseFloat(t[0]) * (u.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (u.test(t[1]) ? i / 100 : 1)]
            }

            function I(t, e) {
                return parseInt(V.css(t, e), 10) || 0
            }

            function T(t) {
                return null != t && t === t.window
            }
            x = Math.max, k = Math.abs, o = /left|center|right/, l = /top|center|bottom/, h = /[\+\-]\d+(\.[\d]+)?%?/, c = /^\w+/, u = /%$/, C = V.fn.position, V.position = {
                scrollbarWidth: function() {
                    if (void 0 !== s) return s;
                    var t, e = V("<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'></div></div>"),
                        i = e.children()[0];
                    return V("body").append(e), t = i.offsetWidth, e.css("overflow", "scroll"), t === (i = i.offsetWidth) && (i = e[0].clientWidth), e.remove(), s = t - i
                },
                getScrollInfo: function(t) {
                    var e = t.isWindow || t.isDocument ? "" : t.element.css("overflow-x"),
                        i = t.isWindow || t.isDocument ? "" : t.element.css("overflow-y"),
                        e = "scroll" === e || "auto" === e && t.width < t.element[0].scrollWidth;
                    return {
                        width: "scroll" === i || "auto" === i && t.height < t.element[0].scrollHeight ? V.position.scrollbarWidth() : 0,
                        height: e ? V.position.scrollbarWidth() : 0
                    }
                },
                getWithinInfo: function(t) {
                    var e = V(t || window),
                        i = T(e[0]),
                        s = !!e[0] && 9 === e[0].nodeType;
                    return {
                        element: e,
                        isWindow: i,
                        isDocument: s,
                        offset: !i && !s ? V(t).offset() : {
                            left: 0,
                            top: 0
                        },
                        scrollLeft: e.scrollLeft(),
                        scrollTop: e.scrollTop(),
                        width: e.outerWidth(),
                        height: e.outerHeight()
                    }
                }
            }, V.fn.position = function(u) {
                if (!u || !u.of) return C.apply(this, arguments);
                var d, p, f, g, m, t, _ = "string" == typeof(u = V.extend({}, u)).of ? V(document).find(u.of) : V(u.of),
                    v = V.position.getWithinInfo(u.within),
                    b = V.position.getScrollInfo(v),
                    y = (u.collision || "flip").split(" "),
                    w = {},
                    e = 9 === (t = (e = _)[0]).nodeType ? {
                        width: e.width(),
                        height: e.height(),
                        offset: {
                            top: 0,
                            left: 0
                        }
                    } : T(t) ? {
                        width: e.width(),
                        height: e.height(),
                        offset: {
                            top: e.scrollTop(),
                            left: e.scrollLeft()
                        }
                    } : t.preventDefault ? {
                        width: 0,
                        height: 0,
                        offset: {
                            top: t.pageY,
                            left: t.pageX
                        }
                    } : {
                        width: e.outerWidth(),
                        height: e.outerHeight(),
                        offset: e.offset()
                    };
                return _[0].preventDefault && (u.at = "left top"), p = e.width, f = e.height, m = V.extend({}, g = e.offset), V.each(["my", "at"], function() {
                    var t, e, i = (u[this] || "").split(" ");
                    (i = 1 === i.length ? o.test(i[0]) ? i.concat(["center"]) : l.test(i[0]) ? ["center"].concat(i) : ["center", "center"] : i)[0] = o.test(i[0]) ? i[0] : "center", i[1] = l.test(i[1]) ? i[1] : "center", t = h.exec(i[0]), e = h.exec(i[1]), w[this] = [t ? t[0] : 0, e ? e[0] : 0], u[this] = [c.exec(i[0])[0], c.exec(i[1])[0]]
                }), 1 === y.length && (y[1] = y[0]), "right" === u.at[0] ? m.left += p : "center" === u.at[0] && (m.left += p / 2), "bottom" === u.at[1] ? m.top += f : "center" === u.at[1] && (m.top += f / 2), d = D(w.at, p, f), m.left += d[0], m.top += d[1], this.each(function() {
                    var i, t, a = V(this),
                        r = a.outerWidth(),
                        l = a.outerHeight(),
                        e = I(this, "marginLeft"),
                        s = I(this, "marginTop"),
                        n = r + e + I(this, "marginRight") + b.width,
                        o = l + s + I(this, "marginBottom") + b.height,
                        h = V.extend({}, m),
                        c = D(w.my, a.outerWidth(), a.outerHeight());
                    "right" === u.my[0] ? h.left -= r : "center" === u.my[0] && (h.left -= r / 2), "bottom" === u.my[1] ? h.top -= l : "center" === u.my[1] && (h.top -= l / 2), h.left += c[0], h.top += c[1], i = {
                        marginLeft: e,
                        marginTop: s
                    }, V.each(["left", "top"], function(t, e) {
                        V.ui.position[y[t]] && V.ui.position[y[t]][e](h, {
                            targetWidth: p,
                            targetHeight: f,
                            elemWidth: r,
                            elemHeight: l,
                            collisionPosition: i,
                            collisionWidth: n,
                            collisionHeight: o,
                            offset: [d[0] + c[0], d[1] + c[1]],
                            my: u.my,
                            at: u.at,
                            within: v,
                            elem: a
                        })
                    }), u.using && (t = function(t) {
                        var e = g.left - h.left,
                            i = e + p - r,
                            s = g.top - h.top,
                            n = s + f - l,
                            o = {
                                target: {
                                    element: _,
                                    left: g.left,
                                    top: g.top,
                                    width: p,
                                    height: f
                                },
                                element: {
                                    element: a,
                                    left: h.left,
                                    top: h.top,
                                    width: r,
                                    height: l
                                },
                                horizontal: i < 0 ? "left" : 0 < e ? "right" : "center",
                                vertical: n < 0 ? "top" : 0 < s ? "bottom" : "middle"
                            };
                        p < r && k(e + i) < p && (o.horizontal = "center"), f < l && k(s + n) < f && (o.vertical = "middle"), x(k(e), k(i)) > x(k(s), k(n)) ? o.important = "horizontal" : o.important = "vertical", u.using.call(this, t, o)
                    }), a.offset(V.extend(h, {
                        using: t
                    }))
                })
            }, V.ui.position = {
                fit: {
                    left: function(t, e) {
                        var i = e.within,
                            s = i.isWindow ? i.scrollLeft : i.offset.left,
                            n = i.width,
                            o = t.left - e.collisionPosition.marginLeft,
                            a = s - o,
                            r = o + e.collisionWidth - n - s;
                        e.collisionWidth > n ? 0 < a && r <= 0 ? (i = t.left + a + e.collisionWidth - n - s, t.left += a - i) : t.left = !(0 < r && a <= 0) && r < a ? s + n - e.collisionWidth : s : 0 < a ? t.left += a : 0 < r ? t.left -= r : t.left = x(t.left - o, t.left)
                    },
                    top: function(t, e) {
                        var i = e.within,
                            s = i.isWindow ? i.scrollTop : i.offset.top,
                            n = e.within.height,
                            o = t.top - e.collisionPosition.marginTop,
                            a = s - o,
                            r = o + e.collisionHeight - n - s;
                        e.collisionHeight > n ? 0 < a && r <= 0 ? (i = t.top + a + e.collisionHeight - n - s, t.top += a - i) : t.top = !(0 < r && a <= 0) && r < a ? s + n - e.collisionHeight : s : 0 < a ? t.top += a : 0 < r ? t.top -= r : t.top = x(t.top - o, t.top)
                    }
                },
                flip: {
                    left: function(t, e) {
                        var i = e.within,
                            s = i.offset.left + i.scrollLeft,
                            n = i.width,
                            o = i.isWindow ? i.scrollLeft : i.offset.left,
                            a = t.left - e.collisionPosition.marginLeft,
                            r = a - o,
                            l = a + e.collisionWidth - n - o,
                            h = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
                            i = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
                            a = -2 * e.offset[0];
                        r < 0 ? ((s = t.left + h + i + a + e.collisionWidth - n - s) < 0 || s < k(r)) && (t.left += h + i + a) : 0 < l && (0 < (o = t.left - e.collisionPosition.marginLeft + h + i + a - o) || k(o) < l) && (t.left += h + i + a)
                    },
                    top: function(t, e) {
                        var i = e.within,
                            s = i.offset.top + i.scrollTop,
                            n = i.height,
                            o = i.isWindow ? i.scrollTop : i.offset.top,
                            a = t.top - e.collisionPosition.marginTop,
                            r = a - o,
                            l = a + e.collisionHeight - n - o,
                            h = "top" === e.my[1] ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
                            i = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
                            a = -2 * e.offset[1];
                        r < 0 ? ((s = t.top + h + i + a + e.collisionHeight - n - s) < 0 || s < k(r)) && (t.top += h + i + a) : 0 < l && (0 < (o = t.top - e.collisionPosition.marginTop + h + i + a - o) || k(o) < l) && (t.top += h + i + a)
                    }
                },
                flipfit: {
                    left: function() {
                        V.ui.position.flip.left.apply(this, arguments), V.ui.position.fit.left.apply(this, arguments)
                    },
                    top: function() {
                        V.ui.position.flip.top.apply(this, arguments), V.ui.position.fit.top.apply(this, arguments)
                    }
                }
            };
            V.ui.position, V.extend(V.expr.pseudos, {
                data: V.expr.createPseudo ? V.expr.createPseudo(function(e) {
                    return function(t) {
                        return !!V.data(t, e)
                    }
                }) : function(t, e, i) {
                    return !!V.data(t, i[3])
                }
            }), V.fn.extend({
                disableSelection: (t = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown", function() {
                    return this.on(t + ".ui-disableSelection", function(t) {
                        t.preventDefault()
                    })
                }),
                enableSelection: function() {
                    return this.off(".ui-disableSelection")
                }
            });
            var t, d = V,
                p = {},
                e = p.toString,
                f = /^([\-+])=\s*(\d+\.?\d*)/,
                g = [{
                    re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                    parse: function(t) {
                        return [t[1], t[2], t[3], t[4]]
                    }
                }, {
                    re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                    parse: function(t) {
                        return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]]
                    }
                }, {
                    re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,
                    parse: function(t) {
                        return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16), t[4] ? (parseInt(t[4], 16) / 255).toFixed(2) : 1]
                    }
                }, {
                    re: /#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,
                    parse: function(t) {
                        return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16), t[4] ? (parseInt(t[4] + t[4], 16) / 255).toFixed(2) : 1]
                    }
                }, {
                    re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                    space: "hsla",
                    parse: function(t) {
                        return [t[1], t[2] / 100, t[3] / 100, t[4]]
                    }
                }],
                m = d.Color = function(t, e, i, s) {
                    return new d.Color.fn.parse(t, e, i, s)
                },
                _ = {
                    rgba: {
                        props: {
                            red: {
                                idx: 0,
                                type: "byte"
                            },
                            green: {
                                idx: 1,
                                type: "byte"
                            },
                            blue: {
                                idx: 2,
                                type: "byte"
                            }
                        }
                    },
                    hsla: {
                        props: {
                            hue: {
                                idx: 0,
                                type: "degrees"
                            },
                            saturation: {
                                idx: 1,
                                type: "percent"
                            },
                            lightness: {
                                idx: 2,
                                type: "percent"
                            }
                        }
                    }
                },
                v = {
                    byte: {
                        floor: !0,
                        max: 255
                    },
                    percent: {
                        max: 1
                    },
                    degrees: {
                        mod: 360,
                        floor: !0
                    }
                },
                b = m.support = {},
                y = d("<p>")[0],
                w = d.each;

            function P(t) {
                return null == t ? t + "" : "object" == typeof t ? p[e.call(t)] || "object" : typeof t
            }

            function M(t, e, i) {
                var s = v[e.type] || {};
                return null == t ? i || !e.def ? null : e.def : (t = s.floor ? ~~t : parseFloat(t), isNaN(t) ? e.def : s.mod ? (t + s.mod) % s.mod : Math.min(s.max, Math.max(0, t)))
            }

            function S(s) {
                var n = m(),
                    o = n._rgba = [];
                return s = s.toLowerCase(), w(g, function(t, e) {
                    var i = e.re.exec(s),
                        i = i && e.parse(i),
                        e = e.space || "rgba";
                    if (i) return i = n[e](i), n[_[e].cache] = i[_[e].cache], o = n._rgba = i._rgba, !1
                }), o.length ? ("0,0,0,0" === o.join() && d.extend(o, B.transparent), n) : B[s]
            }

            function H(t, e, i) {
                return 6 * (i = (i + 1) % 1) < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
            }
            y.style.cssText = "background-color:rgba(1,1,1,.5)", b.rgba = -1 < y.style.backgroundColor.indexOf("rgba"), w(_, function(t, e) {
                e.cache = "_" + t, e.props.alpha = {
                    idx: 3,
                    type: "percent",
                    def: 1
                }
            }), d.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(t, e) {
                p["[object " + e + "]"] = e.toLowerCase()
            }), (m.fn = d.extend(m.prototype, {
                parse: function(n, t, e, i) {
                    if (void 0 === n) return this._rgba = [null, null, null, null], this;
                    (n.jquery || n.nodeType) && (n = d(n).css(t), t = void 0);
                    var o = this,
                        s = P(n),
                        a = this._rgba = [];
                    return void 0 !== t && (n = [n, t, e, i], s = "array"), "string" === s ? this.parse(S(n) || B._default) : "array" === s ? (w(_.rgba.props, function(t, e) {
                        a[e.idx] = M(n[e.idx], e)
                    }), this) : "object" === s ? (w(_, n instanceof m ? function(t, e) {
                        n[e.cache] && (o[e.cache] = n[e.cache].slice())
                    } : function(t, i) {
                        var s = i.cache;
                        w(i.props, function(t, e) {
                            if (!o[s] && i.to) {
                                if ("alpha" === t || null == n[t]) return;
                                o[s] = i.to(o._rgba)
                            }
                            o[s][e.idx] = M(n[t], e, !0)
                        }), o[s] && d.inArray(null, o[s].slice(0, 3)) < 0 && (null == o[s][3] && (o[s][3] = 1), i.from && (o._rgba = i.from(o[s])))
                    }), this) : void 0
                },
                is: function(t) {
                    var n = m(t),
                        o = !0,
                        a = this;
                    return w(_, function(t, e) {
                        var i, s = n[e.cache];
                        return s && (i = a[e.cache] || e.to && e.to(a._rgba) || [], w(e.props, function(t, e) {
                            if (null != s[e.idx]) return o = s[e.idx] === i[e.idx]
                        })), o
                    }), o
                },
                _space: function() {
                    var i = [],
                        s = this;
                    return w(_, function(t, e) {
                        s[e.cache] && i.push(t)
                    }), i.pop()
                },
                transition: function(t, a) {
                    var e = (h = m(t))._space(),
                        i = _[e],
                        t = 0 === this.alpha() ? m("transparent") : this,
                        r = t[i.cache] || i.to(t._rgba),
                        l = r.slice(),
                        h = h[i.cache];
                    return w(i.props, function(t, e) {
                        var i = e.idx,
                            s = r[i],
                            n = h[i],
                            o = v[e.type] || {};
                        null !== n && (null === s ? l[i] = n : (o.mod && (n - s > o.mod / 2 ? s += o.mod : s - n > o.mod / 2 && (s -= o.mod)), l[i] = M((n - s) * a + s, e)))
                    }), this[e](l)
                },
                blend: function(t) {
                    if (1 === this._rgba[3]) return this;
                    var e = this._rgba.slice(),
                        i = e.pop(),
                        s = m(t)._rgba;
                    return m(d.map(e, function(t, e) {
                        return (1 - i) * s[e] + i * t
                    }))
                },
                toRgbaString: function() {
                    var t = "rgba(",
                        e = d.map(this._rgba, function(t, e) {
                            return null != t ? t : 2 < e ? 1 : 0
                        });
                    return 1 === e[3] && (e.pop(), t = "rgb("), t + e.join() + ")"
                },
                toHslaString: function() {
                    var t = "hsla(",
                        e = d.map(this.hsla(), function(t, e) {
                            return null == t && (t = 2 < e ? 1 : 0), t = e && e < 3 ? Math.round(100 * t) + "%" : t
                        });
                    return 1 === e[3] && (e.pop(), t = "hsl("), t + e.join() + ")"
                },
                toHexString: function(t) {
                    var e = this._rgba.slice(),
                        i = e.pop();
                    return t && e.push(~~(255 * i)), "#" + d.map(e, function(t) {
                        return 1 === (t = (t || 0).toString(16)).length ? "0" + t : t
                    }).join("")
                },
                toString: function() {
                    return 0 === this._rgba[3] ? "transparent" : this.toRgbaString()
                }
            })).parse.prototype = m.fn, _.hsla.to = function(t) {
                if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
                var e = t[0] / 255,
                    i = t[1] / 255,
                    s = t[2] / 255,
                    n = t[3],
                    o = Math.max(e, i, s),
                    a = Math.min(e, i, s),
                    r = o - a,
                    l = o + a,
                    t = .5 * l,
                    i = a === o ? 0 : e === o ? 60 * (i - s) / r + 360 : i === o ? 60 * (s - e) / r + 120 : 60 * (e - i) / r + 240,
                    l = 0 == r ? 0 : t <= .5 ? r / l : r / (2 - l);
                return [Math.round(i) % 360, l, t, null == n ? 1 : n]
            }, _.hsla.from = function(t) {
                if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
                var e = t[0] / 360,
                    i = t[1],
                    s = t[2],
                    t = t[3],
                    i = s <= .5 ? s * (1 + i) : s + i - s * i,
                    s = 2 * s - i;
                return [Math.round(255 * H(s, i, e + 1 / 3)), Math.round(255 * H(s, i, e)), Math.round(255 * H(s, i, e - 1 / 3)), t]
            }, w(_, function(l, t) {
                var e = t.props,
                    o = t.cache,
                    a = t.to,
                    r = t.from;
                m.fn[l] = function(t) {
                    if (a && !this[o] && (this[o] = a(this._rgba)), void 0 === t) return this[o].slice();
                    var i = P(t),
                        s = "array" === i || "object" === i ? t : arguments,
                        n = this[o].slice();
                    return w(e, function(t, e) {
                        t = s["object" === i ? t : e.idx];
                        null == t && (t = n[e.idx]), n[e.idx] = M(t, e)
                    }), r ? ((t = m(r(n)))[o] = n, t) : m(n)
                }, w(e, function(a, r) {
                    m.fn[a] || (m.fn[a] = function(t) {
                        var e, i = P(t),
                            s = "alpha" === a ? this._hsla ? "hsla" : "rgba" : l,
                            n = this[s](),
                            o = n[r.idx];
                        return "undefined" === i ? o : ("function" === i && (i = P(t = t.call(this, o))), null == t && r.empty ? this : ("string" === i && (e = f.exec(t)) && (t = o + parseFloat(e[2]) * ("+" === e[1] ? 1 : -1)), n[r.idx] = t, this[s](n)))
                    })
                })
            }), (m.hook = function(t) {
                t = t.split(" ");
                w(t, function(t, o) {
                    d.cssHooks[o] = {
                        set: function(t, e) {
                            var i, s, n = "";
                            if ("transparent" !== e && ("string" !== P(e) || (i = S(e)))) {
                                if (e = m(i || e), !b.rgba && 1 !== e._rgba[3]) {
                                    for (s = "backgroundColor" === o ? t.parentNode : t;
                                        ("" === n || "transparent" === n) && s && s.style;) try {
                                        n = d.css(s, "backgroundColor"), s = s.parentNode
                                    } catch (t) {}
                                    e = e.blend(n && "transparent" !== n ? n : "_default")
                                }
                                e = e.toRgbaString()
                            }
                            try {
                                t.style[o] = e
                            } catch (t) {}
                        }
                    }, d.fx.step[o] = function(t) {
                        t.colorInit || (t.start = m(t.elem, o), t.end = m(t.end), t.colorInit = !0), d.cssHooks[o].set(t.elem, t.start.transition(t.end, t.pos))
                    }
                })
            })("backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor"), d.cssHooks.borderColor = {
                expand: function(i) {
                    var s = {};
                    return w(["Top", "Right", "Bottom", "Left"], function(t, e) {
                        s["border" + e + "Color"] = i
                    }), s
                }
            };
            var z, A, O, N, E, W, F, L, R, Y, B = d.Color.names = {
                    aqua: "#00ffff",
                    black: "#000000",
                    blue: "#0000ff",
                    fuchsia: "#ff00ff",
                    gray: "#808080",
                    green: "#008000",
                    lime: "#00ff00",
                    maroon: "#800000",
                    navy: "#000080",
                    olive: "#808000",
                    purple: "#800080",
                    red: "#ff0000",
                    silver: "#c0c0c0",
                    teal: "#008080",
                    white: "#ffffff",
                    yellow: "#ffff00",
                    transparent: [null, null, null, 0],
                    _default: "#ffffff"
                },
                j = "ui-effects-",
                q = "ui-effects-style",
                K = "ui-effects-animated";

            function U(t) {
                var e, i, s = t.ownerDocument.defaultView ? t.ownerDocument.defaultView.getComputedStyle(t, null) : t.currentStyle,
                    n = {};
                if (s && s.length && s[0] && s[s[0]])
                    for (i = s.length; i--;) "string" == typeof s[e = s[i]] && (n[e.replace(/-([\da-z])/gi, function(t, e) {
                        return e.toUpperCase()
                    })] = s[e]);
                else
                    for (e in s) "string" == typeof s[e] && (n[e] = s[e]);
                return n
            }

            function X(t, e, i, s) {
                return t = {
                    effect: t = V.isPlainObject(t) ? (e = t).effect : t
                }, "function" == typeof(e = null == e ? {} : e) && (s = e, i = null, e = {}), "number" != typeof e && !V.fx.speeds[e] || (s = i, i = e, e = {}), "function" == typeof i && (s = i, i = null), e && V.extend(t, e), i = i || e.duration, t.duration = V.fx.off ? 0 : "number" == typeof i ? i : i in V.fx.speeds ? V.fx.speeds[i] : V.fx.speeds._default, t.complete = s || e.complete, t
            }

            function $(t) {
                return !t || "number" == typeof t || V.fx.speeds[t] || ("string" == typeof t && !V.effects.effect[t] || ("function" == typeof t || "object" == typeof t && !t.effect))
            }

            function G(t, e) {
                var i = e.outerWidth(),
                    e = e.outerHeight(),
                    t = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/.exec(t) || ["", 0, i, e, 0];
                return {
                    top: parseFloat(t[1]) || 0,
                    right: "auto" === t[2] ? i : parseFloat(t[2]),
                    bottom: "auto" === t[3] ? e : parseFloat(t[3]),
                    left: parseFloat(t[4]) || 0
                }
            }
            V.effects = {
                effect: {}
            }, N = ["add", "remove", "toggle"], E = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1
            }, V.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function(t, e) {
                V.fx.step[e] = function(t) {
                    ("none" !== t.end && !t.setAttr || 1 === t.pos && !t.setAttr) && (d.style(t.elem, e, t.end), t.setAttr = !0)
                }
            }), V.fn.addBack || (V.fn.addBack = function(t) {
                return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
            }), V.effects.animateClass = function(n, t, e, i) {
                var o = V.speed(t, e, i);
                return this.queue(function() {
                    var i = V(this),
                        t = i.attr("class") || "",
                        e = (e = o.children ? i.find("*").addBack() : i).map(function() {
                            return {
                                el: V(this),
                                start: U(this)
                            }
                        }),
                        s = function() {
                            V.each(N, function(t, e) {
                                n[e] && i[e + "Class"](n[e])
                            })
                        };
                    s(), e = e.map(function() {
                        return this.end = U(this.el[0]), this.diff = function(t, e) {
                            var i, s, n = {};
                            for (i in e) s = e[i], t[i] !== s && (E[i] || !V.fx.step[i] && isNaN(parseFloat(s)) || (n[i] = s));
                            return n
                        }(this.start, this.end), this
                    }), i.attr("class", t), e = e.map(function() {
                        var t = this,
                            e = V.Deferred(),
                            i = V.extend({}, o, {
                                queue: !1,
                                complete: function() {
                                    e.resolve(t)
                                }
                            });
                        return this.el.animate(this.diff, i), e.promise()
                    }), V.when.apply(V, e.get()).done(function() {
                        s(), V.each(arguments, function() {
                            var e = this.el;
                            V.each(this.diff, function(t) {
                                e.css(t, "")
                            })
                        }), o.complete.call(i[0])
                    })
                })
            }, V.fn.extend({
                addClass: (O = V.fn.addClass, function(t, e, i, s) {
                    return e ? V.effects.animateClass.call(this, {
                        add: t
                    }, e, i, s) : O.apply(this, arguments)
                }),
                removeClass: (A = V.fn.removeClass, function(t, e, i, s) {
                    return 1 < arguments.length ? V.effects.animateClass.call(this, {
                        remove: t
                    }, e, i, s) : A.apply(this, arguments)
                }),
                toggleClass: (z = V.fn.toggleClass, function(t, e, i, s, n) {
                    return "boolean" == typeof e || void 0 === e ? i ? V.effects.animateClass.call(this, e ? {
                        add: t
                    } : {
                        remove: t
                    }, i, s, n) : z.apply(this, arguments) : V.effects.animateClass.call(this, {
                        toggle: t
                    }, e, i, s)
                }),
                switchClass: function(t, e, i, s, n) {
                    return V.effects.animateClass.call(this, {
                        add: e,
                        remove: t
                    }, i, s, n)
                }
            }), V.expr && V.expr.pseudos && V.expr.pseudos.animated && (V.expr.pseudos.animated = (W = V.expr.pseudos.animated, function(t) {
                return !!V(t).data(K) || W(t)
            })), !1 !== V.uiBackCompat && V.extend(V.effects, {
                save: function(t, e) {
                    for (var i = 0, s = e.length; i < s; i++) null !== e[i] && t.data(j + e[i], t[0].style[e[i]])
                },
                restore: function(t, e) {
                    for (var i, s = 0, n = e.length; s < n; s++) null !== e[s] && (i = t.data(j + e[s]), t.css(e[s], i))
                },
                setMode: function(t, e) {
                    return e = "toggle" === e ? t.is(":hidden") ? "show" : "hide" : e
                },
                createWrapper: function(i) {
                    if (i.parent().is(".ui-effects-wrapper")) return i.parent();
                    var s = {
                            width: i.outerWidth(!0),
                            height: i.outerHeight(!0),
                            float: i.css("float")
                        },
                        t = V("<div></div>").addClass("ui-effects-wrapper").css({
                            fontSize: "100%",
                            background: "transparent",
                            border: "none",
                            margin: 0,
                            padding: 0
                        }),
                        e = {
                            width: i.width(),
                            height: i.height()
                        },
                        n = document.activeElement;
                    try {
                        n.id
                    } catch (t) {
                        n = document.body
                    }
                    return i.wrap(t), i[0] !== n && !V.contains(i[0], n) || V(n).trigger("focus"), t = i.parent(), "static" === i.css("position") ? (t.css({
                        position: "relative"
                    }), i.css({
                        position: "relative"
                    })) : (V.extend(s, {
                        position: i.css("position"),
                        zIndex: i.css("z-index")
                    }), V.each(["top", "left", "bottom", "right"], function(t, e) {
                        s[e] = i.css(e), isNaN(parseInt(s[e], 10)) && (s[e] = "auto")
                    }), i.css({
                        position: "relative",
                        top: 0,
                        left: 0,
                        right: "auto",
                        bottom: "auto"
                    })), i.css(e), t.css(s).show()
                },
                removeWrapper: function(t) {
                    var e = document.activeElement;
                    return t.parent().is(".ui-effects-wrapper") && (t.parent().replaceWith(t), t[0] !== e && !V.contains(t[0], e) || V(e).trigger("focus")), t
                }
            }), V.extend(V.effects, {
                version: "1.13.2",
                define: function(t, e, i) {
                    return i || (i = e, e = "effect"), V.effects.effect[t] = i, V.effects.effect[t].mode = e, i
                },
                scaledDimensions: function(t, e, i) {
                    if (0 === e) return {
                        height: 0,
                        width: 0,
                        outerHeight: 0,
                        outerWidth: 0
                    };
                    var s = "horizontal" !== i ? (e || 100) / 100 : 1,
                        e = "vertical" !== i ? (e || 100) / 100 : 1;
                    return {
                        height: t.height() * e,
                        width: t.width() * s,
                        outerHeight: t.outerHeight() * e,
                        outerWidth: t.outerWidth() * s
                    }
                },
                clipToBox: function(t) {
                    return {
                        width: t.clip.right - t.clip.left,
                        height: t.clip.bottom - t.clip.top,
                        left: t.clip.left,
                        top: t.clip.top
                    }
                },
                unshift: function(t, e, i) {
                    var s = t.queue();
                    1 < e && s.splice.apply(s, [1, 0].concat(s.splice(e, i))), t.dequeue()
                },
                saveStyle: function(t) {
                    t.data(q, t[0].style.cssText)
                },
                restoreStyle: function(t) {
                    t[0].style.cssText = t.data(q) || "", t.removeData(q)
                },
                mode: function(t, e) {
                    t = t.is(":hidden");
                    return "toggle" === e && (e = t ? "show" : "hide"), e = (t ? "hide" === e : "show" === e) ? "none" : e
                },
                getBaseline: function(t, e) {
                    var i, s;
                    switch (t[0]) {
                        case "top":
                            i = 0;
                            break;
                        case "middle":
                            i = .5;
                            break;
                        case "bottom":
                            i = 1;
                            break;
                        default:
                            i = t[0] / e.height
                    }
                    switch (t[1]) {
                        case "left":
                            s = 0;
                            break;
                        case "center":
                            s = .5;
                            break;
                        case "right":
                            s = 1;
                            break;
                        default:
                            s = t[1] / e.width
                    }
                    return {
                        x: s,
                        y: i
                    }
                },
                createPlaceholder: function(t) {
                    var e, i = t.css("position"),
                        s = t.position();
                    return t.css({
                        marginTop: t.css("marginTop"),
                        marginBottom: t.css("marginBottom"),
                        marginLeft: t.css("marginLeft"),
                        marginRight: t.css("marginRight")
                    }).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()), /^(static|relative)/.test(i) && (i = "absolute", e = V("<" + t[0].nodeName + ">").insertAfter(t).css({
                        display: /^(inline|ruby)/.test(t.css("display")) ? "inline-block" : "block",
                        visibility: "hidden",
                        marginTop: t.css("marginTop"),
                        marginBottom: t.css("marginBottom"),
                        marginLeft: t.css("marginLeft"),
                        marginRight: t.css("marginRight"),
                        float: t.css("float")
                    }).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).addClass("ui-effects-placeholder"), t.data(j + "placeholder", e)), t.css({
                        position: i,
                        left: s.left,
                        top: s.top
                    }), e
                },
                removePlaceholder: function(t) {
                    var e = j + "placeholder",
                        i = t.data(e);
                    i && (i.remove(), t.removeData(e))
                },
                cleanUp: function(t) {
                    V.effects.restoreStyle(t), V.effects.removePlaceholder(t)
                },
                setTransition: function(s, t, n, o) {
                    return o = o || {}, V.each(t, function(t, e) {
                        var i = s.cssUnit(e);
                        0 < i[0] && (o[e] = i[0] * n + i[1])
                    }), o
                }
            }), V.fn.extend({
                effect: function() {
                    function t(t) {
                        var e = V(this),
                            i = V.effects.mode(e, r) || o;
                        e.data(K, !0), l.push(i), o && ("show" === i || i === o && "hide" === i) && e.show(), o && "none" === i || V.effects.saveStyle(e), "function" == typeof t && t()
                    }
                    var s = X.apply(this, arguments),
                        n = V.effects.effect[s.effect],
                        o = n.mode,
                        e = s.queue,
                        i = e || "fx",
                        a = s.complete,
                        r = s.mode,
                        l = [];
                    return V.fx.off || !n ? r ? this[r](s.duration, a) : this.each(function() {
                        a && a.call(this)
                    }) : !1 === e ? this.each(t).each(h) : this.queue(i, t).queue(i, h);

                    function h(t) {
                        var e = V(this);

                        function i() {
                            "function" == typeof a && a.call(e[0]), "function" == typeof t && t()
                        }
                        s.mode = l.shift(), !1 === V.uiBackCompat || o ? "none" === s.mode ? (e[r](), i()) : n.call(e[0], s, function() {
                            e.removeData(K), V.effects.cleanUp(e), "hide" === s.mode && e.hide(), i()
                        }) : (e.is(":hidden") ? "hide" === r : "show" === r) ? (e[r](), i()) : n.call(e[0], s, i)
                    }
                },
                show: (R = V.fn.show, function(t) {
                    if ($(t)) return R.apply(this, arguments);
                    t = X.apply(this, arguments);
                    return t.mode = "show", this.effect.call(this, t)
                }),
                hide: (L = V.fn.hide, function(t) {
                    if ($(t)) return L.apply(this, arguments);
                    t = X.apply(this, arguments);
                    return t.mode = "hide", this.effect.call(this, t)
                }),
                toggle: (F = V.fn.toggle, function(t) {
                    if ($(t) || "boolean" == typeof t) return F.apply(this, arguments);
                    t = X.apply(this, arguments);
                    return t.mode = "toggle", this.effect.call(this, t)
                }),
                cssUnit: function(t) {
                    var i = this.css(t),
                        s = [];
                    return V.each(["em", "px", "%", "pt"], function(t, e) {
                        0 < i.indexOf(e) && (s = [parseFloat(i), e])
                    }), s
                },
                cssClip: function(t) {
                    return t ? this.css("clip", "rect(" + t.top + "px " + t.right + "px " + t.bottom + "px " + t.left + "px)") : G(this.css("clip"), this)
                },
                transfer: function(t, e) {
                    var i = V(this),
                        s = V(t.to),
                        n = "fixed" === s.css("position"),
                        o = V("body"),
                        a = n ? o.scrollTop() : 0,
                        r = n ? o.scrollLeft() : 0,
                        o = s.offset(),
                        o = {
                            top: o.top - a,
                            left: o.left - r,
                            height: s.innerHeight(),
                            width: s.innerWidth()
                        },
                        s = i.offset(),
                        l = V("<div class='ui-effects-transfer'></div>");
                    l.appendTo("body").addClass(t.className).css({
                        top: s.top - a,
                        left: s.left - r,
                        height: i.innerHeight(),
                        width: i.innerWidth(),
                        position: n ? "fixed" : "absolute"
                    }).animate(o, t.duration, t.easing, function() {
                        l.remove(), "function" == typeof e && e()
                    })
                }
            }), V.fx.step.clip = function(t) {
                t.clipInit || (t.start = V(t.elem).cssClip(), "string" == typeof t.end && (t.end = G(t.end, t.elem)), t.clipInit = !0), V(t.elem).cssClip({
                    top: t.pos * (t.end.top - t.start.top) + t.start.top,
                    right: t.pos * (t.end.right - t.start.right) + t.start.right,
                    bottom: t.pos * (t.end.bottom - t.start.bottom) + t.start.bottom,
                    left: t.pos * (t.end.left - t.start.left) + t.start.left
                })
            }, Y = {}, V.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(e, t) {
                Y[t] = function(t) {
                    return Math.pow(t, e + 2)
                }
            }), V.extend(Y, {
                Sine: function(t) {
                    return 1 - Math.cos(t * Math.PI / 2)
                },
                Circ: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Elastic: function(t) {
                    return 0 === t || 1 === t ? t : -Math.pow(2, 8 * (t - 1)) * Math.sin((80 * (t - 1) - 7.5) * Math.PI / 15)
                },
                Back: function(t) {
                    return t * t * (3 * t - 2)
                },
                Bounce: function(t) {
                    for (var e, i = 4; t < ((e = Math.pow(2, --i)) - 1) / 11;);
                    return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2)
                }
            }), V.each(Y, function(t, e) {
                V.easing["easeIn" + t] = e, V.easing["easeOut" + t] = function(t) {
                    return 1 - e(1 - t)
                }, V.easing["easeInOut" + t] = function(t) {
                    return t < .5 ? e(2 * t) / 2 : 1 - e(-2 * t + 2) / 2
                }
            });
            y = V.effects, V.effects.define("blind", "hide", function(t, e) {
                var i = {
                        up: ["bottom", "top"],
                        vertical: ["bottom", "top"],
                        down: ["top", "bottom"],
                        left: ["right", "left"],
                        horizontal: ["right", "left"],
                        right: ["left", "right"]
                    },
                    s = V(this),
                    n = t.direction || "up",
                    o = s.cssClip(),
                    a = {
                        clip: V.extend({}, o)
                    },
                    r = V.effects.createPlaceholder(s);
                a.clip[i[n][0]] = a.clip[i[n][1]], "show" === t.mode && (s.cssClip(a.clip), r && r.css(V.effects.clipToBox(a)), a.clip = o), r && r.animate(V.effects.clipToBox(a), t.duration, t.easing), s.animate(a, {
                    queue: !1,
                    duration: t.duration,
                    easing: t.easing,
                    complete: e
                })
            }), V.effects.define("bounce", function(t, e) {
                var i, s, n = V(this),
                    o = t.mode,
                    a = "hide" === o,
                    r = "show" === o,
                    l = t.direction || "up",
                    h = t.distance,
                    c = t.times || 5,
                    o = 2 * c + (r || a ? 1 : 0),
                    u = t.duration / o,
                    d = t.easing,
                    p = "up" === l || "down" === l ? "top" : "left",
                    f = "up" === l || "left" === l,
                    g = 0,
                    t = n.queue().length;
                for (V.effects.createPlaceholder(n), l = n.css(p), h = h || n["top" == p ? "outerHeight" : "outerWidth"]() / 3, r && ((s = {
                        opacity: 1
                    })[p] = l, n.css("opacity", 0).css(p, f ? 2 * -h : 2 * h).animate(s, u, d)), a && (h /= Math.pow(2, c - 1)), (s = {})[p] = l; g < c; g++)(i = {})[p] = (f ? "-=" : "+=") + h, n.animate(i, u, d).animate(s, u, d), h = a ? 2 * h : h / 2;
                a && ((i = {
                    opacity: 0
                })[p] = (f ? "-=" : "+=") + h, n.animate(i, u, d)), n.queue(e), V.effects.unshift(n, t, 1 + o)
            }), V.effects.define("clip", "hide", function(t, e) {
                var i = {},
                    s = V(this),
                    n = t.direction || "vertical",
                    o = "both" === n,
                    a = o || "horizontal" === n,
                    o = o || "vertical" === n,
                    n = s.cssClip();
                i.clip = {
                    top: o ? (n.bottom - n.top) / 2 : n.top,
                    right: a ? (n.right - n.left) / 2 : n.right,
                    bottom: o ? (n.bottom - n.top) / 2 : n.bottom,
                    left: a ? (n.right - n.left) / 2 : n.left
                }, V.effects.createPlaceholder(s), "show" === t.mode && (s.cssClip(i.clip), i.clip = n), s.animate(i, {
                    queue: !1,
                    duration: t.duration,
                    easing: t.easing,
                    complete: e
                })
            }), V.effects.define("drop", "hide", function(t, e) {
                var i = V(this),
                    s = "show" === t.mode,
                    n = t.direction || "left",
                    o = "up" === n || "down" === n ? "top" : "left",
                    a = "up" === n || "left" === n ? "-=" : "+=",
                    r = "+=" == a ? "-=" : "+=",
                    l = {
                        opacity: 0
                    };
                V.effects.createPlaceholder(i), n = t.distance || i["top" == o ? "outerHeight" : "outerWidth"](!0) / 2, l[o] = a + n, s && (i.css(l), l[o] = r + n, l.opacity = 1), i.animate(l, {
                    queue: !1,
                    duration: t.duration,
                    easing: t.easing,
                    complete: e
                })
            }), V.effects.define("explode", "hide", function(t, e) {
                var i, s, n, o, a, r, l = t.pieces ? Math.round(Math.sqrt(t.pieces)) : 3,
                    h = l,
                    c = V(this),
                    u = "show" === t.mode,
                    d = c.show().css("visibility", "hidden").offset(),
                    p = Math.ceil(c.outerWidth() / h),
                    f = Math.ceil(c.outerHeight() / l),
                    g = [];

                function m() {
                    g.push(this), g.length === l * h && (c.css({
                        visibility: "visible"
                    }), V(g).remove(), e())
                }
                for (i = 0; i < l; i++)
                    for (o = d.top + i * f, r = i - (l - 1) / 2, s = 0; s < h; s++) n = d.left + s * p, a = s - (h - 1) / 2, c.clone().appendTo("body").wrap("<div></div>").css({
                        position: "absolute",
                        visibility: "visible",
                        left: -s * p,
                        top: -i * f
                    }).parent().addClass("ui-effects-explode").css({
                        position: "absolute",
                        overflow: "hidden",
                        width: p,
                        height: f,
                        left: n + (u ? a * p : 0),
                        top: o + (u ? r * f : 0),
                        opacity: u ? 0 : 1
                    }).animate({
                        left: n + (u ? 0 : a * p),
                        top: o + (u ? 0 : r * f),
                        opacity: u ? 1 : 0
                    }, t.duration || 500, t.easing, m)
            }), V.effects.define("fade", "toggle", function(t, e) {
                var i = "show" === t.mode;
                V(this).css("opacity", i ? 0 : 1).animate({
                    opacity: i ? 1 : 0
                }, {
                    queue: !1,
                    duration: t.duration,
                    easing: t.easing,
                    complete: e
                })
            }), V.effects.define("fold", "hide", function(e, t) {
                var i = V(this),
                    s = e.mode,
                    n = "show" === s,
                    o = "hide" === s,
                    a = e.size || 15,
                    r = /([0-9]+)%/.exec(a),
                    l = !!e.horizFirst ? ["right", "bottom"] : ["bottom", "right"],
                    h = e.duration / 2,
                    c = V.effects.createPlaceholder(i),
                    u = i.cssClip(),
                    d = {
                        clip: V.extend({}, u)
                    },
                    p = {
                        clip: V.extend({}, u)
                    },
                    f = [u[l[0]], u[l[1]]],
                    s = i.queue().length;
                r && (a = parseInt(r[1], 10) / 100 * f[o ? 0 : 1]), d.clip[l[0]] = a, p.clip[l[0]] = a, p.clip[l[1]] = 0, n && (i.cssClip(p.clip), c && c.css(V.effects.clipToBox(p)), p.clip = u), i.queue(function(t) {
                    c && c.animate(V.effects.clipToBox(d), h, e.easing).animate(V.effects.clipToBox(p), h, e.easing), t()
                }).animate(d, h, e.easing).animate(p, h, e.easing).queue(t), V.effects.unshift(i, s, 4)
            }), V.effects.define("highlight", "show", function(t, e) {
                var i = V(this),
                    s = {
                        backgroundColor: i.css("backgroundColor")
                    };
                "hide" === t.mode && (s.opacity = 0), V.effects.saveStyle(i), i.css({
                    backgroundImage: "none",
                    backgroundColor: t.color || "#ffff99"
                }).animate(s, {
                    queue: !1,
                    duration: t.duration,
                    easing: t.easing,
                    complete: e
                })
            }), V.effects.define("size", function(s, e) {
                var n, i = V(this),
                    t = ["fontSize"],
                    o = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
                    a = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
                    r = s.mode,
                    l = "effect" !== r,
                    h = s.scale || "both",
                    c = s.origin || ["middle", "center"],
                    u = i.css("position"),
                    d = i.position(),
                    p = V.effects.scaledDimensions(i),
                    f = s.from || p,
                    g = s.to || V.effects.scaledDimensions(i, 0);
                V.effects.createPlaceholder(i), "show" === r && (r = f, f = g, g = r), n = {
                    from: {
                        y: f.height / p.height,
                        x: f.width / p.width
                    },
                    to: {
                        y: g.height / p.height,
                        x: g.width / p.width
                    }
                }, "box" !== h && "both" !== h || (n.from.y !== n.to.y && (f = V.effects.setTransition(i, o, n.from.y, f), g = V.effects.setTransition(i, o, n.to.y, g)), n.from.x !== n.to.x && (f = V.effects.setTransition(i, a, n.from.x, f), g = V.effects.setTransition(i, a, n.to.x, g))), "content" !== h && "both" !== h || n.from.y !== n.to.y && (f = V.effects.setTransition(i, t, n.from.y, f), g = V.effects.setTransition(i, t, n.to.y, g)), c && (c = V.effects.getBaseline(c, p), f.top = (p.outerHeight - f.outerHeight) * c.y + d.top, f.left = (p.outerWidth - f.outerWidth) * c.x + d.left, g.top = (p.outerHeight - g.outerHeight) * c.y + d.top, g.left = (p.outerWidth - g.outerWidth) * c.x + d.left), delete f.outerHeight, delete f.outerWidth, i.css(f), "content" !== h && "both" !== h || (o = o.concat(["marginTop", "marginBottom"]).concat(t), a = a.concat(["marginLeft", "marginRight"]), i.find("*[width]").each(function() {
                    var t = V(this),
                        e = V.effects.scaledDimensions(t),
                        i = {
                            height: e.height * n.from.y,
                            width: e.width * n.from.x,
                            outerHeight: e.outerHeight * n.from.y,
                            outerWidth: e.outerWidth * n.from.x
                        },
                        e = {
                            height: e.height * n.to.y,
                            width: e.width * n.to.x,
                            outerHeight: e.height * n.to.y,
                            outerWidth: e.width * n.to.x
                        };
                    n.from.y !== n.to.y && (i = V.effects.setTransition(t, o, n.from.y, i), e = V.effects.setTransition(t, o, n.to.y, e)), n.from.x !== n.to.x && (i = V.effects.setTransition(t, a, n.from.x, i), e = V.effects.setTransition(t, a, n.to.x, e)), l && V.effects.saveStyle(t), t.css(i), t.animate(e, s.duration, s.easing, function() {
                        l && V.effects.restoreStyle(t)
                    })
                })), i.animate(g, {
                    queue: !1,
                    duration: s.duration,
                    easing: s.easing,
                    complete: function() {
                        var t = i.offset();
                        0 === g.opacity && i.css("opacity", f.opacity), l || (i.css("position", "static" === u ? "relative" : u).offset(t), V.effects.saveStyle(i)), e()
                    }
                })
            }), V.effects.define("scale", function(t, e) {
                var i = V(this),
                    s = t.mode,
                    s = parseInt(t.percent, 10) || (0 === parseInt(t.percent, 10) || "effect" !== s ? 0 : 100),
                    s = V.extend(!0, {
                        from: V.effects.scaledDimensions(i),
                        to: V.effects.scaledDimensions(i, s, t.direction || "both"),
                        origin: t.origin || ["middle", "center"]
                    }, t);
                t.fade && (s.from.opacity = 1, s.to.opacity = 0), V.effects.effect.size.call(this, s, e)
            }), V.effects.define("puff", "hide", function(t, e) {
                t = V.extend(!0, {}, t, {
                    fade: !0,
                    percent: parseInt(t.percent, 10) || 150
                });
                V.effects.effect.scale.call(this, t, e)
            }), V.effects.define("pulsate", "show", function(t, e) {
                var i = V(this),
                    s = t.mode,
                    n = "show" === s,
                    o = 2 * (t.times || 5) + (n || "hide" === s ? 1 : 0),
                    a = t.duration / o,
                    r = 0,
                    l = 1,
                    s = i.queue().length;
                for (!n && i.is(":visible") || (i.css("opacity", 0).show(), r = 1); l < o; l++) i.animate({
                    opacity: r
                }, a, t.easing), r = 1 - r;
                i.animate({
                    opacity: r
                }, a, t.easing), i.queue(e), V.effects.unshift(i, s, 1 + o)
            }), V.effects.define("shake", function(t, e) {
                var i = 1,
                    s = V(this),
                    n = t.direction || "left",
                    o = t.distance || 20,
                    a = t.times || 3,
                    r = 2 * a + 1,
                    l = Math.round(t.duration / r),
                    h = "up" === n || "down" === n ? "top" : "left",
                    c = "up" === n || "left" === n,
                    u = {},
                    d = {},
                    p = {},
                    n = s.queue().length;
                for (V.effects.createPlaceholder(s), u[h] = (c ? "-=" : "+=") + o, d[h] = (c ? "+=" : "-=") + 2 * o, p[h] = (c ? "-=" : "+=") + 2 * o, s.animate(u, l, t.easing); i < a; i++) s.animate(d, l, t.easing).animate(p, l, t.easing);
                s.animate(d, l, t.easing).animate(u, l / 2, t.easing).queue(e), V.effects.unshift(s, n, 1 + r)
            }), V.effects.define("slide", "show", function(t, e) {
                var i, s, n = V(this),
                    o = {
                        up: ["bottom", "top"],
                        down: ["top", "bottom"],
                        left: ["right", "left"],
                        right: ["left", "right"]
                    },
                    a = t.mode,
                    r = t.direction || "left",
                    l = "up" === r || "down" === r ? "top" : "left",
                    h = "up" === r || "left" === r,
                    c = t.distance || n["top" == l ? "outerHeight" : "outerWidth"](!0),
                    u = {};
                V.effects.createPlaceholder(n), i = n.cssClip(), s = n.position()[l], u[l] = (h ? -1 : 1) * c + s, u.clip = n.cssClip(), u.clip[o[r][1]] = u.clip[o[r][0]], "show" === a && (n.cssClip(u.clip), n.css(l, u[l]), u.clip = i, u[l] = s), n.animate(u, {
                    queue: !1,
                    duration: t.duration,
                    easing: t.easing,
                    complete: e
                })
            }), y = !1 !== V.uiBackCompat ? V.effects.define("transfer", function(t, e) {
                V(this).transfer(t, e)
            }) : y;
            V.ui.focusable = function(t, e) {
                var i, s, n, o, a = t.nodeName.toLowerCase();
                return "area" === a ? (s = (i = t.parentNode).name, !(!t.href || !s || "map" !== i.nodeName.toLowerCase()) && (0 < (s = V("img[usemap='#" + s + "']")).length && s.is(":visible"))) : (/^(input|select|textarea|button|object)$/.test(a) ? (n = !t.disabled) && (o = V(t).closest("fieldset")[0]) && (n = !o.disabled) : n = "a" === a && t.href || e, n && V(t).is(":visible") && function(t) {
                    var e = t.css("visibility");
                    for (;
                        "inherit" === e;) t = t.parent(), e = t.css("visibility");
                    return "visible" === e
                }(V(t)))
            }, V.extend(V.expr.pseudos, {
                focusable: function(t) {
                    return V.ui.focusable(t, null != V.attr(t, "tabindex"))
                }
            });
            var Q, J;
            V.ui.focusable, V.fn._form = function() {
                return "string" == typeof this[0].form ? this.closest("form") : V(this[0].form)
            }, V.ui.formResetMixin = {
                _formResetHandler: function() {
                    var e = V(this);
                    setTimeout(function() {
                        var t = e.data("ui-form-reset-instances");
                        V.each(t, function() {
                            this.refresh()
                        })
                    })
                },
                _bindFormResetHandler: function() {
                    var t;
                    this.form = this.element._form(), this.form.length && ((t = this.form.data("ui-form-reset-instances") || []).length || this.form.on("reset.ui-form-reset", this._formResetHandler), t.push(this), this.form.data("ui-form-reset-instances", t))
                },
                _unbindFormResetHandler: function() {
                    var t;
                    this.form.length && ((t = this.form.data("ui-form-reset-instances")).splice(V.inArray(this, t), 1), t.length ? this.form.data("ui-form-reset-instances", t) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"))
                }
            };
            V.expr.pseudos || (V.expr.pseudos = V.expr[":"]), V.uniqueSort || (V.uniqueSort = V.unique), V.escapeSelector || (Q = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, J = function(t, e) {
                return e ? "\0" === t ? "" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
            }, V.escapeSelector = function(t) {
                return (t + "").replace(Q, J)
            }), V.fn.even && V.fn.odd || V.fn.extend({
                even: function() {
                    return this.filter(function(t) {
                        return t % 2 == 0
                    })
                },
                odd: function() {
                    return this.filter(function(t) {
                        return t % 2 == 1
                    })
                }
            });
            var Z;
            V.ui.keyCode = {
                BACKSPACE: 8,
                COMMA: 188,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                LEFT: 37,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SPACE: 32,
                TAB: 9,
                UP: 38
            }, V.fn.labels = function() {
                var t, e, i;
                return this.length ? this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (e = this.eq(0).parents("label"), (t = this.attr("id")) && (i = (i = this.eq(0).parents().last()).add((i.length ? i : this).siblings()), t = "label[for='" + V.escapeSelector(t) + "']", e = e.add(i.find(t).addBack(t))), this.pushStack(e)) : this.pushStack([])
            }, V.fn.scrollParent = function(t) {
                var e = this.css("position"),
                    i = "absolute" === e,
                    s = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                    t = this.parents().filter(function() {
                        var t = V(this);
                        return (!i || "static" !== t.css("position")) && s.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"))
                    }).eq(0);
                return "fixed" !== e && t.length ? t : V(this[0].ownerDocument || document)
            }, V.extend(V.expr.pseudos, {
                tabbable: function(t) {
                    var e = V.attr(t, "tabindex"),
                        i = null != e;
                    return (!i || 0 <= e) && V.ui.focusable(t, i)
                }
            }), V.fn.extend({
                uniqueId: (Z = 0, function() {
                    return this.each(function() {
                        this.id || (this.id = "ui-id-" + ++Z)
                    })
                }),
                removeUniqueId: function() {
                    return this.each(function() {
                        /^ui-id-\d+$/.test(this.id) && V(this).removeAttr("id")
                    })
                }
            }), V.widget("ui.accordion", {
                version: "1.13.2",
                options: {
                    active: 0,
                    animate: {},
                    classes: {
                        "ui-accordion-header": "ui-corner-top",
                        "ui-accordion-header-collapsed": "ui-corner-all",
                        "ui-accordion-content": "ui-corner-bottom"
                    },
                    collapsible: !1,
                    event: "click",
                    header: function(t) {
                        return t.find("> li > :first-child").add(t.find("> :not(li)").even())
                    },
                    heightStyle: "auto",
                    icons: {
                        activeHeader: "ui-icon-triangle-1-s",
                        header: "ui-icon-triangle-1-e"
                    },
                    activate: null,
                    beforeActivate: null
                },
                hideProps: {
                    borderTopWidth: "hide",
                    borderBottomWidth: "hide",
                    paddingTop: "hide",
                    paddingBottom: "hide",
                    height: "hide"
                },
                showProps: {
                    borderTopWidth: "show",
                    borderBottomWidth: "show",
                    paddingTop: "show",
                    paddingBottom: "show",
                    height: "show"
                },
                _create: function() {
                    var t = this.options;
                    this.prevShow = this.prevHide = V(), this._addClass("ui-accordion", "ui-widget ui-helper-reset"), this.element.attr("role", "tablist"), t.collapsible || !1 !== t.active && null != t.active || (t.active = 0), this._processPanels(), t.active < 0 && (t.active += this.headers.length), this._refresh()
                },
                _getCreateEventData: function() {
                    return {
                        header: this.active,
                        panel: this.active.length ? this.active.next() : V()
                    }
                },
                _createIcons: function() {
                    var t, e = this.options.icons;
                    e && (t = V("<span>"), this._addClass(t, "ui-accordion-header-icon", "ui-icon " + e.header), t.prependTo(this.headers), t = this.active.children(".ui-accordion-header-icon"), this._removeClass(t, e.header)._addClass(t, null, e.activeHeader)._addClass(this.headers, "ui-accordion-icons"))
                },
                _destroyIcons: function() {
                    this._removeClass(this.headers, "ui-accordion-icons"), this.headers.children(".ui-accordion-header-icon").remove()
                },
                _destroy: function() {
                    var t;
                    this.element.removeAttr("role"), this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(), this._destroyIcons(), t = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(), "content" !== this.options.heightStyle && t.css("height", "")
                },
                _setOption: function(t, e) {
                    "active" !== t ? ("event" === t && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(e)), this._super(t, e), "collapsible" !== t || e || !1 !== this.options.active || this._activate(0), "icons" === t && (this._destroyIcons(), e && this._createIcons())) : this._activate(e)
                },
                _setOptionDisabled: function(t) {
                    this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t), this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!t)
                },
                _keydown: function(t) {
                    if (!t.altKey && !t.ctrlKey) {
                        var e = V.ui.keyCode,
                            i = this.headers.length,
                            s = this.headers.index(t.target),
                            n = !1;
                        switch (t.keyCode) {
                            case e.RIGHT:
                            case e.DOWN:
                                n = this.headers[(s + 1) % i];
                                break;
                            case e.LEFT:
                            case e.UP:
                                n = this.headers[(s - 1 + i) % i];
                                break;
                            case e.SPACE:
                            case e.ENTER:
                                this._eventHandler(t);
                                break;
                            case e.HOME:
                                n = this.headers[0];
                                break;
                            case e.END:
                                n = this.headers[i - 1]
                        }
                        n && (V(t.target).attr("tabIndex", -1), V(n).attr("tabIndex", 0), V(n).trigger("focus"), t.preventDefault())
                    }
                },
                _panelKeyDown: function(t) {
                    t.keyCode === V.ui.keyCode.UP && t.ctrlKey && V(t.currentTarget).prev().trigger("focus")
                },
                refresh: function() {
                    var t = this.options;
                    this._processPanels(), !1 === t.active && !0 === t.collapsible || !this.headers.length ? (t.active = !1, this.active = V()) : !1 === t.active ? this._activate(0) : this.active.length && !V.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (t.active = !1, this.active = V()) : this._activate(Math.max(0, t.active - 1)) : t.active = this.headers.index(this.active), this._destroyIcons(), this._refresh()
                },
                _processPanels: function() {
                    var t = this.headers,
                        e = this.panels;
                    "function" == typeof this.options.header ? this.headers = this.options.header(this.element) : this.headers = this.element.find(this.options.header), this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default"), this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide(), this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content"), e && (this._off(t.not(this.headers)), this._off(e.not(this.panels)))
                },
                _refresh: function() {
                    var i, t = this.options,
                        e = t.heightStyle,
                        s = this.element.parent();
                    this.active = this._findActive(t.active), this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed"), this._addClass(this.active.next(), "ui-accordion-content-active"), this.active.next().show(), this.headers.attr("role", "tab").each(function() {
                        var t = V(this),
                            e = t.uniqueId().attr("id"),
                            i = t.next(),
                            s = i.uniqueId().attr("id");
                        t.attr("aria-controls", s), i.attr("aria-labelledby", e)
                    }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
                        "aria-selected": "false",
                        "aria-expanded": "false",
                        tabIndex: -1
                    }).next().attr({
                        "aria-hidden": "true"
                    }).hide(), this.active.length ? this.active.attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    }).next().attr({
                        "aria-hidden": "false"
                    }) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(t.event), "fill" === e ? (i = s.height(), this.element.siblings(":visible").each(function() {
                        var t = V(this),
                            e = t.css("position");
                        "absolute" !== e && "fixed" !== e && (i -= t.outerHeight(!0))
                    }), this.headers.each(function() {
                        i -= V(this).outerHeight(!0)
                    }), this.headers.next().each(function() {
                        V(this).height(Math.max(0, i - V(this).innerHeight() + V(this).height()))
                    }).css("overflow", "auto")) : "auto" === e && (i = 0, this.headers.next().each(function() {
                        var t = V(this).is(":visible");
                        t || V(this).show(), i = Math.max(i, V(this).css("height", "").height()), t || V(this).hide()
                    }).height(i))
                },
                _activate: function(t) {
                    t = this._findActive(t)[0];
                    t !== this.active[0] && (t = t || this.active[0], this._eventHandler({
                        target: t,
                        currentTarget: t,
                        preventDefault: V.noop
                    }))
                },
                _findActive: function(t) {
                    return "number" == typeof t ? this.headers.eq(t) : V()
                },
                _setupEvents: function(t) {
                    var i = {
                        keydown: "_keydown"
                    };
                    t && V.each(t.split(" "), function(t, e) {
                        i[e] = "_eventHandler"
                    }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, i), this._on(this.headers.next(), {
                        keydown: "_panelKeyDown"
                    }), this._hoverable(this.headers), this._focusable(this.headers)
                },
                _eventHandler: function(t) {
                    var e = this.options,
                        i = this.active,
                        s = V(t.currentTarget),
                        n = s[0] === i[0],
                        o = n && e.collapsible,
                        a = o ? V() : s.next(),
                        r = i.next(),
                        a = {
                            oldHeader: i,
                            oldPanel: r,
                            newHeader: o ? V() : s,
                            newPanel: a
                        };
                    t.preventDefault(), n && !e.collapsible || !1 === this._trigger("beforeActivate", t, a) || (e.active = !o && this.headers.index(s), this.active = n ? V() : s, this._toggle(a), this._removeClass(i, "ui-accordion-header-active", "ui-state-active"), e.icons && (i = i.children(".ui-accordion-header-icon"), this._removeClass(i, null, e.icons.activeHeader)._addClass(i, null, e.icons.header)), n || (this._removeClass(s, "ui-accordion-header-collapsed")._addClass(s, "ui-accordion-header-active", "ui-state-active"), e.icons && (n = s.children(".ui-accordion-header-icon"), this._removeClass(n, null, e.icons.header)._addClass(n, null, e.icons.activeHeader)), this._addClass(s.next(), "ui-accordion-content-active")))
                },
                _toggle: function(t) {
                    var e = t.newPanel,
                        i = this.prevShow.length ? this.prevShow : t.oldPanel;
                    this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = e, this.prevHide = i, this.options.animate ? this._animate(e, i, t) : (i.hide(), e.show(), this._toggleComplete(t)), i.attr({
                        "aria-hidden": "true"
                    }), i.prev().attr({
                        "aria-selected": "false",
                        "aria-expanded": "false"
                    }), e.length && i.length ? i.prev().attr({
                        tabIndex: -1,
                        "aria-expanded": "false"
                    }) : e.length && this.headers.filter(function() {
                        return 0 === parseInt(V(this).attr("tabIndex"), 10)
                    }).attr("tabIndex", -1), e.attr("aria-hidden", "false").prev().attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    })
                },
                _animate: function(t, i, e) {
                    var s, n, o, a = this,
                        r = 0,
                        l = t.css("box-sizing"),
                        h = t.length && (!i.length || t.index() < i.index()),
                        c = this.options.animate || {},
                        u = h && c.down || c,
                        h = function() {
                            a._toggleComplete(e)
                        };
                    return n = (n = "string" == typeof u ? u : n) || u.easing || c.easing, o = (o = "number" == typeof u ? u : o) || u.duration || c.duration, i.length ? t.length ? (s = t.show().outerHeight(), i.animate(this.hideProps, {
                        duration: o,
                        easing: n,
                        step: function(t, e) {
                            e.now = Math.round(t)
                        }
                    }), void t.hide().animate(this.showProps, {
                        duration: o,
                        easing: n,
                        complete: h,
                        step: function(t, e) {
                            e.now = Math.round(t), "height" !== e.prop ? "content-box" === l && (r += e.now) : "content" !== a.options.heightStyle && (e.now = Math.round(s - i.outerHeight() - r), r = 0)
                        }
                    })) : i.animate(this.hideProps, o, n, h) : t.animate(this.showProps, o, n, h)
                },
                _toggleComplete: function(t) {
                    var e = t.oldPanel,
                        i = e.prev();
                    this._removeClass(e, "ui-accordion-content-active"), this._removeClass(i, "ui-accordion-header-active")._addClass(i, "ui-accordion-header-collapsed"), e.length && (e.parent()[0].className = e.parent()[0].className), this._trigger("activate", null, t)
                }
            }), V.ui.safeActiveElement = function(e) {
                var i;
                try {
                    i = e.activeElement
                } catch (t) {
                    i = e.body
                }
                return i = !(i = i || e.body).nodeName ? e.body : i
            }, V.widget("ui.menu", {
                version: "1.13.2",
                defaultElement: "<ul>",
                delay: 300,
                options: {
                    icons: {
                        submenu: "ui-icon-caret-1-e"
                    },
                    items: "> *",
                    menus: "ul",
                    position: {
                        my: "left top",
                        at: "right top"
                    },
                    role: "menu",
                    blur: null,
                    focus: null,
                    select: null
                },
                _create: function() {
                    this.activeMenu = this.element, this.mouseHandled = !1, this.lastMousePosition = {
                        x: null,
                        y: null
                    }, this.element.uniqueId().attr({
                        role: this.options.role,
                        tabIndex: 0
                    }), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({
                        "mousedown .ui-menu-item": function(t) {
                            t.preventDefault(), this._activateItem(t)
                        },
                        "click .ui-menu-item": function(t) {
                            var e = V(t.target),
                                i = V(V.ui.safeActiveElement(this.document[0]));
                            !this.mouseHandled && e.not(".ui-state-disabled").length && (this.select(t), t.isPropagationStopped() || (this.mouseHandled = !0), e.has(".ui-menu").length ? this.expand(t) : !this.element.is(":focus") && i.closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)))
                        },
                        "mouseenter .ui-menu-item": "_activateItem",
                        "mousemove .ui-menu-item": "_activateItem",
                        mouseleave: "collapseAll",
                        "mouseleave .ui-menu": "collapseAll",
                        focus: function(t, e) {
                            var i = this.active || this._menuItems().first();
                            e || this.focus(t, i)
                        },
                        blur: function(t) {
                            this._delay(function() {
                                V.contains(this.element[0], V.ui.safeActiveElement(this.document[0])) || this.collapseAll(t)
                            })
                        },
                        keydown: "_keydown"
                    }), this.refresh(), this._on(this.document, {
                        click: function(t) {
                            this._closeOnDocumentClick(t) && this.collapseAll(t, !0), this.mouseHandled = !1
                        }
                    })
                },
                _activateItem: function(t) {
                    var e, i;
                    this.previousFilter || t.clientX === this.lastMousePosition.x && t.clientY === this.lastMousePosition.y || (this.lastMousePosition = {
                        x: t.clientX,
                        y: t.clientY
                    }, e = V(t.target).closest(".ui-menu-item"), i = V(t.currentTarget), e[0] === i[0] && (i.is(".ui-state-active") || (this._removeClass(i.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(t, i))))
                },
                _destroy: function() {
                    var t = this.element.find(".ui-menu-item").removeAttr("role aria-disabled").children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
                    this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), t.children().each(function() {
                        var t = V(this);
                        t.data("ui-menu-submenu-caret") && t.remove()
                    })
                },
                _keydown: function(t) {
                    var e, i, s, n = !0;
                    switch (t.keyCode) {
                        case V.ui.keyCode.PAGE_UP:
                            this.previousPage(t);
                            break;
                        case V.ui.keyCode.PAGE_DOWN:
                            this.nextPage(t);
                            break;
                        case V.ui.keyCode.HOME:
                            this._move("first", "first", t);
                            break;
                        case V.ui.keyCode.END:
                            this._move("last", "last", t);
                            break;
                        case V.ui.keyCode.UP:
                            this.previous(t);
                            break;
                        case V.ui.keyCode.DOWN:
                            this.next(t);
                            break;
                        case V.ui.keyCode.LEFT:
                            this.collapse(t);
                            break;
                        case V.ui.keyCode.RIGHT:
                            this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
                            break;
                        case V.ui.keyCode.ENTER:
                        case V.ui.keyCode.SPACE:
                            this._activate(t);
                            break;
                        case V.ui.keyCode.ESCAPE:
                            this.collapse(t);
                            break;
                        default:
                            e = this.previousFilter || "", s = n = !1, i = 96 <= t.keyCode && t.keyCode <= 105 ? (t.keyCode - 96).toString() : String.fromCharCode(t.keyCode), clearTimeout(this.filterTimer), i === e ? s = !0 : i = e + i, e = this._filterMenuItems(i), (e = s && -1 !== e.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : e).length || (i = String.fromCharCode(t.keyCode), e = this._filterMenuItems(i)), e.length ? (this.focus(t, e), this.previousFilter = i, this.filterTimer = this._delay(function() {
                                delete this.previousFilter
                            }, 1e3)) : delete this.previousFilter
                    }
                    n && t.preventDefault()
                },
                _activate: function(t) {
                    this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t) : this.select(t))
                },
                refresh: function() {
                    var t, e, s = this,
                        n = this.options.icons.submenu,
                        i = this.element.find(this.options.menus);
                    this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), e = i.filter(":not(.ui-menu)").hide().attr({
                        role: this.options.role,
                        "aria-hidden": "true",
                        "aria-expanded": "false"
                    }).each(function() {
                        var t = V(this),
                            e = t.prev(),
                            i = V("<span>").data("ui-menu-submenu-caret", !0);
                        s._addClass(i, "ui-menu-icon", "ui-icon " + n), e.attr("aria-haspopup", "true").prepend(i), t.attr("aria-labelledby", e.attr("id"))
                    }), this._addClass(e, "ui-menu", "ui-widget ui-widget-content ui-front"), (t = i.add(this.element).find(this.options.items)).not(".ui-menu-item").each(function() {
                        var t = V(this);
                        s._isDivider(t) && s._addClass(t, "ui-menu-divider", "ui-widget-content")
                    }), i = (e = t.not(".ui-menu-item, .ui-menu-divider")).children().not(".ui-menu").uniqueId().attr({
                        tabIndex: -1,
                        role: this._itemRole()
                    }), this._addClass(e, "ui-menu-item")._addClass(i, "ui-menu-item-wrapper"), t.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !V.contains(this.element[0], this.active[0]) && this.blur()
                },
                _itemRole: function() {
                    return {
                        menu: "menuitem",
                        listbox: "option"
                    }[this.options.role]
                },
                _setOption: function(t, e) {
                    var i;
                    "icons" === t && (i = this.element.find(".ui-menu-icon"), this._removeClass(i, null, this.options.icons.submenu)._addClass(i, null, e.submenu)), this._super(t, e)
                },
                _setOptionDisabled: function(t) {
                    this._super(t), this.element.attr("aria-disabled", String(t)), this._toggleClass(null, "ui-state-disabled", !!t)
                },
                focus: function(t, e) {
                    var i;
                    this.blur(t, t && "focus" === t.type), this._scrollIntoView(e), this.active = e.first(), i = this.active.children(".ui-menu-item-wrapper"), this._addClass(i, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", i.attr("id")), i = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(i, null, "ui-state-active"), t && "keydown" === t.type ? this._close() : this.timer = this._delay(function() {
                        this._close()
                    }, this.delay), (i = e.children(".ui-menu")).length && t && /^mouse/.test(t.type) && this._startOpening(i), this.activeMenu = e.parent(), this._trigger("focus", t, {
                        item: e
                    })
                },
                _scrollIntoView: function(t) {
                    var e, i, s;
                    this._hasScroll() && (i = parseFloat(V.css(this.activeMenu[0], "borderTopWidth")) || 0, s = parseFloat(V.css(this.activeMenu[0], "paddingTop")) || 0, e = t.offset().top - this.activeMenu.offset().top - i - s, i = this.activeMenu.scrollTop(), s = this.activeMenu.height(), t = t.outerHeight(), e < 0 ? this.activeMenu.scrollTop(i + e) : s < e + t && this.activeMenu.scrollTop(i + e - s + t))
                },
                blur: function(t, e) {
                    e || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t, {
                        item: this.active
                    }), this.active = null)
                },
                _startOpening: function(t) {
                    clearTimeout(this.timer), "true" === t.attr("aria-hidden") && (this.timer = this._delay(function() {
                        this._close(), this._open(t)
                    }, this.delay))
                },
                _open: function(t) {
                    var e = V.extend({
                        of: this.active
                    }, this.options.position);
                    clearTimeout(this.timer), this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(e)
                },
                collapseAll: function(e, i) {
                    clearTimeout(this.timer), this.timer = this._delay(function() {
                        var t = i ? this.element : V(e && e.target).closest(this.element.find(".ui-menu"));
                        t.length || (t = this.element), this._close(t), this.blur(e), this._removeClass(t.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = t
                    }, i ? 0 : this.delay)
                },
                _close: function(t) {
                    (t = t || (this.active ? this.active.parent() : this.element)).find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false")
                },
                _closeOnDocumentClick: function(t) {
                    return !V(t.target).closest(".ui-menu").length
                },
                _isDivider: function(t) {
                    return !/[^\-\u2014\u2013\s]/.test(t.text())
                },
                collapse: function(t) {
                    var e = this.active && this.active.parent().closest(".ui-menu-item", this.element);
                    e && e.length && (this._close(), this.focus(t, e))
                },
                expand: function(t) {
                    var e = this.active && this._menuItems(this.active.children(".ui-menu")).first();
                    e && e.length && (this._open(e.parent()), this._delay(function() {
                        this.focus(t, e)
                    }))
                },
                next: function(t) {
                    this._move("next", "first", t)
                },
                previous: function(t) {
                    this._move("prev", "last", t)
                },
                isFirstItem: function() {
                    return this.active && !this.active.prevAll(".ui-menu-item").length
                },
                isLastItem: function() {
                    return this.active && !this.active.nextAll(".ui-menu-item").length
                },
                _menuItems: function(t) {
                    return (t || this.element).find(this.options.items).filter(".ui-menu-item")
                },
                _move: function(t, e, i) {
                    var s;
                    (s = this.active ? "first" === t || "last" === t ? this.active["first" === t ? "prevAll" : "nextAll"](".ui-menu-item").last() : this.active[t + "All"](".ui-menu-item").first() : s) && s.length && this.active || (s = this._menuItems(this.activeMenu)[e]()), this.focus(i, s)
                },
                nextPage: function(t) {
                    var e, i, s;
                    this.active ? this.isLastItem() || (this._hasScroll() ? (i = this.active.offset().top, s = this.element.innerHeight(), 0 === V.fn.jquery.indexOf("3.2.") && (s += this.element[0].offsetHeight - this.element.outerHeight()), this.active.nextAll(".ui-menu-item").each(function() {
                        return (e = V(this)).offset().top - i - s < 0
                    }), this.focus(t, e)) : this.focus(t, this._menuItems(this.activeMenu)[this.active ? "last" : "first"]())) : this.next(t)
                },
                previousPage: function(t) {
                    var e, i, s;
                    this.active ? this.isFirstItem() || (this._hasScroll() ? (i = this.active.offset().top, s = this.element.innerHeight(), 0 === V.fn.jquery.indexOf("3.2.") && (s += this.element[0].offsetHeight - this.element.outerHeight()), this.active.prevAll(".ui-menu-item").each(function() {
                        return 0 < (e = V(this)).offset().top - i + s
                    }), this.focus(t, e)) : this.focus(t, this._menuItems(this.activeMenu).first())) : this.next(t)
                },
                _hasScroll: function() {
                    return this.element.outerHeight() < this.element.prop("scrollHeight")
                },
                select: function(t) {
                    this.active = this.active || V(t.target).closest(".ui-menu-item");
                    var e = {
                        item: this.active
                    };
                    this.active.has(".ui-menu").length || this.collapseAll(t, !0), this._trigger("select", t, e)
                },
                _filterMenuItems: function(t) {
                    var t = t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
                        e = new RegExp("^" + t, "i");
                    return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
                        return e.test(String.prototype.trim.call(V(this).children(".ui-menu-item-wrapper").text()))
                    })
                }
            });
            V.widget("ui.autocomplete", {
                version: "1.13.2",
                defaultElement: "<input>",
                options: {
                    appendTo: null,
                    autoFocus: !1,
                    delay: 300,
                    minLength: 1,
                    position: {
                        my: "left top",
                        at: "left bottom",
                        collision: "none"
                    },
                    source: null,
                    change: null,
                    close: null,
                    focus: null,
                    open: null,
                    response: null,
                    search: null,
                    select: null
                },
                requestIndex: 0,
                pending: 0,
                liveRegionTimer: null,
                _create: function() {
                    var i, s, n, t = this.element[0].nodeName.toLowerCase(),
                        e = "textarea" === t,
                        t = "input" === t;
                    this.isMultiLine = e || !t && this._isContentEditable(this.element), this.valueMethod = this.element[e || t ? "val" : "text"], this.isNewMenu = !0, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, {
                        keydown: function(t) {
                            if (this.element.prop("readOnly")) s = n = i = !0;
                            else {
                                s = n = i = !1;
                                var e = V.ui.keyCode;
                                switch (t.keyCode) {
                                    case e.PAGE_UP:
                                        i = !0, this._move("previousPage", t);
                                        break;
                                    case e.PAGE_DOWN:
                                        i = !0, this._move("nextPage", t);
                                        break;
                                    case e.UP:
                                        i = !0, this._keyEvent("previous", t);
                                        break;
                                    case e.DOWN:
                                        i = !0, this._keyEvent("next", t);
                                        break;
                                    case e.ENTER:
                                        this.menu.active && (i = !0, t.preventDefault(), this.menu.select(t));
                                        break;
                                    case e.TAB:
                                        this.menu.active && this.menu.select(t);
                                        break;
                                    case e.ESCAPE:
                                        this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(t), t.preventDefault());
                                        break;
                                    default:
                                        s = !0, this._searchTimeout(t)
                                }
                            }
                        },
                        keypress: function(t) {
                            if (i) return i = !1, void(this.isMultiLine && !this.menu.element.is(":visible") || t.preventDefault());
                            if (!s) {
                                var e = V.ui.keyCode;
                                switch (t.keyCode) {
                                    case e.PAGE_UP:
                                        this._move("previousPage", t);
                                        break;
                                    case e.PAGE_DOWN:
                                        this._move("nextPage", t);
                                        break;
                                    case e.UP:
                                        this._keyEvent("previous", t);
                                        break;
                                    case e.DOWN:
                                        this._keyEvent("next", t)
                                }
                            }
                        },
                        input: function(t) {
                            if (n) return n = !1, void t.preventDefault();
                            this._searchTimeout(t)
                        },
                        focus: function() {
                            this.selectedItem = null, this.previous = this._value()
                        },
                        blur: function(t) {
                            clearTimeout(this.searching), this.close(t), this._change(t)
                        }
                    }), this._initSource(), this.menu = V("<ul>").appendTo(this._appendTo()).menu({
                        role: null
                    }).hide().attr({
                        unselectable: "on"
                    }).menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, {
                        mousedown: function(t) {
                            t.preventDefault()
                        },
                        menufocus: function(t, e) {
                            var i, s;
                            if (this.isNewMenu && (this.isNewMenu = !1, t.originalEvent && /^mouse/.test(t.originalEvent.type))) return this.menu.blur(), void this.document.one("mousemove", function() {
                                V(t.target).trigger(t.originalEvent)
                            });
                            s = e.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", t, {
                                item: s
                            }) && t.originalEvent && /^key/.test(t.originalEvent.type) && this._value(s.value), (i = e.item.attr("aria-label") || s.value) && String.prototype.trim.call(i).length && (clearTimeout(this.liveRegionTimer), this.liveRegionTimer = this._delay(function() {
                                this.liveRegion.html(V("<div>").text(i))
                            }, 100))
                        },
                        menuselect: function(t, e) {
                            var i = e.item.data("ui-autocomplete-item"),
                                s = this.previous;
                            this.element[0] !== V.ui.safeActiveElement(this.document[0]) && (this.element.trigger("focus"), this.previous = s, this._delay(function() {
                                this.previous = s, this.selectedItem = i
                            })), !1 !== this._trigger("select", t, {
                                item: i
                            }) && this._value(i.value), this.term = this._value(), this.close(t), this.selectedItem = i
                        }
                    }), this.liveRegion = V("<div>", {
                        role: "status",
                        "aria-live": "assertive",
                        "aria-relevant": "additions"
                    }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, {
                        beforeunload: function() {
                            this.element.removeAttr("autocomplete")
                        }
                    })
                },
                _destroy: function() {
                    clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove()
                },
                _setOption: function(t, e) {
                    this._super(t, e), "source" === t && this._initSource(), "appendTo" === t && this.menu.element.appendTo(this._appendTo()), "disabled" === t && e && this.xhr && this.xhr.abort()
                },
                _isEventTargetInWidget: function(t) {
                    var e = this.menu.element[0];
                    return t.target === this.element[0] || t.target === e || V.contains(e, t.target)
                },
                _closeOnClickOutside: function(t) {
                    this._isEventTargetInWidget(t) || this.close()
                },
                _appendTo: function() {
                    var t = this.options.appendTo;
                    return t = !(t = !(t = t && (t.jquery || t.nodeType ? V(t) : this.document.find(t).eq(0))) || !t[0] ? this.element.closest(".ui-front, dialog") : t).length ? this.document[0].body : t
                },
                _initSource: function() {
                    var i, s, n = this;
                    Array.isArray(this.options.source) ? (i = this.options.source, this.source = function(t, e) {
                        e(V.ui.autocomplete.filter(i, t.term))
                    }) : "string" == typeof this.options.source ? (s = this.options.source, this.source = function(t, e) {
                        n.xhr && n.xhr.abort(), n.xhr = V.ajax({
                            url: s,
                            data: t,
                            dataType: "json",
                            success: function(t) {
                                e(t)
                            },
                            error: function() {
                                e([])
                            }
                        })
                    }) : this.source = this.options.source
                },
                _searchTimeout: function(s) {
                    clearTimeout(this.searching), this.searching = this._delay(function() {
                        var t = this.term === this._value(),
                            e = this.menu.element.is(":visible"),
                            i = s.altKey || s.ctrlKey || s.metaKey || s.shiftKey;
                        t && (e || i) || (this.selectedItem = null, this.search(null, s))
                    }, this.options.delay)
                },
                search: function(t, e) {
                    return t = null != t ? t : this._value(), this.term = this._value(), t.length < this.options.minLength ? this.close(e) : !1 !== this._trigger("search", e) ? this._search(t) : void 0
                },
                _search: function(t) {
                    this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({
                        term: t
                    }, this._response())
                },
                _response: function() {
                    var e = ++this.requestIndex;
                    return function(t) {
                        e === this.requestIndex && this.__response(t), this.pending--, this.pending || this._removeClass("ui-autocomplete-loading")
                    }.bind(this)
                },
                __response: function(t) {
                    t = t && this._normalize(t), this._trigger("response", null, {
                        content: t
                    }), !this.options.disabled && t && t.length && !this.cancelSearch ? (this._suggest(t), this._trigger("open")) : this._close()
                },
                close: function(t) {
                    this.cancelSearch = !0, this._close(t)
                },
                _close: function(t) {
                    this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", t))
                },
                _change: function(t) {
                    this.previous !== this._value() && this._trigger("change", t, {
                        item: this.selectedItem
                    })
                },
                _normalize: function(t) {
                    return t.length && t[0].label && t[0].value ? t : V.map(t, function(t) {
                        return "string" == typeof t ? {
                            label: t,
                            value: t
                        } : V.extend({}, t, {
                            label: t.label || t.value,
                            value: t.value || t.label
                        })
                    })
                },
                _suggest: function(t) {
                    var e = this.menu.element.empty();
                    this._renderMenu(e, t), this.isNewMenu = !0, this.menu.refresh(), e.show(), this._resizeMenu(), e.position(V.extend({
                        of: this.element
                    }, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, {
                        mousedown: "_closeOnClickOutside"
                    })
                },
                _resizeMenu: function() {
                    var t = this.menu.element;
                    t.outerWidth(Math.max(t.width("").outerWidth() + 1, this.element.outerWidth()))
                },
                _renderMenu: function(i, t) {
                    var s = this;
                    V.each(t, function(t, e) {
                        s._renderItemData(i, e)
                    })
                },
                _renderItemData: function(t, e) {
                    return this._renderItem(t, e).data("ui-autocomplete-item", e)
                },
                _renderItem: function(t, e) {
                    return V("<li>").append(V("<div>").text(e.label)).appendTo(t)
                },
                _move: function(t, e) {
                    if (this.menu.element.is(":visible")) return this.menu.isFirstItem() && /^previous/.test(t) || this.menu.isLastItem() && /^next/.test(t) ? (this.isMultiLine || this._value(this.term), void this.menu.blur()) : void this.menu[t](e);
                    this.search(null, e)
                },
                widget: function() {
                    return this.menu.element
                },
                _value: function() {
                    return this.valueMethod.apply(this.element, arguments)
                },
                _keyEvent: function(t, e) {
                    this.isMultiLine && !this.menu.element.is(":visible") || (this._move(t, e), e.preventDefault())
                },
                _isContentEditable: function(t) {
                    if (!t.length) return !1;
                    var e = t.prop("contentEditable");
                    return "inherit" === e ? this._isContentEditable(t.parent()) : "true" === e
                }
            }), V.extend(V.ui.autocomplete, {
                escapeRegex: function(t) {
                    return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
                },
                filter: function(t, e) {
                    var i = new RegExp(V.ui.autocomplete.escapeRegex(e), "i");
                    return V.grep(t, function(t) {
                        return i.test(t.label || t.value || t)
                    })
                }
            }), V.widget("ui.autocomplete", V.ui.autocomplete, {
                options: {
                    messages: {
                        noResults: "No search results.",
                        results: function(t) {
                            return t + (1 < t ? " results are" : " result is") + " available, use up and down arrow keys to navigate."
                        }
                    }
                },
                __response: function(t) {
                    var e;
                    this._superApply(arguments), this.options.disabled || this.cancelSearch || (e = t && t.length ? this.options.messages.results(t.length) : this.options.messages.noResults, clearTimeout(this.liveRegionTimer), this.liveRegionTimer = this._delay(function() {
                        this.liveRegion.html(V("<div>").text(e))
                    }, 100))
                }
            });
            V.ui.autocomplete;
            var tt = /ui-corner-([a-z]){2,6}/g;
            V.widget("ui.controlgroup", {
                version: "1.13.2",
                defaultElement: "<div>",
                options: {
                    direction: "horizontal",
                    disabled: null,
                    onlyVisible: !0,
                    items: {
                        button: "input[type=button], input[type=submit], input[type=reset], button, a",
                        controlgroupLabel: ".ui-controlgroup-label",
                        checkboxradio: "input[type='checkbox'], input[type='radio']",
                        selectmenu: "select",
                        spinner: ".ui-spinner-input"
                    }
                },
                _create: function() {
                    this._enhance()
                },
                _enhance: function() {
                    this.element.attr("role", "toolbar"), this.refresh()
                },
                _destroy: function() {
                    this._callChildMethod("destroy"), this.childWidgets.removeData("ui-controlgroup-data"), this.element.removeAttr("role"), this.options.items.controlgroupLabel && this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()
                },
                _initWidgets: function() {
                    var o = this,
                        a = [];
                    V.each(this.options.items, function(s, t) {
                        var e, n = {};
                        if (t) return "controlgroupLabel" === s ? ((e = o.element.find(t)).each(function() {
                            var t = V(this);
                            t.children(".ui-controlgroup-label-contents").length || t.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")
                        }), o._addClass(e, null, "ui-widget ui-widget-content ui-state-default"), void(a = a.concat(e.get()))) : void(V.fn[s] && (n = o["_" + s + "Options"] ? o["_" + s + "Options"]("middle") : {
                            classes: {}
                        }, o.element.find(t).each(function() {
                            var t = V(this),
                                e = t[s]("instance"),
                                i = V.widget.extend({}, n);
                            "button" === s && t.parent(".ui-spinner").length || ((e = e || t[s]()[s]("instance")) && (i.classes = o._resolveClassesValues(i.classes, e)), t[s](i), i = t[s]("widget"), V.data(i[0], "ui-controlgroup-data", e || t[s]("instance")), a.push(i[0]))
                        })))
                    }), this.childWidgets = V(V.uniqueSort(a)), this._addClass(this.childWidgets, "ui-controlgroup-item")
                },
                _callChildMethod: function(e) {
                    this.childWidgets.each(function() {
                        var t = V(this).data("ui-controlgroup-data");
                        t && t[e] && t[e]()
                    })
                },
                _updateCornerClass: function(t, e) {
                    e = this._buildSimpleOptions(e, "label").classes.label;
                    this._removeClass(t, null, "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"), this._addClass(t, null, e)
                },
                _buildSimpleOptions: function(t, e) {
                    var i = "vertical" === this.options.direction,
                        s = {
                            classes: {}
                        };
                    return s.classes[e] = {
                        middle: "",
                        first: "ui-corner-" + (i ? "top" : "left"),
                        last: "ui-corner-" + (i ? "bottom" : "right"),
                        only: "ui-corner-all"
                    }[t], s
                },
                _spinnerOptions: function(t) {
                    t = this._buildSimpleOptions(t, "ui-spinner");
                    return t.classes["ui-spinner-up"] = "", t.classes["ui-spinner-down"] = "", t
                },
                _buttonOptions: function(t) {
                    return this._buildSimpleOptions(t, "ui-button")
                },
                _checkboxradioOptions: function(t) {
                    return this._buildSimpleOptions(t, "ui-checkboxradio-label")
                },
                _selectmenuOptions: function(t) {
                    var e = "vertical" === this.options.direction;
                    return {
                        width: e && "auto",
                        classes: {
                            middle: {
                                "ui-selectmenu-button-open": "",
                                "ui-selectmenu-button-closed": ""
                            },
                            first: {
                                "ui-selectmenu-button-open": "ui-corner-" + (e ? "top" : "tl"),
                                "ui-selectmenu-button-closed": "ui-corner-" + (e ? "top" : "left")
                            },
                            last: {
                                "ui-selectmenu-button-open": e ? "" : "ui-corner-tr",
                                "ui-selectmenu-button-closed": "ui-corner-" + (e ? "bottom" : "right")
                            },
                            only: {
                                "ui-selectmenu-button-open": "ui-corner-top",
                                "ui-selectmenu-button-closed": "ui-corner-all"
                            }
                        }[t]
                    }
                },
                _resolveClassesValues: function(i, s) {
                    var n = {};
                    return V.each(i, function(t) {
                        var e = s.options.classes[t] || "",
                            e = String.prototype.trim.call(e.replace(tt, ""));
                        n[t] = (e + " " + i[t]).replace(/\s+/g, " ")
                    }), n
                },
                _setOption: function(t, e) {
                    "direction" === t && this._removeClass("ui-controlgroup-" + this.options.direction), this._super(t, e), "disabled" !== t ? this.refresh() : this._callChildMethod(e ? "disable" : "enable")
                },
                refresh: function() {
                    var n, o = this;
                    this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction), "horizontal" === this.options.direction && this._addClass(null, "ui-helper-clearfix"), this._initWidgets(), n = this.childWidgets, (n = this.options.onlyVisible ? n.filter(":visible") : n).length && (V.each(["first", "last"], function(t, e) {
                        var i, s = n[e]().data("ui-controlgroup-data");
                        s && o["_" + s.widgetName + "Options"] ? ((i = o["_" + s.widgetName + "Options"](1 === n.length ? "only" : e)).classes = o._resolveClassesValues(i.classes, s), s.element[s.widgetName](i)) : o._updateCornerClass(n[e](), e)
                    }), this._callChildMethod("refresh"))
                }
            });
            V.widget("ui.checkboxradio", [V.ui.formResetMixin, {
                version: "1.13.2",
                options: {
                    disabled: null,
                    label: null,
                    icon: !0,
                    classes: {
                        "ui-checkboxradio-label": "ui-corner-all",
                        "ui-checkboxradio-icon": "ui-corner-all"
                    }
                },
                _getCreateOptions: function() {
                    var t, e = this._super() || {};
                    return this._readType(), t = this.element.labels(), this.label = V(t[t.length - 1]), this.label.length || V.error("No label found for checkboxradio widget"), this.originalLabel = "", (t = this.label.contents().not(this.element[0])).length && (this.originalLabel += t.clone().wrapAll("<div></div>").parent().html()), this.originalLabel && (e.label = this.originalLabel), null != (t = this.element[0].disabled) && (e.disabled = t), e
                },
                _create: function() {
                    var t = this.element[0].checked;
                    this._bindFormResetHandler(), null == this.options.disabled && (this.options.disabled = this.element[0].disabled), this._setOption("disabled", this.options.disabled), this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible"), this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget"), "radio" === this.type && this._addClass(this.label, "ui-checkboxradio-radio-label"), this.options.label && this.options.label !== this.originalLabel ? this._updateLabel() : this.originalLabel && (this.options.label = this.originalLabel), this._enhance(), t && this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active"), this._on({
                        change: "_toggleClasses",
                        focus: function() {
                            this._addClass(this.label, null, "ui-state-focus ui-visual-focus")
                        },
                        blur: function() {
                            this._removeClass(this.label, null, "ui-state-focus ui-visual-focus")
                        }
                    })
                },
                _readType: function() {
                    var t = this.element[0].nodeName.toLowerCase();
                    this.type = this.element[0].type, "input" === t && /radio|checkbox/.test(this.type) || V.error("Can't create checkboxradio on element.nodeName=" + t + " and element.type=" + this.type)
                },
                _enhance: function() {
                    this._updateIcon(this.element[0].checked)
                },
                widget: function() {
                    return this.label
                },
                _getRadioGroup: function() {
                    var t = this.element[0].name,
                        e = "input[name='" + V.escapeSelector(t) + "']";
                    return t ? (this.form.length ? V(this.form[0].elements).filter(e) : V(e).filter(function() {
                        return 0 === V(this)._form().length
                    })).not(this.element) : V([])
                },
                _toggleClasses: function() {
                    var t = this.element[0].checked;
                    this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), this.options.icon && "checkbox" === this.type && this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", t)._toggleClass(this.icon, null, "ui-icon-blank", !t), "radio" === this.type && this._getRadioGroup().each(function() {
                        var t = V(this).checkboxradio("instance");
                        t && t._removeClass(t.label, "ui-checkboxradio-checked", "ui-state-active")
                    })
                },
                _destroy: function() {
                    this._unbindFormResetHandler(), this.icon && (this.icon.remove(), this.iconSpace.remove())
                },
                _setOption: function(t, e) {
                    if ("label" !== t || e) {
                        if (this._super(t, e), "disabled" === t) return this._toggleClass(this.label, null, "ui-state-disabled", e), void(this.element[0].disabled = e);
                        this.refresh()
                    }
                },
                _updateIcon: function(t) {
                    var e = "ui-icon ui-icon-background ";
                    this.options.icon ? (this.icon || (this.icon = V("<span>"), this.iconSpace = V("<span> </span>"), this._addClass(this.iconSpace, "ui-checkboxradio-icon-space")), "checkbox" === this.type ? (e += t ? "ui-icon-check ui-state-checked" : "ui-icon-blank", this._removeClass(this.icon, null, t ? "ui-icon-blank" : "ui-icon-check")) : e += "ui-icon-blank", this._addClass(this.icon, "ui-checkboxradio-icon", e), t || this._removeClass(this.icon, null, "ui-icon-check ui-state-checked"), this.icon.prependTo(this.label).after(this.iconSpace)) : void 0 !== this.icon && (this.icon.remove(), this.iconSpace.remove(), delete this.icon)
                },
                _updateLabel: function() {
                    var t = this.label.contents().not(this.element[0]);
                    this.icon && (t = t.not(this.icon[0])), (t = this.iconSpace ? t.not(this.iconSpace[0]) : t).remove(), this.label.append(this.options.label)
                },
                refresh: function() {
                    var t = this.element[0].checked,
                        e = this.element[0].disabled;
                    this._updateIcon(t), this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), null !== this.options.label && this._updateLabel(), e !== this.options.disabled && this._setOptions({
                        disabled: e
                    })
                }
            }]);
            var et;
            V.ui.checkboxradio;
            V.widget("ui.button", {
                version: "1.13.2",
                defaultElement: "<button>",
                options: {
                    classes: {
                        "ui-button": "ui-corner-all"
                    },
                    disabled: null,
                    icon: null,
                    iconPosition: "beginning",
                    label: null,
                    showLabel: !0
                },
                _getCreateOptions: function() {
                    var t, e = this._super() || {};
                    return this.isInput = this.element.is("input"), null != (t = this.element[0].disabled) && (e.disabled = t), this.originalLabel = this.isInput ? this.element.val() : this.element.html(), this.originalLabel && (e.label = this.originalLabel), e
                },
                _create: function() {
                    !this.option.showLabel & !this.options.icon && (this.options.showLabel = !0), null == this.options.disabled && (this.options.disabled = this.element[0].disabled || !1), this.hasTitle = !!this.element.attr("title"), this.options.label && this.options.label !== this.originalLabel && (this.isInput ? this.element.val(this.options.label) : this.element.html(this.options.label)), this._addClass("ui-button", "ui-widget"), this._setOption("disabled", this.options.disabled), this._enhance(), this.element.is("a") && this._on({
                        keyup: function(t) {
                            t.keyCode === V.ui.keyCode.SPACE && (t.preventDefault(), this.element[0].click ? this.element[0].click() : this.element.trigger("click"))
                        }
                    })
                },
                _enhance: function() {
                    this.element.is("button") || this.element.attr("role", "button"), this.options.icon && (this._updateIcon("icon", this.options.icon), this._updateTooltip())
                },
                _updateTooltip: function() {
                    this.title = this.element.attr("title"), this.options.showLabel || this.title || this.element.attr("title", this.options.label)
                },
                _updateIcon: function(t, e) {
                    var i = "iconPosition" !== t,
                        s = i ? this.options.iconPosition : e,
                        t = "top" === s || "bottom" === s;
                    this.icon ? i && this._removeClass(this.icon, null, this.options.icon) : (this.icon = V("<span>"), this._addClass(this.icon, "ui-button-icon", "ui-icon"), this.options.showLabel || this._addClass("ui-button-icon-only")), i && this._addClass(this.icon, null, e), this._attachIcon(s), t ? (this._addClass(this.icon, null, "ui-widget-icon-block"), this.iconSpace && this.iconSpace.remove()) : (this.iconSpace || (this.iconSpace = V("<span> </span>"), this._addClass(this.iconSpace, "ui-button-icon-space")), this._removeClass(this.icon, null, "ui-wiget-icon-block"), this._attachIconSpace(s))
                },
                _destroy: function() {
                    this.element.removeAttr("role"), this.icon && this.icon.remove(), this.iconSpace && this.iconSpace.remove(), this.hasTitle || this.element.removeAttr("title")
                },
                _attachIconSpace: function(t) {
                    this.icon[/^(?:end|bottom)/.test(t) ? "before" : "after"](this.iconSpace)
                },
                _attachIcon: function(t) {
                    this.element[/^(?:end|bottom)/.test(t) ? "append" : "prepend"](this.icon)
                },
                _setOptions: function(t) {
                    var e = (void 0 === t.showLabel ? this.options : t).showLabel,
                        i = (void 0 === t.icon ? this.options : t).icon;
                    e || i || (t.showLabel = !0), this._super(t)
                },
                _setOption: function(t, e) {
                    "icon" === t && (e ? this._updateIcon(t, e) : this.icon && (this.icon.remove(), this.iconSpace && this.iconSpace.remove())), "iconPosition" === t && this._updateIcon(t, e), "showLabel" === t && (this._toggleClass("ui-button-icon-only", null, !e), this._updateTooltip()), "label" === t && (this.isInput ? this.element.val(e) : (this.element.html(e), this.icon && (this._attachIcon(this.options.iconPosition), this._attachIconSpace(this.options.iconPosition)))), this._super(t, e), "disabled" === t && (this._toggleClass(null, "ui-state-disabled", e), (this.element[0].disabled = e) && this.element.trigger("blur"))
                },
                refresh: function() {
                    var t = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
                    t !== this.options.disabled && this._setOptions({
                        disabled: t
                    }), this._updateTooltip()
                }
            }), !1 !== V.uiBackCompat && (V.widget("ui.button", V.ui.button, {
                options: {
                    text: !0,
                    icons: {
                        primary: null,
                        secondary: null
                    }
                },
                _create: function() {
                    this.options.showLabel && !this.options.text && (this.options.showLabel = this.options.text), !this.options.showLabel && this.options.text && (this.options.text = this.options.showLabel), this.options.icon || !this.options.icons.primary && !this.options.icons.secondary ? this.options.icon && (this.options.icons.primary = this.options.icon) : this.options.icons.primary ? this.options.icon = this.options.icons.primary : (this.options.icon = this.options.icons.secondary, this.options.iconPosition = "end"), this._super()
                },
                _setOption: function(t, e) {
                    "text" !== t ? ("showLabel" === t && (this.options.text = e), "icon" === t && (this.options.icons.primary = e), "icons" === t && (e.primary ? (this._super("icon", e.primary), this._super("iconPosition", "beginning")) : e.secondary && (this._super("icon", e.secondary), this._super("iconPosition", "end"))), this._superApply(arguments)) : this._super("showLabel", e)
                }
            }), V.fn.button = (et = V.fn.button, function(i) {
                var t = "string" == typeof i,
                    s = Array.prototype.slice.call(arguments, 1),
                    n = this;
                return t ? this.length || "instance" !== i ? this.each(function() {
                    var t = V(this).attr("type"),
                        e = V.data(this, "ui-" + ("checkbox" !== t && "radio" !== t ? "button" : "checkboxradio"));
                    return "instance" === i ? (n = e, !1) : e ? "function" != typeof e[i] || "_" === i.charAt(0) ? V.error("no such method '" + i + "' for button widget instance") : (t = e[i].apply(e, s)) !== e && void 0 !== t ? (n = t && t.jquery ? n.pushStack(t.get()) : t, !1) : void 0 : V.error("cannot call methods on button prior to initialization; attempted to call method '" + i + "'")
                }) : n = void 0 : (s.length && (i = V.widget.extend.apply(null, [i].concat(s))), this.each(function() {
                    var t = V(this).attr("type"),
                        e = "checkbox" !== t && "radio" !== t ? "button" : "checkboxradio",
                        t = V.data(this, "ui-" + e);
                    t ? (t.option(i || {}), t._init && t._init()) : "button" != e ? V(this).checkboxradio(V.extend({
                        icon: !1
                    }, i)) : et.call(V(this), i)
                })), n
            }), V.fn.buttonset = function() {
                return V.ui.controlgroup || V.error("Controlgroup widget missing"), "option" === arguments[0] && "items" === arguments[1] && arguments[2] ? this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]) : "option" === arguments[0] && "items" === arguments[1] ? this.controlgroup.apply(this, [arguments[0], "items.button"]) : ("object" == typeof arguments[0] && arguments[0].items && (arguments[0].items = {
                    button: arguments[0].items
                }), this.controlgroup.apply(this, arguments))
            });
            var it;
            V.ui.button;

            function st() {
                this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
                    closeText: "Done",
                    prevText: "Prev",
                    nextText: "Next",
                    currentText: "Today",
                    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                    weekHeader: "Wk",
                    dateFormat: "mm/dd/yy",
                    firstDay: 0,
                    isRTL: !1,
                    showMonthAfterYear: !1,
                    yearSuffix: "",
                    selectMonthLabel: "Select month",
                    selectYearLabel: "Select year"
                }, this._defaults = {
                    showOn: "focus",
                    showAnim: "fadeIn",
                    showOptions: {},
                    defaultDate: null,
                    appendText: "",
                    buttonText: "...",
                    buttonImage: "",
                    buttonImageOnly: !1,
                    hideIfNoPrevNext: !1,
                    navigationAsDateFormat: !1,
                    gotoCurrent: !1,
                    changeMonth: !1,
                    changeYear: !1,
                    yearRange: "c-10:c+10",
                    showOtherMonths: !1,
                    selectOtherMonths: !1,
                    showWeek: !1,
                    calculateWeek: this.iso8601Week,
                    shortYearCutoff: "+10",
                    minDate: null,
                    maxDate: null,
                    duration: "fast",
                    beforeShowDay: null,
                    beforeShow: null,
                    onSelect: null,
                    onChangeMonthYear: null,
                    onClose: null,
                    onUpdateDatepicker: null,
                    numberOfMonths: 1,
                    showCurrentAtPos: 0,
                    stepMonths: 1,
                    stepBigMonths: 12,
                    altField: "",
                    altFormat: "",
                    constrainInput: !0,
                    showButtonPanel: !1,
                    autoSize: !1,
                    disabled: !1
                }, V.extend(this._defaults, this.regional[""]), this.regional.en = V.extend(!0, {}, this.regional[""]), this.regional["en-US"] = V.extend(!0, {}, this.regional.en), this.dpDiv = nt(V("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
            }

            function nt(t) {
                var e = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
                return t.on("mouseout", e, function() {
                    V(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && V(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && V(this).removeClass("ui-datepicker-next-hover")
                }).on("mouseover", e, ot)
            }

            function ot() {
                V.datepicker._isDisabledDatepicker((it.inline ? it.dpDiv.parent() : it.input)[0]) || (V(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), V(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && V(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && V(this).addClass("ui-datepicker-next-hover"))
            }

            function at(t, e) {
                for (var i in V.extend(t, e), e) null == e[i] && (t[i] = e[i]);
                return t
            }
            V.extend(V.ui, {
                datepicker: {
                    version: "1.13.2"
                }
            }), V.extend(st.prototype, {
                markerClassName: "hasDatepicker",
                maxRows: 4,
                _widgetDatepicker: function() {
                    return this.dpDiv
                },
                setDefaults: function(t) {
                    return at(this._defaults, t || {}), this
                },
                _attachDatepicker: function(t, e) {
                    var i, s = t.nodeName.toLowerCase(),
                        n = "div" === s || "span" === s;
                    t.id || (this.uuid += 1, t.id = "dp" + this.uuid), (i = this._newInst(V(t), n)).settings = V.extend({}, e || {}), "input" === s ? this._connectDatepicker(t, i) : n && this._inlineDatepicker(t, i)
                },
                _newInst: function(t, e) {
                    return {
                        id: t[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"),
                        input: t,
                        selectedDay: 0,
                        selectedMonth: 0,
                        selectedYear: 0,
                        drawMonth: 0,
                        drawYear: 0,
                        inline: e,
                        dpDiv: e ? nt(V("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
                    }
                },
                _connectDatepicker: function(t, e) {
                    var i = V(t);
                    e.append = V([]), e.trigger = V([]), i.hasClass(this.markerClassName) || (this._attachments(i, e), i.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp), this._autoSize(e), V.data(t, "datepicker", e), e.settings.disabled && this._disableDatepicker(t))
                },
                _attachments: function(t, e) {
                    var i, s = this._get(e, "appendText"),
                        n = this._get(e, "isRTL");
                    e.append && e.append.remove(), s && (e.append = V("<span>").addClass(this._appendClass).text(s), t[n ? "before" : "after"](e.append)), t.off("focus", this._showDatepicker), e.trigger && e.trigger.remove(), "focus" !== (i = this._get(e, "showOn")) && "both" !== i || t.on("focus", this._showDatepicker), "button" !== i && "both" !== i || (s = this._get(e, "buttonText"), i = this._get(e, "buttonImage"), this._get(e, "buttonImageOnly") ? e.trigger = V("<img>").addClass(this._triggerClass).attr({
                        src: i,
                        alt: s,
                        title: s
                    }) : (e.trigger = V("<button type='button'>").addClass(this._triggerClass), i ? e.trigger.html(V("<img>").attr({
                        src: i,
                        alt: s,
                        title: s
                    })) : e.trigger.text(s)), t[n ? "before" : "after"](e.trigger), e.trigger.on("click", function() {
                        return V.datepicker._datepickerShowing && V.datepicker._lastInput === t[0] ? V.datepicker._hideDatepicker() : (V.datepicker._datepickerShowing && V.datepicker._lastInput !== t[0] && V.datepicker._hideDatepicker(), V.datepicker._showDatepicker(t[0])), !1
                    }))
                },
                _autoSize: function(t) {
                    var e, i, s, n, o, a;
                    this._get(t, "autoSize") && !t.inline && (o = new Date(2009, 11, 20), (a = this._get(t, "dateFormat")).match(/[DM]/) && (e = function(t) {
                        for (n = s = i = 0; n < t.length; n++) t[n].length > i && (i = t[n].length, s = n);
                        return s
                    }, o.setMonth(e(this._get(t, a.match(/MM/) ? "monthNames" : "monthNamesShort"))), o.setDate(e(this._get(t, a.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - o.getDay())), t.input.attr("size", this._formatDate(t, o).length))
                },
                _inlineDatepicker: function(t, e) {
                    var i = V(t);
                    i.hasClass(this.markerClassName) || (i.addClass(this.markerClassName).append(e.dpDiv), V.data(t, "datepicker", e), this._setDate(e, this._getDefaultDate(e), !0), this._updateDatepicker(e), this._updateAlternate(e), e.settings.disabled && this._disableDatepicker(t), e.dpDiv.css("display", "block"))
                },
                _dialogDatepicker: function(t, e, i, s, n) {
                    var o, a = this._dialogInst;
                    return a || (this.uuid += 1, o = "dp" + this.uuid, this._dialogInput = V("<input type='text' id='" + o + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.on("keydown", this._doKeyDown), V("body").append(this._dialogInput), (a = this._dialogInst = this._newInst(this._dialogInput, !1)).settings = {}, V.data(this._dialogInput[0], "datepicker", a)), at(a.settings, s || {}), e = e && e.constructor === Date ? this._formatDate(a, e) : e, this._dialogInput.val(e), this._pos = n ? n.length ? n : [n.pageX, n.pageY] : null, this._pos || (o = document.documentElement.clientWidth, s = document.documentElement.clientHeight, e = document.documentElement.scrollLeft || document.body.scrollLeft, n = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [o / 2 - 100 + e, s / 2 - 150 + n]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), a.settings.onSelect = i, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), V.blockUI && V.blockUI(this.dpDiv), V.data(this._dialogInput[0], "datepicker", a), this
                },
                _destroyDatepicker: function(t) {
                    var e, i = V(t),
                        s = V.data(t, "datepicker");
                    i.hasClass(this.markerClassName) && (e = t.nodeName.toLowerCase(), V.removeData(t, "datepicker"), "input" === e ? (s.append.remove(), s.trigger.remove(), i.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp)) : "div" !== e && "span" !== e || i.removeClass(this.markerClassName).empty(), it === s && (it = null, this._curInst = null))
                },
                _enableDatepicker: function(e) {
                    var t, i = V(e),
                        s = V.data(e, "datepicker");
                    i.hasClass(this.markerClassName) && ("input" === (t = e.nodeName.toLowerCase()) ? (e.disabled = !1, s.trigger.filter("button").each(function() {
                        this.disabled = !1
                    }).end().filter("img").css({
                        opacity: "1.0",
                        cursor: ""
                    })) : "div" !== t && "span" !== t || ((i = i.children("." + this._inlineClass)).children().removeClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = V.map(this._disabledInputs, function(t) {
                        return t === e ? null : t
                    }))
                },
                _disableDatepicker: function(e) {
                    var t, i = V(e),
                        s = V.data(e, "datepicker");
                    i.hasClass(this.markerClassName) && ("input" === (t = e.nodeName.toLowerCase()) ? (e.disabled = !0, s.trigger.filter("button").each(function() {
                        this.disabled = !0
                    }).end().filter("img").css({
                        opacity: "0.5",
                        cursor: "default"
                    })) : "div" !== t && "span" !== t || ((i = i.children("." + this._inlineClass)).children().addClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = V.map(this._disabledInputs, function(t) {
                        return t === e ? null : t
                    }), this._disabledInputs[this._disabledInputs.length] = e)
                },
                _isDisabledDatepicker: function(t) {
                    if (!t) return !1;
                    for (var e = 0; e < this._disabledInputs.length; e++)
                        if (this._disabledInputs[e] === t) return !0;
                    return !1
                },
                _getInst: function(t) {
                    try {
                        return V.data(t, "datepicker")
                    } catch (t) {
                        throw "Missing instance data for this datepicker"
                    }
                },
                _optionDatepicker: function(t, e, i) {
                    var s, n, o = this._getInst(t);
                    if (2 === arguments.length && "string" == typeof e) return "defaults" === e ? V.extend({}, V.datepicker._defaults) : o ? "all" === e ? V.extend({}, o.settings) : this._get(o, e) : null;
                    s = e || {}, "string" == typeof e && ((s = {})[e] = i), o && (this._curInst === o && this._hideDatepicker(), n = this._getDateDatepicker(t, !0), e = this._getMinMaxDate(o, "min"), i = this._getMinMaxDate(o, "max"), at(o.settings, s), null !== e && void 0 !== s.dateFormat && void 0 === s.minDate && (o.settings.minDate = this._formatDate(o, e)), null !== i && void 0 !== s.dateFormat && void 0 === s.maxDate && (o.settings.maxDate = this._formatDate(o, i)), "disabled" in s && (s.disabled ? this._disableDatepicker(t) : this._enableDatepicker(t)), this._attachments(V(t), o), this._autoSize(o), this._setDate(o, n), this._updateAlternate(o), this._updateDatepicker(o))
                },
                _changeDatepicker: function(t, e, i) {
                    this._optionDatepicker(t, e, i)
                },
                _refreshDatepicker: function(t) {
                    t = this._getInst(t);
                    t && this._updateDatepicker(t)
                },
                _setDateDatepicker: function(t, e) {
                    t = this._getInst(t);
                    t && (this._setDate(t, e), this._updateDatepicker(t), this._updateAlternate(t))
                },
                _getDateDatepicker: function(t, e) {
                    t = this._getInst(t);
                    return t && !t.inline && this._setDateFromField(t, e), t ? this._getDate(t) : null
                },
                _doKeyDown: function(t) {
                    var e, i, s = V.datepicker._getInst(t.target),
                        n = !0,
                        o = s.dpDiv.is(".ui-datepicker-rtl");
                    if (s._keyEvent = !0, V.datepicker._datepickerShowing) switch (t.keyCode) {
                        case 9:
                            V.datepicker._hideDatepicker(), n = !1;
                            break;
                        case 13:
                            return (i = V("td." + V.datepicker._dayOverClass + ":not(." + V.datepicker._currentClass + ")", s.dpDiv))[0] && V.datepicker._selectDay(t.target, s.selectedMonth, s.selectedYear, i[0]), (e = V.datepicker._get(s, "onSelect")) ? (i = V.datepicker._formatDate(s), e.apply(s.input ? s.input[0] : null, [i, s])) : V.datepicker._hideDatepicker(), !1;
                        case 27:
                            V.datepicker._hideDatepicker();
                            break;
                        case 33:
                            V.datepicker._adjustDate(t.target, t.ctrlKey ? -V.datepicker._get(s, "stepBigMonths") : -V.datepicker._get(s, "stepMonths"), "M");
                            break;
                        case 34:
                            V.datepicker._adjustDate(t.target, t.ctrlKey ? +V.datepicker._get(s, "stepBigMonths") : +V.datepicker._get(s, "stepMonths"), "M");
                            break;
                        case 35:
                            (t.ctrlKey || t.metaKey) && V.datepicker._clearDate(t.target), n = t.ctrlKey || t.metaKey;
                            break;
                        case 36:
                            (t.ctrlKey || t.metaKey) && V.datepicker._gotoToday(t.target), n = t.ctrlKey || t.metaKey;
                            break;
                        case 37:
                            (t.ctrlKey || t.metaKey) && V.datepicker._adjustDate(t.target, o ? 1 : -1, "D"), n = t.ctrlKey || t.metaKey, t.originalEvent.altKey && V.datepicker._adjustDate(t.target, t.ctrlKey ? -V.datepicker._get(s, "stepBigMonths") : -V.datepicker._get(s, "stepMonths"), "M");
                            break;
                        case 38:
                            (t.ctrlKey || t.metaKey) && V.datepicker._adjustDate(t.target, -7, "D"), n = t.ctrlKey || t.metaKey;
                            break;
                        case 39:
                            (t.ctrlKey || t.metaKey) && V.datepicker._adjustDate(t.target, o ? -1 : 1, "D"), n = t.ctrlKey || t.metaKey, t.originalEvent.altKey && V.datepicker._adjustDate(t.target, t.ctrlKey ? +V.datepicker._get(s, "stepBigMonths") : +V.datepicker._get(s, "stepMonths"), "M");
                            break;
                        case 40:
                            (t.ctrlKey || t.metaKey) && V.datepicker._adjustDate(t.target, 7, "D"), n = t.ctrlKey || t.metaKey;
                            break;
                        default:
                            n = !1
                    } else 36 === t.keyCode && t.ctrlKey ? V.datepicker._showDatepicker(this) : n = !1;
                    n && (t.preventDefault(), t.stopPropagation())
                },
                _doKeyPress: function(t) {
                    var e, i = V.datepicker._getInst(t.target);
                    if (V.datepicker._get(i, "constrainInput")) return e = V.datepicker._possibleChars(V.datepicker._get(i, "dateFormat")), i = String.fromCharCode(null == t.charCode ? t.keyCode : t.charCode), t.ctrlKey || t.metaKey || i < " " || !e || -1 < e.indexOf(i)
                },
                _doKeyUp: function(t) {
                    t = V.datepicker._getInst(t.target);
                    if (t.input.val() !== t.lastVal) try {
                        V.datepicker.parseDate(V.datepicker._get(t, "dateFormat"), t.input ? t.input.val() : null, V.datepicker._getFormatConfig(t)) && (V.datepicker._setDateFromField(t), V.datepicker._updateAlternate(t), V.datepicker._updateDatepicker(t))
                    } catch (t) {}
                    return !0
                },
                _showDatepicker: function(t) {
                    var e, i, s, n;
                    "input" !== (t = t.target || t).nodeName.toLowerCase() && (t = V("input", t.parentNode)[0]), V.datepicker._isDisabledDatepicker(t) || V.datepicker._lastInput === t || (n = V.datepicker._getInst(t), V.datepicker._curInst && V.datepicker._curInst !== n && (V.datepicker._curInst.dpDiv.stop(!0, !0), n && V.datepicker._datepickerShowing && V.datepicker._hideDatepicker(V.datepicker._curInst.input[0])), !1 !== (i = (s = V.datepicker._get(n, "beforeShow")) ? s.apply(t, [t, n]) : {}) && (at(n.settings, i), n.lastVal = null, V.datepicker._lastInput = t, V.datepicker._setDateFromField(n), V.datepicker._inDialog && (t.value = ""), V.datepicker._pos || (V.datepicker._pos = V.datepicker._findPos(t), V.datepicker._pos[1] += t.offsetHeight), e = !1, V(t).parents().each(function() {
                        return !(e |= "fixed" === V(this).css("position"))
                    }), s = {
                        left: V.datepicker._pos[0],
                        top: V.datepicker._pos[1]
                    }, V.datepicker._pos = null, n.dpDiv.empty(), n.dpDiv.css({
                        position: "absolute",
                        display: "block",
                        top: "-1000px"
                    }), V.datepicker._updateDatepicker(n), s = V.datepicker._checkOffset(n, s, e), n.dpDiv.css({
                        position: V.datepicker._inDialog && V.blockUI ? "static" : e ? "fixed" : "absolute",
                        display: "none",
                        left: s.left + "px",
                        top: s.top + "px"
                    }), n.inline || (i = V.datepicker._get(n, "showAnim"), s = V.datepicker._get(n, "duration"), n.dpDiv.css("z-index", function(t) {
                        for (var e, i; t.length && t[0] !== document;) {
                            if (("absolute" === (e = t.css("position")) || "relative" === e || "fixed" === e) && (i = parseInt(t.css("zIndex"), 10), !isNaN(i) && 0 !== i)) return i;
                            t = t.parent()
                        }
                        return 0
                    }(V(t)) + 1), V.datepicker._datepickerShowing = !0, V.effects && V.effects.effect[i] ? n.dpDiv.show(i, V.datepicker._get(n, "showOptions"), s) : n.dpDiv[i || "show"](i ? s : null), V.datepicker._shouldFocusInput(n) && n.input.trigger("focus"), V.datepicker._curInst = n)))
                },
                _updateDatepicker: function(t) {
                    this.maxRows = 4, (it = t).dpDiv.empty().append(this._generateHTML(t)), this._attachHandlers(t);
                    var e, i = this._getNumberOfMonths(t),
                        s = i[1],
                        n = t.dpDiv.find("." + this._dayOverClass + " a"),
                        o = V.datepicker._get(t, "onUpdateDatepicker");
                    0 < n.length && ot.apply(n.get(0)), t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), 1 < s && t.dpDiv.addClass("ui-datepicker-multi-" + s).css("width", 17 * s + "em"), t.dpDiv[(1 !== i[0] || 1 !== i[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), t.dpDiv[(this._get(t, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), t === V.datepicker._curInst && V.datepicker._datepickerShowing && V.datepicker._shouldFocusInput(t) && t.input.trigger("focus"), t.yearshtml && (e = t.yearshtml, setTimeout(function() {
                        e === t.yearshtml && t.yearshtml && t.dpDiv.find("select.ui-datepicker-year").first().replaceWith(t.yearshtml), e = t.yearshtml = null
                    }, 0)), o && o.apply(t.input ? t.input[0] : null, [t])
                },
                _shouldFocusInput: function(t) {
                    return t.input && t.input.is(":visible") && !t.input.is(":disabled") && !t.input.is(":focus")
                },
                _checkOffset: function(t, e, i) {
                    var s = t.dpDiv.outerWidth(),
                        n = t.dpDiv.outerHeight(),
                        o = t.input ? t.input.outerWidth() : 0,
                        a = t.input ? t.input.outerHeight() : 0,
                        r = document.documentElement.clientWidth + (i ? 0 : V(document).scrollLeft()),
                        l = document.documentElement.clientHeight + (i ? 0 : V(document).scrollTop());
                    return e.left -= this._get(t, "isRTL") ? s - o : 0, e.left -= i && e.left === t.input.offset().left ? V(document).scrollLeft() : 0, e.top -= i && e.top === t.input.offset().top + a ? V(document).scrollTop() : 0, e.left -= Math.min(e.left, e.left + s > r && s < r ? Math.abs(e.left + s - r) : 0), e.top -= Math.min(e.top, e.top + n > l && n < l ? Math.abs(n + a) : 0), e
                },
                _findPos: function(t) {
                    for (var e = this._getInst(t), i = this._get(e, "isRTL"); t && ("hidden" === t.type || 1 !== t.nodeType || V.expr.pseudos.hidden(t));) t = t[i ? "previousSibling" : "nextSibling"];
                    return [(e = V(t).offset()).left, e.top]
                },
                _hideDatepicker: function(t) {
                    var e, i, s = this._curInst;
                    !s || t && s !== V.data(t, "datepicker") || this._datepickerShowing && (e = this._get(s, "showAnim"), i = this._get(s, "duration"), t = function() {
                        V.datepicker._tidyDialog(s)
                    }, V.effects && (V.effects.effect[e] || V.effects[e]) ? s.dpDiv.hide(e, V.datepicker._get(s, "showOptions"), i, t) : s.dpDiv["slideDown" === e ? "slideUp" : "fadeIn" === e ? "fadeOut" : "hide"](e ? i : null, t), e || t(), this._datepickerShowing = !1, (t = this._get(s, "onClose")) && t.apply(s.input ? s.input[0] : null, [s.input ? s.input.val() : "", s]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    }), V.blockUI && (V.unblockUI(), V("body").append(this.dpDiv))), this._inDialog = !1)
                },
                _tidyDialog: function(t) {
                    t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")
                },
                _checkExternalClick: function(t) {
                    var e;
                    V.datepicker._curInst && (e = V(t.target), t = V.datepicker._getInst(e[0]), (e[0].id === V.datepicker._mainDivId || 0 !== e.parents("#" + V.datepicker._mainDivId).length || e.hasClass(V.datepicker.markerClassName) || e.closest("." + V.datepicker._triggerClass).length || !V.datepicker._datepickerShowing || V.datepicker._inDialog && V.blockUI) && (!e.hasClass(V.datepicker.markerClassName) || V.datepicker._curInst === t) || V.datepicker._hideDatepicker())
                },
                _adjustDate: function(t, e, i) {
                    var s = V(t),
                        t = this._getInst(s[0]);
                    this._isDisabledDatepicker(s[0]) || (this._adjustInstDate(t, e, i), this._updateDatepicker(t))
                },
                _gotoToday: function(t) {
                    var e = V(t),
                        i = this._getInst(e[0]);
                    this._get(i, "gotoCurrent") && i.currentDay ? (i.selectedDay = i.currentDay, i.drawMonth = i.selectedMonth = i.currentMonth, i.drawYear = i.selectedYear = i.currentYear) : (t = new Date, i.selectedDay = t.getDate(), i.drawMonth = i.selectedMonth = t.getMonth(), i.drawYear = i.selectedYear = t.getFullYear()), this._notifyChange(i), this._adjustDate(e)
                },
                _selectMonthYear: function(t, e, i) {
                    var s = V(t),
                        t = this._getInst(s[0]);
                    t["selected" + ("M" === i ? "Month" : "Year")] = t["draw" + ("M" === i ? "Month" : "Year")] = parseInt(e.options[e.selectedIndex].value, 10), this._notifyChange(t), this._adjustDate(s)
                },
                _selectDay: function(t, e, i, s) {
                    var n = V(t);
                    V(s).hasClass(this._unselectableClass) || this._isDisabledDatepicker(n[0]) || ((n = this._getInst(n[0])).selectedDay = n.currentDay = parseInt(V("a", s).attr("data-date")), n.selectedMonth = n.currentMonth = e, n.selectedYear = n.currentYear = i, this._selectDate(t, this._formatDate(n, n.currentDay, n.currentMonth, n.currentYear)))
                },
                _clearDate: function(t) {
                    t = V(t);
                    this._selectDate(t, "")
                },
                _selectDate: function(t, e) {
                    var i = V(t),
                        t = this._getInst(i[0]);
                    e = null != e ? e : this._formatDate(t), t.input && t.input.val(e), this._updateAlternate(t), (i = this._get(t, "onSelect")) ? i.apply(t.input ? t.input[0] : null, [e, t]) : t.input && t.input.trigger("change"), t.inline ? this._updateDatepicker(t) : (this._hideDatepicker(), this._lastInput = t.input[0], "object" != typeof t.input[0] && t.input.trigger("focus"), this._lastInput = null)
                },
                _updateAlternate: function(t) {
                    var e, i, s = this._get(t, "altField");
                    s && (e = this._get(t, "altFormat") || this._get(t, "dateFormat"), i = this._getDate(t), t = this.formatDate(e, i, this._getFormatConfig(t)), V(document).find(s).val(t))
                },
                noWeekends: function(t) {
                    t = t.getDay();
                    return [0 < t && t < 6, ""]
                },
                iso8601Week: function(t) {
                    var e = new Date(t.getTime());
                    return e.setDate(e.getDate() + 4 - (e.getDay() || 7)), t = e.getTime(), e.setMonth(0), e.setDate(1), Math.floor(Math.round((t - e) / 864e5) / 7) + 1
                },
                parseDate: function(e, n, t) {
                    if (null == e || null == n) throw "Invalid arguments";
                    if ("" === (n = "object" == typeof n ? n.toString() : n + "")) return null;
                    for (var i, s, o, a = 0, r = (t ? t.shortYearCutoff : null) || this._defaults.shortYearCutoff, r = "string" != typeof r ? r : (new Date).getFullYear() % 100 + parseInt(r, 10), l = (t ? t.dayNamesShort : null) || this._defaults.dayNamesShort, h = (t ? t.dayNames : null) || this._defaults.dayNames, c = (t ? t.monthNamesShort : null) || this._defaults.monthNamesShort, u = (t ? t.monthNames : null) || this._defaults.monthNames, d = -1, p = -1, f = -1, g = -1, m = !1, _ = function(t) {
                            t = w + 1 < e.length && e.charAt(w + 1) === t;
                            return t && w++, t
                        }, v = function(t) {
                            var e = _(t),
                                e = "@" === t ? 14 : "!" === t ? 20 : "y" === t && e ? 4 : "o" === t ? 3 : 2,
                                e = new RegExp("^\\d{" + ("y" === t ? e : 1) + "," + e + "}"),
                                e = n.substring(a).match(e);
                            if (!e) throw "Missing number at position " + a;
                            return a += e[0].length, parseInt(e[0], 10)
                        }, b = function(t, e, i) {
                            var s = -1,
                                e = V.map(_(t) ? i : e, function(t, e) {
                                    return [
                                        [e, t]
                                    ]
                                }).sort(function(t, e) {
                                    return -(t[1].length - e[1].length)
                                });
                            if (V.each(e, function(t, e) {
                                    var i = e[1];
                                    if (n.substr(a, i.length).toLowerCase() === i.toLowerCase()) return s = e[0], a += i.length, !1
                                }), -1 !== s) return s + 1;
                            throw "Unknown name at position " + a
                        }, y = function() {
                            if (n.charAt(a) !== e.charAt(w)) throw "Unexpected literal at position " + a;
                            a++
                        }, w = 0; w < e.length; w++)
                        if (m) "'" !== e.charAt(w) || _("'") ? y() : m = !1;
                        else switch (e.charAt(w)) {
                            case "d":
                                f = v("d");
                                break;
                            case "D":
                                b("D", l, h);
                                break;
                            case "o":
                                g = v("o");
                                break;
                            case "m":
                                p = v("m");
                                break;
                            case "M":
                                p = b("M", c, u);
                                break;
                            case "y":
                                d = v("y");
                                break;
                            case "@":
                                d = (o = new Date(v("@"))).getFullYear(), p = o.getMonth() + 1, f = o.getDate();
                                break;
                            case "!":
                                d = (o = new Date((v("!") - this._ticksTo1970) / 1e4)).getFullYear(), p = o.getMonth() + 1, f = o.getDate();
                                break;
                            case "'":
                                _("'") ? y() : m = !0;
                                break;
                            default:
                                y()
                        }
                        if (a < n.length && (s = n.substr(a), !/^\s+/.test(s))) throw "Extra/unparsed characters found in date: " + s;
                    if (-1 === d ? d = (new Date).getFullYear() : d < 100 && (d += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (d <= r ? 0 : -100)), -1 < g)
                        for (p = 1, f = g;;) {
                            if (f <= (i = this._getDaysInMonth(d, p - 1))) break;
                            p++, f -= i
                        }
                    if ((o = this._daylightSavingAdjust(new Date(d, p - 1, f))).getFullYear() !== d || o.getMonth() + 1 !== p || o.getDate() !== f) throw "Invalid date";
                    return o
                },
                ATOM: "yy-mm-dd",
                COOKIE: "D, dd M yy",
                ISO_8601: "yy-mm-dd",
                RFC_822: "D, d M y",
                RFC_850: "DD, dd-M-y",
                RFC_1036: "D, d M y",
                RFC_1123: "D, d M yy",
                RFC_2822: "D, d M yy",
                RSS: "D, d M y",
                TICKS: "!",
                TIMESTAMP: "@",
                W3C: "yy-mm-dd",
                _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7,
                formatDate: function(e, t, i) {
                    if (!t) return "";

                    function s(t, e, i) {
                        var s = "" + e;
                        if (c(t))
                            for (; s.length < i;) s = "0" + s;
                        return s
                    }

                    function n(t, e, i, s) {
                        return (c(t) ? s : i)[e]
                    }
                    var o, a = (i ? i.dayNamesShort : null) || this._defaults.dayNamesShort,
                        r = (i ? i.dayNames : null) || this._defaults.dayNames,
                        l = (i ? i.monthNamesShort : null) || this._defaults.monthNamesShort,
                        h = (i ? i.monthNames : null) || this._defaults.monthNames,
                        c = function(t) {
                            t = o + 1 < e.length && e.charAt(o + 1) === t;
                            return t && o++, t
                        },
                        u = "",
                        d = !1;
                    if (t)
                        for (o = 0; o < e.length; o++)
                            if (d) "'" !== e.charAt(o) || c("'") ? u += e.charAt(o) : d = !1;
                            else switch (e.charAt(o)) {
                                case "d":
                                    u += s("d", t.getDate(), 2);
                                    break;
                                case "D":
                                    u += n("D", t.getDay(), a, r);
                                    break;
                                case "o":
                                    u += s("o", Math.round((new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() - new Date(t.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                                    break;
                                case "m":
                                    u += s("m", t.getMonth() + 1, 2);
                                    break;
                                case "M":
                                    u += n("M", t.getMonth(), l, h);
                                    break;
                                case "y":
                                    u += c("y") ? t.getFullYear() : (t.getFullYear() % 100 < 10 ? "0" : "") + t.getFullYear() % 100;
                                    break;
                                case "@":
                                    u += t.getTime();
                                    break;
                                case "!":
                                    u += 1e4 * t.getTime() + this._ticksTo1970;
                                    break;
                                case "'":
                                    c("'") ? u += "'" : d = !0;
                                    break;
                                default:
                                    u += e.charAt(o)
                            }
                            return u
                },
                _possibleChars: function(e) {
                    for (var t = "", i = !1, s = function(t) {
                            t = n + 1 < e.length && e.charAt(n + 1) === t;
                            return t && n++, t
                        }, n = 0; n < e.length; n++)
                        if (i) "'" !== e.charAt(n) || s("'") ? t += e.charAt(n) : i = !1;
                        else switch (e.charAt(n)) {
                            case "d":
                            case "m":
                            case "y":
                            case "@":
                                t += "0123456789";
                                break;
                            case "D":
                            case "M":
                                return null;
                            case "'":
                                s("'") ? t += "'" : i = !0;
                                break;
                            default:
                                t += e.charAt(n)
                        }
                        return t
                },
                _get: function(t, e) {
                    return (void 0 !== t.settings[e] ? t.settings : this._defaults)[e]
                },
                _setDateFromField: function(t, e) {
                    if (t.input.val() !== t.lastVal) {
                        var i = this._get(t, "dateFormat"),
                            s = t.lastVal = t.input ? t.input.val() : null,
                            n = this._getDefaultDate(t),
                            o = n,
                            a = this._getFormatConfig(t);
                        try {
                            o = this.parseDate(i, s, a) || n
                        } catch (t) {
                            s = e ? "" : s
                        }
                        t.selectedDay = o.getDate(), t.drawMonth = t.selectedMonth = o.getMonth(), t.drawYear = t.selectedYear = o.getFullYear(), t.currentDay = s ? o.getDate() : 0, t.currentMonth = s ? o.getMonth() : 0, t.currentYear = s ? o.getFullYear() : 0, this._adjustInstDate(t)
                    }
                },
                _getDefaultDate: function(t) {
                    return this._restrictMinMax(t, this._determineDate(t, this._get(t, "defaultDate"), new Date))
                },
                _determineDate: function(r, t, e) {
                    var i, s, t = null == t || "" === t ? e : "string" == typeof t ? function(t) {
                        try {
                            return V.datepicker.parseDate(V.datepicker._get(r, "dateFormat"), t, V.datepicker._getFormatConfig(r))
                        } catch (t) {}
                        for (var e = (t.toLowerCase().match(/^c/) ? V.datepicker._getDate(r) : null) || new Date, i = e.getFullYear(), s = e.getMonth(), n = e.getDate(), o = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, a = o.exec(t); a;) {
                            switch (a[2] || "d") {
                                case "d":
                                case "D":
                                    n += parseInt(a[1], 10);
                                    break;
                                case "w":
                                case "W":
                                    n += 7 * parseInt(a[1], 10);
                                    break;
                                case "m":
                                case "M":
                                    s += parseInt(a[1], 10), n = Math.min(n, V.datepicker._getDaysInMonth(i, s));
                                    break;
                                case "y":
                                case "Y":
                                    i += parseInt(a[1], 10), n = Math.min(n, V.datepicker._getDaysInMonth(i, s))
                            }
                            a = o.exec(t)
                        }
                        return new Date(i, s, n)
                    }(t) : "number" == typeof t ? isNaN(t) ? e : (i = t, (s = new Date).setDate(s.getDate() + i), s) : new Date(t.getTime());
                    return (t = t && "Invalid Date" === t.toString() ? e : t) && (t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)), this._daylightSavingAdjust(t)
                },
                _daylightSavingAdjust: function(t) {
                    return t ? (t.setHours(12 < t.getHours() ? t.getHours() + 2 : 0), t) : null
                },
                _setDate: function(t, e, i) {
                    var s = !e,
                        n = t.selectedMonth,
                        o = t.selectedYear,
                        e = this._restrictMinMax(t, this._determineDate(t, e, new Date));
                    t.selectedDay = t.currentDay = e.getDate(), t.drawMonth = t.selectedMonth = t.currentMonth = e.getMonth(), t.drawYear = t.selectedYear = t.currentYear = e.getFullYear(), n === t.selectedMonth && o === t.selectedYear || i || this._notifyChange(t), this._adjustInstDate(t), t.input && t.input.val(s ? "" : this._formatDate(t))
                },
                _getDate: function(t) {
                    return !t.currentYear || t.input && "" === t.input.val() ? null : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay))
                },
                _attachHandlers: function(t) {
                    var e = this._get(t, "stepMonths"),
                        i = "#" + t.id.replace(/\\\\/g, "\\");
                    t.dpDiv.find("[data-handler]").map(function() {
                        var t = {
                            prev: function() {
                                V.datepicker._adjustDate(i, -e, "M")
                            },
                            next: function() {
                                V.datepicker._adjustDate(i, +e, "M")
                            },
                            hide: function() {
                                V.datepicker._hideDatepicker()
                            },
                            today: function() {
                                V.datepicker._gotoToday(i)
                            },
                            selectDay: function() {
                                return V.datepicker._selectDay(i, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
                            },
                            selectMonth: function() {
                                return V.datepicker._selectMonthYear(i, this, "M"), !1
                            },
                            selectYear: function() {
                                return V.datepicker._selectMonthYear(i, this, "Y"), !1
                            }
                        };
                        V(this).on(this.getAttribute("data-event"), t[this.getAttribute("data-handler")])
                    })
                },
                _generateHTML: function(t) {
                    var e, i, s, n, o, a, r, l, h, c, u, d, p, f, g, m, _, v, b, y, w, x, k, C, D, I, T, P, M, S, H, z, A = new Date,
                        O = this._daylightSavingAdjust(new Date(A.getFullYear(), A.getMonth(), A.getDate())),
                        N = this._get(t, "isRTL"),
                        E = this._get(t, "showButtonPanel"),
                        W = this._get(t, "hideIfNoPrevNext"),
                        F = this._get(t, "navigationAsDateFormat"),
                        L = this._getNumberOfMonths(t),
                        R = this._get(t, "showCurrentAtPos"),
                        A = this._get(t, "stepMonths"),
                        Y = 1 !== L[0] || 1 !== L[1],
                        B = this._daylightSavingAdjust(t.currentDay ? new Date(t.currentYear, t.currentMonth, t.currentDay) : new Date(9999, 9, 9)),
                        j = this._getMinMaxDate(t, "min"),
                        q = this._getMinMaxDate(t, "max"),
                        K = t.drawMonth - R,
                        U = t.drawYear;
                    if (K < 0 && (K += 12, U--), q)
                        for (e = this._daylightSavingAdjust(new Date(q.getFullYear(), q.getMonth() - L[0] * L[1] + 1, q.getDate())), e = j && e < j ? j : e; this._daylightSavingAdjust(new Date(U, K, 1)) > e;) --K < 0 && (K = 11, U--);
                    for (t.drawMonth = K, t.drawYear = U, R = this._get(t, "prevText"), R = F ? this.formatDate(R, this._daylightSavingAdjust(new Date(U, K - A, 1)), this._getFormatConfig(t)) : R, i = this._canAdjustMonth(t, -1, U, K) ? V("<a>").attr({
                            class: "ui-datepicker-prev ui-corner-all",
                            "data-handler": "prev",
                            "data-event": "click",
                            title: R
                        }).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (N ? "e" : "w")).text(R))[0].outerHTML : W ? "" : V("<a>").attr({
                            class: "ui-datepicker-prev ui-corner-all ui-state-disabled",
                            title: R
                        }).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (N ? "e" : "w")).text(R))[0].outerHTML, R = this._get(t, "nextText"), R = F ? this.formatDate(R, this._daylightSavingAdjust(new Date(U, K + A, 1)), this._getFormatConfig(t)) : R, s = this._canAdjustMonth(t, 1, U, K) ? V("<a>").attr({
                            class: "ui-datepicker-next ui-corner-all",
                            "data-handler": "next",
                            "data-event": "click",
                            title: R
                        }).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-" + (N ? "w" : "e")).text(R))[0].outerHTML : W ? "" : V("<a>").attr({
                            class: "ui-datepicker-next ui-corner-all ui-state-disabled",
                            title: R
                        }).append(V("<span>").attr("class", "ui-icon ui-icon-circle-triangle-" + (N ? "w" : "e")).text(R))[0].outerHTML, A = this._get(t, "currentText"), W = this._get(t, "gotoCurrent") && t.currentDay ? B : O, A = F ? this.formatDate(A, W, this._getFormatConfig(t)) : A, R = "", t.inline || (R = V("<button>").attr({
                            type: "button",
                            class: "ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all",
                            "data-handler": "hide",
                            "data-event": "click"
                        }).text(this._get(t, "closeText"))[0].outerHTML), F = "", E && (F = V("<div class='ui-datepicker-buttonpane ui-widget-content'>").append(N ? R : "").append(this._isInRange(t, W) ? V("<button>").attr({
                            type: "button",
                            class: "ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all",
                            "data-handler": "today",
                            "data-event": "click"
                        }).text(A) : "").append(N ? "" : R)[0].outerHTML), n = parseInt(this._get(t, "firstDay"), 10), n = isNaN(n) ? 0 : n, o = this._get(t, "showWeek"), a = this._get(t, "dayNames"), r = this._get(t, "dayNamesMin"), l = this._get(t, "monthNames"), h = this._get(t, "monthNamesShort"), c = this._get(t, "beforeShowDay"), u = this._get(t, "showOtherMonths"), d = this._get(t, "selectOtherMonths"), p = this._getDefaultDate(t), f = "", m = 0; m < L[0]; m++) {
                        for (_ = "", this.maxRows = 4, v = 0; v < L[1]; v++) {
                            if (b = this._daylightSavingAdjust(new Date(U, K, t.selectedDay)), y = " ui-corner-all", w = "", Y) {
                                if (w += "<div class='ui-datepicker-group", 1 < L[1]) switch (v) {
                                    case 0:
                                        w += " ui-datepicker-group-first", y = " ui-corner-" + (N ? "right" : "left");
                                        break;
                                    case L[1] - 1:
                                        w += " ui-datepicker-group-last", y = " ui-corner-" + (N ? "left" : "right");
                                        break;
                                    default:
                                        w += " ui-datepicker-group-middle", y = ""
                                }
                                w += "'>"
                            }
                            for (w += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + y + "'>" + (/all|left/.test(y) && 0 === m ? N ? s : i : "") + (/all|right/.test(y) && 0 === m ? N ? i : s : "") + this._generateMonthYearHeader(t, K, U, j, q, 0 < m || 0 < v, l, h) + "</div><table class='ui-datepicker-calendar'><thead><tr>", x = o ? "<th class='ui-datepicker-week-col'>" + this._get(t, "weekHeader") + "</th>" : "", g = 0; g < 7; g++) x += "<th scope='col'" + (5 <= (g + n + 6) % 7 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + a[k = (g + n) % 7] + "'>" + r[k] + "</span></th>";
                            for (w += x + "</tr></thead><tbody>", D = this._getDaysInMonth(U, K), U === t.selectedYear && K === t.selectedMonth && (t.selectedDay = Math.min(t.selectedDay, D)), C = (this._getFirstDayOfMonth(U, K) - n + 7) % 7, D = Math.ceil((C + D) / 7), I = Y && this.maxRows > D ? this.maxRows : D, this.maxRows = I, T = this._daylightSavingAdjust(new Date(U, K, 1 - C)), P = 0; P < I; P++) {
                                for (w += "<tr>", M = o ? "<td class='ui-datepicker-week-col'>" + this._get(t, "calculateWeek")(T) + "</td>" : "", g = 0; g < 7; g++) S = c ? c.apply(t.input ? t.input[0] : null, [T]) : [!0, ""], z = (H = T.getMonth() !== K) && !d || !S[0] || j && T < j || q && q < T, M += "<td class='" + (5 <= (g + n + 6) % 7 ? " ui-datepicker-week-end" : "") + (H ? " ui-datepicker-other-month" : "") + (T.getTime() === b.getTime() && K === t.selectedMonth && t._keyEvent || p.getTime() === T.getTime() && p.getTime() === b.getTime() ? " " + this._dayOverClass : "") + (z ? " " + this._unselectableClass + " ui-state-disabled" : "") + (H && !u ? "" : " " + S[1] + (T.getTime() === B.getTime() ? " " + this._currentClass : "") + (T.getTime() === O.getTime() ? " ui-datepicker-today" : "")) + "'" + (H && !u || !S[2] ? "" : " title='" + S[2].replace(/'/g, "&#39;") + "'") + (z ? "" : " data-handler='selectDay' data-event='click' data-month='" + T.getMonth() + "' data-year='" + T.getFullYear() + "'") + ">" + (H && !u ? "&#xa0;" : z ? "<span class='ui-state-default'>" + T.getDate() + "</span>" : "<a class='ui-state-default" + (T.getTime() === O.getTime() ? " ui-state-highlight" : "") + (T.getTime() === B.getTime() ? " ui-state-active" : "") + (H ? " ui-priority-secondary" : "") + "' href='#' aria-current='" + (T.getTime() === B.getTime() ? "true" : "false") + "' data-date='" + T.getDate() + "'>" + T.getDate() + "</a>") + "</td>", T.setDate(T.getDate() + 1), T = this._daylightSavingAdjust(T);
                                w += M + "</tr>"
                            }
                            11 < ++K && (K = 0, U++), _ += w += "</tbody></table>" + (Y ? "</div>" + (0 < L[0] && v === L[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "")
                        }
                        f += _
                    }
                    return f += F, t._keyEvent = !1, f
                },
                _generateMonthYearHeader: function(t, e, i, s, n, o, a, r) {
                    var l, h, c, u, d, p, f = this._get(t, "changeMonth"),
                        g = this._get(t, "changeYear"),
                        m = this._get(t, "showMonthAfterYear"),
                        _ = this._get(t, "selectMonthLabel"),
                        v = this._get(t, "selectYearLabel"),
                        b = "<div class='ui-datepicker-title'>",
                        y = "";
                    if (o || !f) y += "<span class='ui-datepicker-month'>" + a[e] + "</span>";
                    else {
                        for (l = s && s.getFullYear() === i, h = n && n.getFullYear() === i, y += "<select class='ui-datepicker-month' aria-label='" + _ + "' data-handler='selectMonth' data-event='change'>", c = 0; c < 12; c++)(!l || c >= s.getMonth()) && (!h || c <= n.getMonth()) && (y += "<option value='" + c + "'" + (c === e ? " selected='selected'" : "") + ">" + r[c] + "</option>");
                        y += "</select>"
                    }
                    if (m || (b += y + (!o && f && g ? "" : "&#xa0;")), !t.yearshtml)
                        if (t.yearshtml = "", o || !g) b += "<span class='ui-datepicker-year'>" + i + "</span>";
                        else {
                            for (a = this._get(t, "yearRange").split(":"), u = (new Date).getFullYear(), d = (_ = function(t) {
                                    t = t.match(/c[+\-].*/) ? i + parseInt(t.substring(1), 10) : t.match(/[+\-].*/) ? u + parseInt(t, 10) : parseInt(t, 10);
                                    return isNaN(t) ? u : t
                                })(a[0]), p = Math.max(d, _(a[1] || "")), d = s ? Math.max(d, s.getFullYear()) : d, p = n ? Math.min(p, n.getFullYear()) : p, t.yearshtml += "<select class='ui-datepicker-year' aria-label='" + v + "' data-handler='selectYear' data-event='change'>"; d <= p; d++) t.yearshtml += "<option value='" + d + "'" + (d === i ? " selected='selected'" : "") + ">" + d + "</option>";
                            t.yearshtml += "</select>", b += t.yearshtml, t.yearshtml = null
                        }
                    return b += this._get(t, "yearSuffix"), m && (b += (!o && f && g ? "" : "&#xa0;") + y), b += "</div>"
                },
                _adjustInstDate: function(t, e, i) {
                    var s = t.selectedYear + ("Y" === i ? e : 0),
                        n = t.selectedMonth + ("M" === i ? e : 0),
                        e = Math.min(t.selectedDay, this._getDaysInMonth(s, n)) + ("D" === i ? e : 0),
                        e = this._restrictMinMax(t, this._daylightSavingAdjust(new Date(s, n, e)));
                    t.selectedDay = e.getDate(), t.drawMonth = t.selectedMonth = e.getMonth(), t.drawYear = t.selectedYear = e.getFullYear(), "M" !== i && "Y" !== i || this._notifyChange(t)
                },
                _restrictMinMax: function(t, e) {
                    var i = this._getMinMaxDate(t, "min"),
                        t = this._getMinMaxDate(t, "max"),
                        e = i && e < i ? i : e;
                    return t && t < e ? t : e
                },
                _notifyChange: function(t) {
                    var e = this._get(t, "onChangeMonthYear");
                    e && e.apply(t.input ? t.input[0] : null, [t.selectedYear, t.selectedMonth + 1, t])
                },
                _getNumberOfMonths: function(t) {
                    t = this._get(t, "numberOfMonths");
                    return null == t ? [1, 1] : "number" == typeof t ? [1, t] : t
                },
                _getMinMaxDate: function(t, e) {
                    return this._determineDate(t, this._get(t, e + "Date"), null)
                },
                _getDaysInMonth: function(t, e) {
                    return 32 - this._daylightSavingAdjust(new Date(t, e, 32)).getDate()
                },
                _getFirstDayOfMonth: function(t, e) {
                    return new Date(t, e, 1).getDay()
                },
                _canAdjustMonth: function(t, e, i, s) {
                    var n = this._getNumberOfMonths(t),
                        n = this._daylightSavingAdjust(new Date(i, s + (e < 0 ? e : n[0] * n[1]), 1));
                    return e < 0 && n.setDate(this._getDaysInMonth(n.getFullYear(), n.getMonth())), this._isInRange(t, n)
                },
                _isInRange: function(t, e) {
                    var i = this._getMinMaxDate(t, "min"),
                        s = this._getMinMaxDate(t, "max"),
                        n = null,
                        o = null,
                        a = this._get(t, "yearRange");
                    return a && (t = a.split(":"), a = (new Date).getFullYear(), n = parseInt(t[0], 10), o = parseInt(t[1], 10), t[0].match(/[+\-].*/) && (n += a), t[1].match(/[+\-].*/) && (o += a)), (!i || e.getTime() >= i.getTime()) && (!s || e.getTime() <= s.getTime()) && (!n || e.getFullYear() >= n) && (!o || e.getFullYear() <= o)
                },
                _getFormatConfig: function(t) {
                    var e = this._get(t, "shortYearCutoff");
                    return {
                        shortYearCutoff: e = "string" != typeof e ? e : (new Date).getFullYear() % 100 + parseInt(e, 10),
                        dayNamesShort: this._get(t, "dayNamesShort"),
                        dayNames: this._get(t, "dayNames"),
                        monthNamesShort: this._get(t, "monthNamesShort"),
                        monthNames: this._get(t, "monthNames")
                    }
                },
                _formatDate: function(t, e, i, s) {
                    e || (t.currentDay = t.selectedDay, t.currentMonth = t.selectedMonth, t.currentYear = t.selectedYear);
                    e = e ? "object" == typeof e ? e : this._daylightSavingAdjust(new Date(s, i, e)) : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay));
                    return this.formatDate(this._get(t, "dateFormat"), e, this._getFormatConfig(t))
                }
            }), V.fn.datepicker = function(t) {
                if (!this.length) return this;
                V.datepicker.initialized || (V(document).on("mousedown", V.datepicker._checkExternalClick), V.datepicker.initialized = !0), 0 === V("#" + V.datepicker._mainDivId).length && V("body").append(V.datepicker.dpDiv);
                var e = Array.prototype.slice.call(arguments, 1);
                return "string" == typeof t && ("isDisabled" === t || "getDate" === t || "widget" === t) || "option" === t && 2 === arguments.length && "string" == typeof arguments[1] ? V.datepicker["_" + t + "Datepicker"].apply(V.datepicker, [this[0]].concat(e)) : this.each(function() {
                    "string" == typeof t ? V.datepicker["_" + t + "Datepicker"].apply(V.datepicker, [this].concat(e)) : V.datepicker._attachDatepicker(this, t)
                })
            }, V.datepicker = new st, V.datepicker.initialized = !1, V.datepicker.uuid = (new Date).getTime(), V.datepicker.version = "1.13.2";
            V.datepicker, V.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
            var rt = !1;
            V(document).on("mouseup", function() {
                rt = !1
            });
            V.widget("ui.mouse", {
                version: "1.13.2",
                options: {
                    cancel: "input, textarea, button, select, option",
                    distance: 1,
                    delay: 0
                },
                _mouseInit: function() {
                    var e = this;
                    this.element.on("mousedown." + this.widgetName, function(t) {
                        return e._mouseDown(t)
                    }).on("click." + this.widgetName, function(t) {
                        if (!0 === V.data(t.target, e.widgetName + ".preventClickEvent")) return V.removeData(t.target, e.widgetName + ".preventClickEvent"), t.stopImmediatePropagation(), !1
                    }), this.started = !1
                },
                _mouseDestroy: function() {
                    this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate)
                },
                _mouseDown: function(t) {
                    if (!rt) {
                        this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
                        var e = this,
                            i = 1 === t.which,
                            s = !("string" != typeof this.options.cancel || !t.target.nodeName) && V(t.target).closest(this.options.cancel).length;
                        return i && !s && this._mouseCapture(t) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                            e.mouseDelayMet = !0
                        }, this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === V.data(t.target, this.widgetName + ".preventClickEvent") && V.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function(t) {
                            return e._mouseMove(t)
                        }, this._mouseUpDelegate = function(t) {
                            return e._mouseUp(t)
                        }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), rt = !0)) : !0
                    }
                },
                _mouseMove: function(t) {
                    if (this._mouseMoved) {
                        if (V.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
                        if (!t.which)
                            if (t.originalEvent.altKey || t.originalEvent.ctrlKey || t.originalEvent.metaKey || t.originalEvent.shiftKey) this.ignoreMissingWhich = !0;
                            else if (!this.ignoreMissingWhich) return this._mouseUp(t)
                    }
                    return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
                },
                _mouseUp: function(t) {
                    this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && V.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, rt = !1, t.preventDefault()
                },
                _mouseDistanceMet: function(t) {
                    return Math.max(Math.abs(this._mouseDownEvent.pageX - t.pageX), Math.abs(this._mouseDownEvent.pageY - t.pageY)) >= this.options.distance
                },
                _mouseDelayMet: function() {
                    return this.mouseDelayMet
                },
                _mouseStart: function() {},
                _mouseDrag: function() {},
                _mouseStop: function() {},
                _mouseCapture: function() {
                    return !0
                }
            }), V.ui.plugin = {
                add: function(t, e, i) {
                    var s, n = V.ui[t].prototype;
                    for (s in i) n.plugins[s] = n.plugins[s] || [], n.plugins[s].push([e, i[s]])
                },
                call: function(t, e, i, s) {
                    var n, o = t.plugins[e];
                    if (o && (s || t.element[0].parentNode && 11 !== t.element[0].parentNode.nodeType))
                        for (n = 0; n < o.length; n++) t.options[o[n][0]] && o[n][1].apply(t.element, i)
                }
            }, V.ui.safeBlur = function(t) {
                t && "body" !== t.nodeName.toLowerCase() && V(t).trigger("blur")
            };
            V.widget("ui.draggable", V.ui.mouse, {
                version: "1.13.2",
                widgetEventPrefix: "drag",
                options: {
                    addClasses: !0,
                    appendTo: "parent",
                    axis: !1,
                    connectToSortable: !1,
                    containment: !1,
                    cursor: "auto",
                    cursorAt: !1,
                    grid: !1,
                    handle: !1,
                    helper: "original",
                    iframeFix: !1,
                    opacity: !1,
                    refreshPositions: !1,
                    revert: !1,
                    revertDuration: 500,
                    scope: "default",
                    scroll: !0,
                    scrollSensitivity: 20,
                    scrollSpeed: 20,
                    snap: !1,
                    snapMode: "both",
                    snapTolerance: 20,
                    stack: !1,
                    zIndex: !1,
                    drag: null,
                    start: null,
                    stop: null
                },
                _create: function() {
                    "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this._addClass("ui-draggable"), this._setHandleClassName(), this._mouseInit()
                },
                _setOption: function(t, e) {
                    this._super(t, e), "handle" === t && (this._removeHandleClassName(), this._setHandleClassName())
                },
                _destroy: function() {
                    (this.helper || this.element).is(".ui-draggable-dragging") ? this.destroyOnClear = !0 : (this._removeHandleClassName(), this._mouseDestroy())
                },
                _mouseCapture: function(t) {
                    var e = this.options;
                    return !(this.helper || e.disabled || 0 < V(t.target).closest(".ui-resizable-handle").length) && (this.handle = this._getHandle(t), !!this.handle && (this._blurActiveElement(t), this._blockFrames(!0 === e.iframeFix ? "iframe" : e.iframeFix), !0))
                },
                _blockFrames: function(t) {
                    this.iframeBlocks = this.document.find(t).map(function() {
                        var t = V(this);
                        return V("<div>").css("position", "absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]
                    })
                },
                _unblockFrames: function() {
                    this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
                },
                _blurActiveElement: function(t) {
                    var e = V.ui.safeActiveElement(this.document[0]);
                    V(t.target).closest(e).length || V.ui.safeBlur(e)
                },
                _mouseStart: function(t) {
                    var e = this.options;
                    return this.helper = this._createHelper(t), this._addClass(this.helper, "ui-draggable-dragging"), this._cacheHelperProportions(), V.ui.ddmanager && (V.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = 0 < this.helper.parents().filter(function() {
                        return "fixed" === V(this).css("position")
                    }).length, this.positionAbs = this.element.offset(), this._refreshOffsets(t), this.originalPosition = this.position = this._generatePosition(t, !1), this.originalPageX = t.pageX, this.originalPageY = t.pageY, e.cursorAt && this._adjustOffsetFromHelper(e.cursorAt), this._setContainment(), !1 === this._trigger("start", t) ? (this._clear(), !1) : (this._cacheHelperProportions(), V.ui.ddmanager && !e.dropBehaviour && V.ui.ddmanager.prepareOffsets(this, t), this._mouseDrag(t, !0), V.ui.ddmanager && V.ui.ddmanager.dragStart(this, t), !0)
                },
                _refreshOffsets: function(t) {
                    this.offset = {
                        top: this.positionAbs.top - this.margins.top,
                        left: this.positionAbs.left - this.margins.left,
                        scroll: !1,
                        parent: this._getParentOffset(),
                        relative: this._getRelativeOffset()
                    }, this.offset.click = {
                        left: t.pageX - this.offset.left,
                        top: t.pageY - this.offset.top
                    }
                },
                _mouseDrag: function(t, e) {
                    if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(t, !0), this.positionAbs = this._convertPositionTo("absolute"), !e) {
                        e = this._uiHash();
                        if (!1 === this._trigger("drag", t, e)) return this._mouseUp(new V.Event("mouseup", t)), !1;
                        this.position = e.position
                    }
                    return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", V.ui.ddmanager && V.ui.ddmanager.drag(this, t), !1
                },
                _mouseStop: function(t) {
                    var e = this,
                        i = !1;
                    return V.ui.ddmanager && !this.options.dropBehaviour && (i = V.ui.ddmanager.drop(this, t)), this.dropped && (i = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !i || "valid" === this.options.revert && i || !0 === this.options.revert || "function" == typeof this.options.revert && this.options.revert.call(this.element, i) ? V(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                        !1 !== e._trigger("stop", t) && e._clear()
                    }) : !1 !== this._trigger("stop", t) && this._clear(), !1
                },
                _mouseUp: function(t) {
                    return this._unblockFrames(), V.ui.ddmanager && V.ui.ddmanager.dragStop(this, t), this.handleElement.is(t.target) && this.element.trigger("focus"), V.ui.mouse.prototype._mouseUp.call(this, t)
                },
                cancel: function() {
                    return this.helper.is(".ui-draggable-dragging") ? this._mouseUp(new V.Event("mouseup", {
                        target: this.element[0]
                    })) : this._clear(), this
                },
                _getHandle: function(t) {
                    return !this.options.handle || !!V(t.target).closest(this.element.find(this.options.handle)).length
                },
                _setHandleClassName: function() {
                    this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this._addClass(this.handleElement, "ui-draggable-handle")
                },
                _removeHandleClassName: function() {
                    this._removeClass(this.handleElement, "ui-draggable-handle")
                },
                _createHelper: function(t) {
                    var e = this.options,
                        i = "function" == typeof e.helper,
                        t = i ? V(e.helper.apply(this.element[0], [t])) : "clone" === e.helper ? this.element.clone().removeAttr("id") : this.element;
                    return t.parents("body").length || t.appendTo("parent" === e.appendTo ? this.element[0].parentNode : e.appendTo), i && t[0] === this.element[0] && this._setPositionRelative(), t[0] === this.element[0] || /(fixed|absolute)/.test(t.css("position")) || t.css("position", "absolute"), t
                },
                _setPositionRelative: function() {
                    /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative")
                },
                _adjustOffsetFromHelper: function(t) {
                    "string" == typeof t && (t = t.split(" ")), "left" in (t = Array.isArray(t) ? {
                        left: +t[0],
                        top: +t[1] || 0
                    } : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
                },
                _isRootNode: function(t) {
                    return /(html|body)/i.test(t.tagName) || t === this.document[0]
                },
                _getParentOffset: function() {
                    var t = this.offsetParent.offset(),
                        e = this.document[0];
                    return "absolute" === this.cssPosition && this.scrollParent[0] !== e && V.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), {
                        top: (t = this._isRootNode(this.offsetParent[0]) ? {
                            top: 0,
                            left: 0
                        } : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                        left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    }
                },
                _getRelativeOffset: function() {
                    if ("relative" !== this.cssPosition) return {
                        top: 0,
                        left: 0
                    };
                    var t = this.element.position(),
                        e = this._isRootNode(this.scrollParent[0]);
                    return {
                        top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + (e ? 0 : this.scrollParent.scrollTop()),
                        left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + (e ? 0 : this.scrollParent.scrollLeft())
                    }
                },
                _cacheMargins: function() {
                    this.margins = {
                        left: parseInt(this.element.css("marginLeft"), 10) || 0,
                        top: parseInt(this.element.css("marginTop"), 10) || 0,
                        right: parseInt(this.element.css("marginRight"), 10) || 0,
                        bottom: parseInt(this.element.css("marginBottom"), 10) || 0
                    }
                },
                _cacheHelperProportions: function() {
                    this.helperProportions = {
                        width: this.helper.outerWidth(),
                        height: this.helper.outerHeight()
                    }
                },
                _setContainment: function() {
                    var t, e, i, s = this.options,
                        n = this.document[0];
                    this.relativeContainer = null, s.containment ? "window" !== s.containment ? "document" !== s.containment ? s.containment.constructor !== Array ? ("parent" === s.containment && (s.containment = this.helper[0].parentNode), (i = (e = V(s.containment))[0]) && (t = /(scroll|auto)/.test(e.css("overflow")), this.containment = [(parseInt(e.css("borderLeftWidth"), 10) || 0) + (parseInt(e.css("paddingLeft"), 10) || 0), (parseInt(e.css("borderTopWidth"), 10) || 0) + (parseInt(e.css("paddingTop"), 10) || 0), (t ? Math.max(i.scrollWidth, i.offsetWidth) : i.offsetWidth) - (parseInt(e.css("borderRightWidth"), 10) || 0) - (parseInt(e.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t ? Math.max(i.scrollHeight, i.offsetHeight) : i.offsetHeight) - (parseInt(e.css("borderBottomWidth"), 10) || 0) - (parseInt(e.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = e)) : this.containment = s.containment : this.containment = [0, 0, V(n).width() - this.helperProportions.width - this.margins.left, (V(n).height() || n.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : this.containment = [V(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, V(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, V(window).scrollLeft() + V(window).width() - this.helperProportions.width - this.margins.left, V(window).scrollTop() + (V(window).height() || n.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : this.containment = null
                },
                _convertPositionTo: function(t, e) {
                    e = e || this.position;
                    var i = "absolute" === t ? 1 : -1,
                        t = this._isRootNode(this.scrollParent[0]);
                    return {
                        top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : t ? 0 : this.offset.scroll.top) * i,
                        left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : t ? 0 : this.offset.scroll.left) * i
                    }
                },
                _generatePosition: function(t, e) {
                    var i, s = this.options,
                        n = this._isRootNode(this.scrollParent[0]),
                        o = t.pageX,
                        a = t.pageY;
                    return n && this.offset.scroll || (this.offset.scroll = {
                        top: this.scrollParent.scrollTop(),
                        left: this.scrollParent.scrollLeft()
                    }), e && (this.containment && (i = this.relativeContainer ? (i = this.relativeContainer.offset(), [this.containment[0] + i.left, this.containment[1] + i.top, this.containment[2] + i.left, this.containment[3] + i.top]) : this.containment, t.pageX - this.offset.click.left < i[0] && (o = i[0] + this.offset.click.left), t.pageY - this.offset.click.top < i[1] && (a = i[1] + this.offset.click.top), t.pageX - this.offset.click.left > i[2] && (o = i[2] + this.offset.click.left), t.pageY - this.offset.click.top > i[3] && (a = i[3] + this.offset.click.top)), s.grid && (t = s.grid[1] ? this.originalPageY + Math.round((a - this.originalPageY) / s.grid[1]) * s.grid[1] : this.originalPageY, a = !i || t - this.offset.click.top >= i[1] || t - this.offset.click.top > i[3] ? t : t - this.offset.click.top >= i[1] ? t - s.grid[1] : t + s.grid[1], t = s.grid[0] ? this.originalPageX + Math.round((o - this.originalPageX) / s.grid[0]) * s.grid[0] : this.originalPageX, o = !i || t - this.offset.click.left >= i[0] || t - this.offset.click.left > i[2] ? t : t - this.offset.click.left >= i[0] ? t - s.grid[0] : t + s.grid[0]), "y" === s.axis && (o = this.originalPageX), "x" === s.axis && (a = this.originalPageY)), {
                        top: a - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : n ? 0 : this.offset.scroll.top),
                        left: o - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : n ? 0 : this.offset.scroll.left)
                    }
                },
                _clear: function() {
                    this._removeClass(this.helper, "ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy()
                },
                _trigger: function(t, e, i) {
                    return i = i || this._uiHash(), V.ui.plugin.call(this, t, [e, i, this], !0), /^(drag|start|stop)/.test(t) && (this.positionAbs = this._convertPositionTo("absolute"), i.offset = this.positionAbs), V.Widget.prototype._trigger.call(this, t, e, i)
                },
                plugins: {},
                _uiHash: function() {
                    return {
                        helper: this.helper,
                        position: this.position,
                        originalPosition: this.originalPosition,
                        offset: this.positionAbs
                    }
                }
            }), V.ui.plugin.add("draggable", "connectToSortable", {
                start: function(e, t, i) {
                    var s = V.extend({}, t, {
                        item: i.element
                    });
                    i.sortables = [], V(i.options.connectToSortable).each(function() {
                        var t = V(this).sortable("instance");
                        t && !t.options.disabled && (i.sortables.push(t), t.refreshPositions(), t._trigger("activate", e, s))
                    })
                },
                stop: function(e, t, i) {
                    var s = V.extend({}, t, {
                        item: i.element
                    });
                    i.cancelHelperRemoval = !1, V.each(i.sortables, function() {
                        var t = this;
                        t.isOver ? (t.isOver = 0, i.cancelHelperRemoval = !0, t.cancelHelperRemoval = !1, t._storedCSS = {
                            position: t.placeholder.css("position"),
                            top: t.placeholder.css("top"),
                            left: t.placeholder.css("left")
                        }, t._mouseStop(e), t.options.helper = t.options._helper) : (t.cancelHelperRemoval = !0, t._trigger("deactivate", e, s))
                    })
                },
                drag: function(i, s, n) {
                    V.each(n.sortables, function() {
                        var t = !1,
                            e = this;
                        e.positionAbs = n.positionAbs, e.helperProportions = n.helperProportions, e.offset.click = n.offset.click, e._intersectsWith(e.containerCache) && (t = !0, V.each(n.sortables, function() {
                            return this.positionAbs = n.positionAbs, this.helperProportions = n.helperProportions, this.offset.click = n.offset.click, t = this !== e && this._intersectsWith(this.containerCache) && V.contains(e.element[0], this.element[0]) ? !1 : t
                        })), t ? (e.isOver || (e.isOver = 1, n._parent = s.helper.parent(), e.currentItem = s.helper.appendTo(e.element).data("ui-sortable-item", !0), e.options._helper = e.options.helper, e.options.helper = function() {
                            return s.helper[0]
                        }, i.target = e.currentItem[0], e._mouseCapture(i, !0), e._mouseStart(i, !0, !0), e.offset.click.top = n.offset.click.top, e.offset.click.left = n.offset.click.left, e.offset.parent.left -= n.offset.parent.left - e.offset.parent.left, e.offset.parent.top -= n.offset.parent.top - e.offset.parent.top, n._trigger("toSortable", i), n.dropped = e.element, V.each(n.sortables, function() {
                            this.refreshPositions()
                        }), n.currentItem = n.element, e.fromOutside = n), e.currentItem && (e._mouseDrag(i), s.position = e.position)) : e.isOver && (e.isOver = 0, e.cancelHelperRemoval = !0, e.options._revert = e.options.revert, e.options.revert = !1, e._trigger("out", i, e._uiHash(e)), e._mouseStop(i, !0), e.options.revert = e.options._revert, e.options.helper = e.options._helper, e.placeholder && e.placeholder.remove(), s.helper.appendTo(n._parent), n._refreshOffsets(i), s.position = n._generatePosition(i, !0), n._trigger("fromSortable", i), n.dropped = !1, V.each(n.sortables, function() {
                            this.refreshPositions()
                        }))
                    })
                }
            }), V.ui.plugin.add("draggable", "cursor", {
                start: function(t, e, i) {
                    var s = V("body"),
                        i = i.options;
                    s.css("cursor") && (i._cursor = s.css("cursor")), s.css("cursor", i.cursor)
                },
                stop: function(t, e, i) {
                    i = i.options;
                    i._cursor && V("body").css("cursor", i._cursor)
                }
            }), V.ui.plugin.add("draggable", "opacity", {
                start: function(t, e, i) {
                    e = V(e.helper), i = i.options;
                    e.css("opacity") && (i._opacity = e.css("opacity")), e.css("opacity", i.opacity)
                },
                stop: function(t, e, i) {
                    i = i.options;
                    i._opacity && V(e.helper).css("opacity", i._opacity)
                }
            }), V.ui.plugin.add("draggable", "scroll", {
                start: function(t, e, i) {
                    i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset())
                },
                drag: function(t, e, i) {
                    var s = i.options,
                        n = !1,
                        o = i.scrollParentNotHidden[0],
                        a = i.document[0];
                    o !== a && "HTML" !== o.tagName ? (s.axis && "x" === s.axis || (i.overflowOffset.top + o.offsetHeight - t.pageY < s.scrollSensitivity ? o.scrollTop = n = o.scrollTop + s.scrollSpeed : t.pageY - i.overflowOffset.top < s.scrollSensitivity && (o.scrollTop = n = o.scrollTop - s.scrollSpeed)), s.axis && "y" === s.axis || (i.overflowOffset.left + o.offsetWidth - t.pageX < s.scrollSensitivity ? o.scrollLeft = n = o.scrollLeft + s.scrollSpeed : t.pageX - i.overflowOffset.left < s.scrollSensitivity && (o.scrollLeft = n = o.scrollLeft - s.scrollSpeed))) : (s.axis && "x" === s.axis || (t.pageY - V(a).scrollTop() < s.scrollSensitivity ? n = V(a).scrollTop(V(a).scrollTop() - s.scrollSpeed) : V(window).height() - (t.pageY - V(a).scrollTop()) < s.scrollSensitivity && (n = V(a).scrollTop(V(a).scrollTop() + s.scrollSpeed))), s.axis && "y" === s.axis || (t.pageX - V(a).scrollLeft() < s.scrollSensitivity ? n = V(a).scrollLeft(V(a).scrollLeft() - s.scrollSpeed) : V(window).width() - (t.pageX - V(a).scrollLeft()) < s.scrollSensitivity && (n = V(a).scrollLeft(V(a).scrollLeft() + s.scrollSpeed)))), !1 !== n && V.ui.ddmanager && !s.dropBehaviour && V.ui.ddmanager.prepareOffsets(i, t)
                }
            }), V.ui.plugin.add("draggable", "snap", {
                start: function(t, e, i) {
                    var s = i.options;
                    i.snapElements = [], V(s.snap.constructor !== String ? s.snap.items || ":data(ui-draggable)" : s.snap).each(function() {
                        var t = V(this),
                            e = t.offset();
                        this !== i.element[0] && i.snapElements.push({
                            item: this,
                            width: t.outerWidth(),
                            height: t.outerHeight(),
                            top: e.top,
                            left: e.left
                        })
                    })
                },
                drag: function(t, e, i) {
                    for (var s, n, o, a, r, l, h, c, u, d = i.options, p = d.snapTolerance, f = e.offset.left, g = f + i.helperProportions.width, m = e.offset.top, _ = m + i.helperProportions.height, v = i.snapElements.length - 1; 0 <= v; v--) l = (r = i.snapElements[v].left - i.margins.left) + i.snapElements[v].width, c = (h = i.snapElements[v].top - i.margins.top) + i.snapElements[v].height, g < r - p || l + p < f || _ < h - p || c + p < m || !V.contains(i.snapElements[v].item.ownerDocument, i.snapElements[v].item) ? (i.snapElements[v].snapping && i.options.snap.release && i.options.snap.release.call(i.element, t, V.extend(i._uiHash(), {
                        snapItem: i.snapElements[v].item
                    })), i.snapElements[v].snapping = !1) : ("inner" !== d.snapMode && (s = Math.abs(h - _) <= p, n = Math.abs(c - m) <= p, o = Math.abs(r - g) <= p, a = Math.abs(l - f) <= p, s && (e.position.top = i._convertPositionTo("relative", {
                        top: h - i.helperProportions.height,
                        left: 0
                    }).top), n && (e.position.top = i._convertPositionTo("relative", {
                        top: c,
                        left: 0
                    }).top), o && (e.position.left = i._convertPositionTo("relative", {
                        top: 0,
                        left: r - i.helperProportions.width
                    }).left), a && (e.position.left = i._convertPositionTo("relative", {
                        top: 0,
                        left: l
                    }).left)), u = s || n || o || a, "outer" !== d.snapMode && (s = Math.abs(h - m) <= p, n = Math.abs(c - _) <= p, o = Math.abs(r - f) <= p, a = Math.abs(l - g) <= p, s && (e.position.top = i._convertPositionTo("relative", {
                        top: h,
                        left: 0
                    }).top), n && (e.position.top = i._convertPositionTo("relative", {
                        top: c - i.helperProportions.height,
                        left: 0
                    }).top), o && (e.position.left = i._convertPositionTo("relative", {
                        top: 0,
                        left: r
                    }).left), a && (e.position.left = i._convertPositionTo("relative", {
                        top: 0,
                        left: l - i.helperProportions.width
                    }).left)), !i.snapElements[v].snapping && (s || n || o || a || u) && i.options.snap.snap && i.options.snap.snap.call(i.element, t, V.extend(i._uiHash(), {
                        snapItem: i.snapElements[v].item
                    })), i.snapElements[v].snapping = s || n || o || a || u)
                }
            }), V.ui.plugin.add("draggable", "stack", {
                start: function(t, e, i) {
                    var s, i = i.options,
                        i = V.makeArray(V(i.stack)).sort(function(t, e) {
                            return (parseInt(V(t).css("zIndex"), 10) || 0) - (parseInt(V(e).css("zIndex"), 10) || 0)
                        });
                    i.length && (s = parseInt(V(i[0]).css("zIndex"), 10) || 0, V(i).each(function(t) {
                        V(this).css("zIndex", s + t)
                    }), this.css("zIndex", s + i.length))
                }
            }), V.ui.plugin.add("draggable", "zIndex", {
                start: function(t, e, i) {
                    e = V(e.helper), i = i.options;
                    e.css("zIndex") && (i._zIndex = e.css("zIndex")), e.css("zIndex", i.zIndex)
                },
                stop: function(t, e, i) {
                    i = i.options;
                    i._zIndex && V(e.helper).css("zIndex", i._zIndex)
                }
            });
            V.ui.draggable;
            V.widget("ui.resizable", V.ui.mouse, {
                version: "1.13.2",
                widgetEventPrefix: "resize",
                options: {
                    alsoResize: !1,
                    animate: !1,
                    animateDuration: "slow",
                    animateEasing: "swing",
                    aspectRatio: !1,
                    autoHide: !1,
                    classes: {
                        "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
                    },
                    containment: !1,
                    ghost: !1,
                    grid: !1,
                    handles: "e,s,se",
                    helper: !1,
                    maxHeight: null,
                    maxWidth: null,
                    minHeight: 10,
                    minWidth: 10,
                    zIndex: 90,
                    resize: null,
                    start: null,
                    stop: null
                },
                _num: function(t) {
                    return parseFloat(t) || 0
                },
                _isNumber: function(t) {
                    return !isNaN(parseFloat(t))
                },
                _hasScroll: function(t, e) {
                    if ("hidden" === V(t).css("overflow")) return !1;
                    var i = e && "left" === e ? "scrollLeft" : "scrollTop",
                        e = !1;
                    if (0 < t[i]) return !0;
                    try {
                        t[i] = 1, e = 0 < t[i], t[i] = 0
                    } catch (t) {}
                    return e
                },
                _create: function() {
                    var t, e = this.options,
                        i = this;
                    this._addClass("ui-resizable"), V.extend(this, {
                        _aspectRatio: !!e.aspectRatio,
                        aspectRatio: e.aspectRatio,
                        originalElement: this.element,
                        _proportionallyResizeElements: [],
                        _helper: e.helper || e.ghost || e.animate ? e.helper || "ui-resizable-helper" : null
                    }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(V("<div class='ui-wrapper'></div>").css({
                        overflow: "hidden",
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), this.elementIsWrapper = !0, t = {
                        marginTop: this.originalElement.css("marginTop"),
                        marginRight: this.originalElement.css("marginRight"),
                        marginBottom: this.originalElement.css("marginBottom"),
                        marginLeft: this.originalElement.css("marginLeft")
                    }, this.element.css(t), this.originalElement.css("margin", 0), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
                        position: "static",
                        zoom: 1,
                        display: "block"
                    })), this.originalElement.css(t), this._proportionallyResize()), this._setupHandles(), e.autoHide && V(this.element).on("mouseenter", function() {
                        e.disabled || (i._removeClass("ui-resizable-autohide"), i._handles.show())
                    }).on("mouseleave", function() {
                        e.disabled || i.resizing || (i._addClass("ui-resizable-autohide"), i._handles.hide())
                    }), this._mouseInit()
                },
                _destroy: function() {
                    this._mouseDestroy(), this._addedHandles.remove();

                    function t(t) {
                        V(t).removeData("resizable").removeData("ui-resizable").off(".resizable")
                    }
                    var e;
                    return this.elementIsWrapper && (t(this.element), e = this.element, this.originalElement.css({
                        position: e.css("position"),
                        width: e.outerWidth(),
                        height: e.outerHeight(),
                        top: e.css("top"),
                        left: e.css("left")
                    }).insertAfter(e), e.remove()), this.originalElement.css("resize", this.originalResizeStyle), t(this.originalElement), this
                },
                _setOption: function(t, e) {
                    switch (this._super(t, e), t) {
                        case "handles":
                            this._removeHandles(), this._setupHandles();
                            break;
                        case "aspectRatio":
                            this._aspectRatio = !!e
                    }
                },
                _setupHandles: function() {
                    var t, e, i, s, n, o = this.options,
                        a = this;
                    if (this.handles = o.handles || (V(".ui-resizable-handle", this.element).length ? {
                            n: ".ui-resizable-n",
                            e: ".ui-resizable-e",
                            s: ".ui-resizable-s",
                            w: ".ui-resizable-w",
                            se: ".ui-resizable-se",
                            sw: ".ui-resizable-sw",
                            ne: ".ui-resizable-ne",
                            nw: ".ui-resizable-nw"
                        } : "e,s,se"), this._handles = V(), this._addedHandles = V(), this.handles.constructor === String)
                        for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), i = this.handles.split(","), this.handles = {}, e = 0; e < i.length; e++) s = "ui-resizable-" + (t = String.prototype.trim.call(i[e])), n = V("<div>"), this._addClass(n, "ui-resizable-handle " + s), n.css({
                            zIndex: o.zIndex
                        }), this.handles[t] = ".ui-resizable-" + t, this.element.children(this.handles[t]).length || (this.element.append(n), this._addedHandles = this._addedHandles.add(n));
                    this._renderAxis = function(t) {
                        var e, i, s;
                        for (e in t = t || this.element, this.handles) this.handles[e].constructor === String ? this.handles[e] = this.element.children(this.handles[e]).first().show() : (this.handles[e].jquery || this.handles[e].nodeType) && (this.handles[e] = V(this.handles[e]), this._on(this.handles[e], {
                            mousedown: a._mouseDown
                        })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (i = V(this.handles[e], this.element), s = /sw|ne|nw|se|n|s/.test(e) ? i.outerHeight() : i.outerWidth(), i = ["padding", /ne|nw|n/.test(e) ? "Top" : /se|sw|s/.test(e) ? "Bottom" : /^e$/.test(e) ? "Right" : "Left"].join(""), t.css(i, s), this._proportionallyResize()), this._handles = this._handles.add(this.handles[e])
                    }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), this._handles.disableSelection(), this._handles.on("mouseover", function() {
                        a.resizing || (this.className && (n = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), a.axis = n && n[1] ? n[1] : "se")
                    }), o.autoHide && (this._handles.hide(), this._addClass("ui-resizable-autohide"))
                },
                _removeHandles: function() {
                    this._addedHandles.remove()
                },
                _mouseCapture: function(t) {
                    var e, i, s = !1;
                    for (e in this.handles)(i = V(this.handles[e])[0]) !== t.target && !V.contains(i, t.target) || (s = !0);
                    return !this.options.disabled && s
                },
                _mouseStart: function(t) {
                    var e, i, s = this.options,
                        n = this.element;
                    return this.resizing = !0, this._renderProxy(), e = this._num(this.helper.css("left")), i = this._num(this.helper.css("top")), s.containment && (e += V(s.containment).scrollLeft() || 0, i += V(s.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
                        left: e,
                        top: i
                    }, this.size = this._helper ? {
                        width: this.helper.width(),
                        height: this.helper.height()
                    } : {
                        width: n.width(),
                        height: n.height()
                    }, this.originalSize = this._helper ? {
                        width: n.outerWidth(),
                        height: n.outerHeight()
                    } : {
                        width: n.width(),
                        height: n.height()
                    }, this.sizeDiff = {
                        width: n.outerWidth() - n.width(),
                        height: n.outerHeight() - n.height()
                    }, this.originalPosition = {
                        left: e,
                        top: i
                    }, this.originalMousePosition = {
                        left: t.pageX,
                        top: t.pageY
                    }, this.aspectRatio = "number" == typeof s.aspectRatio ? s.aspectRatio : this.originalSize.width / this.originalSize.height || 1, s = V(".ui-resizable-" + this.axis).css("cursor"), V("body").css("cursor", "auto" === s ? this.axis + "-resize" : s), this._addClass("ui-resizable-resizing"), this._propagate("start", t), !0
                },
                _mouseDrag: function(t) {
                    var e = this.originalMousePosition,
                        i = this.axis,
                        s = t.pageX - e.left || 0,
                        e = t.pageY - e.top || 0,
                        i = this._change[i];
                    return this._updatePrevProperties(), i && (e = i.apply(this, [t, s, e]), this._updateVirtualBoundaries(t.shiftKey), (this._aspectRatio || t.shiftKey) && (e = this._updateRatio(e, t)), e = this._respectSize(e, t), this._updateCache(e), this._propagate("resize", t), e = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), V.isEmptyObject(e) || (this._updatePrevProperties(), this._trigger("resize", t, this.ui()), this._applyChanges())), !1
                },
                _mouseStop: function(t) {
                    this.resizing = !1;
                    var e, i, s, n = this.options,
                        o = this;
                    return this._helper && (s = (e = (i = this._proportionallyResizeElements).length && /textarea/i.test(i[0].nodeName)) && this._hasScroll(i[0], "left") ? 0 : o.sizeDiff.height, i = e ? 0 : o.sizeDiff.width, e = {
                        width: o.helper.width() - i,
                        height: o.helper.height() - s
                    }, i = parseFloat(o.element.css("left")) + (o.position.left - o.originalPosition.left) || null, s = parseFloat(o.element.css("top")) + (o.position.top - o.originalPosition.top) || null, n.animate || this.element.css(V.extend(e, {
                        top: s,
                        left: i
                    })), o.helper.height(o.size.height), o.helper.width(o.size.width), this._helper && !n.animate && this._proportionallyResize()), V("body").css("cursor", "auto"), this._removeClass("ui-resizable-resizing"), this._propagate("stop", t), this._helper && this.helper.remove(), !1
                },
                _updatePrevProperties: function() {
                    this.prevPosition = {
                        top: this.position.top,
                        left: this.position.left
                    }, this.prevSize = {
                        width: this.size.width,
                        height: this.size.height
                    }
                },
                _applyChanges: function() {
                    var t = {};
                    return this.position.top !== this.prevPosition.top && (t.top = this.position.top + "px"), this.position.left !== this.prevPosition.left && (t.left = this.position.left + "px"), this.size.width !== this.prevSize.width && (t.width = this.size.width + "px"), this.size.height !== this.prevSize.height && (t.height = this.size.height + "px"), this.helper.css(t), t
                },
                _updateVirtualBoundaries: function(t) {
                    var e, i, s = this.options,
                        n = {
                            minWidth: this._isNumber(s.minWidth) ? s.minWidth : 0,
                            maxWidth: this._isNumber(s.maxWidth) ? s.maxWidth : 1 / 0,
                            minHeight: this._isNumber(s.minHeight) ? s.minHeight : 0,
                            maxHeight: this._isNumber(s.maxHeight) ? s.maxHeight : 1 / 0
                        };
                    (this._aspectRatio || t) && (e = n.minHeight * this.aspectRatio, i = n.minWidth / this.aspectRatio, s = n.maxHeight * this.aspectRatio, t = n.maxWidth / this.aspectRatio, e > n.minWidth && (n.minWidth = e), i > n.minHeight && (n.minHeight = i), s < n.maxWidth && (n.maxWidth = s), t < n.maxHeight && (n.maxHeight = t)), this._vBoundaries = n
                },
                _updateCache: function(t) {
                    this.offset = this.helper.offset(), this._isNumber(t.left) && (this.position.left = t.left), this._isNumber(t.top) && (this.position.top = t.top), this._isNumber(t.height) && (this.size.height = t.height), this._isNumber(t.width) && (this.size.width = t.width)
                },
                _updateRatio: function(t) {
                    var e = this.position,
                        i = this.size,
                        s = this.axis;
                    return this._isNumber(t.height) ? t.width = t.height * this.aspectRatio : this._isNumber(t.width) && (t.height = t.width / this.aspectRatio), "sw" === s && (t.left = e.left + (i.width - t.width), t.top = null), "nw" === s && (t.top = e.top + (i.height - t.height), t.left = e.left + (i.width - t.width)), t
                },
                _respectSize: function(t) {
                    var e = this._vBoundaries,
                        i = this.axis,
                        s = this._isNumber(t.width) && e.maxWidth && e.maxWidth < t.width,
                        n = this._isNumber(t.height) && e.maxHeight && e.maxHeight < t.height,
                        o = this._isNumber(t.width) && e.minWidth && e.minWidth > t.width,
                        a = this._isNumber(t.height) && e.minHeight && e.minHeight > t.height,
                        r = this.originalPosition.left + this.originalSize.width,
                        l = this.originalPosition.top + this.originalSize.height,
                        h = /sw|nw|w/.test(i),
                        i = /nw|ne|n/.test(i);
                    return o && (t.width = e.minWidth), a && (t.height = e.minHeight), s && (t.width = e.maxWidth), n && (t.height = e.maxHeight), o && h && (t.left = r - e.minWidth), s && h && (t.left = r - e.maxWidth), a && i && (t.top = l - e.minHeight), n && i && (t.top = l - e.maxHeight), t.width || t.height || t.left || !t.top ? t.width || t.height || t.top || !t.left || (t.left = null) : t.top = null, t
                },
                _getPaddingPlusBorderDimensions: function(t) {
                    for (var e = 0, i = [], s = [t.css("borderTopWidth"), t.css("borderRightWidth"), t.css("borderBottomWidth"), t.css("borderLeftWidth")], n = [t.css("paddingTop"), t.css("paddingRight"), t.css("paddingBottom"), t.css("paddingLeft")]; e < 4; e++) i[e] = parseFloat(s[e]) || 0, i[e] += parseFloat(n[e]) || 0;
                    return {
                        height: i[0] + i[2],
                        width: i[1] + i[3]
                    }
                },
                _proportionallyResize: function() {
                    if (this._proportionallyResizeElements.length)
                        for (var t, e = 0, i = this.helper || this.element; e < this._proportionallyResizeElements.length; e++) t = this._proportionallyResizeElements[e], this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(t)), t.css({
                            height: i.height() - this.outerDimensions.height || 0,
                            width: i.width() - this.outerDimensions.width || 0
                        })
                },
                _renderProxy: function() {
                    var t = this.element,
                        e = this.options;
                    this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper || V("<div></div>").css({
                        overflow: "hidden"
                    }), this._addClass(this.helper, this._helper), this.helper.css({
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        position: "absolute",
                        left: this.elementOffset.left + "px",
                        top: this.elementOffset.top + "px",
                        zIndex: ++e.zIndex
                    }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element
                },
                _change: {
                    e: function(t, e) {
                        return {
                            width: this.originalSize.width + e
                        }
                    },
                    w: function(t, e) {
                        var i = this.originalSize;
                        return {
                            left: this.originalPosition.left + e,
                            width: i.width - e
                        }
                    },
                    n: function(t, e, i) {
                        var s = this.originalSize;
                        return {
                            top: this.originalPosition.top + i,
                            height: s.height - i
                        }
                    },
                    s: function(t, e, i) {
                        return {
                            height: this.originalSize.height + i
                        }
                    },
                    se: function(t, e, i) {
                        return V.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t, e, i]))
                    },
                    sw: function(t, e, i) {
                        return V.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t, e, i]))
                    },
                    ne: function(t, e, i) {
                        return V.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t, e, i]))
                    },
                    nw: function(t, e, i) {
                        return V.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t, e, i]))
                    }
                },
                _propagate: function(t, e) {
                    V.ui.plugin.call(this, t, [e, this.ui()]), "resize" !== t && this._trigger(t, e, this.ui())
                },
                plugins: {},
                ui: function() {
                    return {
                        originalElement: this.originalElement,
                        element: this.element,
                        helper: this.helper,
                        position: this.position,
                        size: this.size,
                        originalSize: this.originalSize,
                        originalPosition: this.originalPosition
                    }
                }
            }), V.ui.plugin.add("resizable", "animate", {
                stop: function(e) {
                    var i = V(this).resizable("instance"),
                        t = i.options,
                        s = i._proportionallyResizeElements,
                        n = s.length && /textarea/i.test(s[0].nodeName),
                        o = n && i._hasScroll(s[0], "left") ? 0 : i.sizeDiff.height,
                        a = n ? 0 : i.sizeDiff.width,
                        n = {
                            width: i.size.width - a,
                            height: i.size.height - o
                        },
                        a = parseFloat(i.element.css("left")) + (i.position.left - i.originalPosition.left) || null,
                        o = parseFloat(i.element.css("top")) + (i.position.top - i.originalPosition.top) || null;
                    i.element.animate(V.extend(n, o && a ? {
                        top: o,
                        left: a
                    } : {}), {
                        duration: t.animateDuration,
                        easing: t.animateEasing,
                        step: function() {
                            var t = {
                                width: parseFloat(i.element.css("width")),
                                height: parseFloat(i.element.css("height")),
                                top: parseFloat(i.element.css("top")),
                                left: parseFloat(i.element.css("left"))
                            };
                            s && s.length && V(s[0]).css({
                                width: t.width,
                                height: t.height
                            }), i._updateCache(t), i._propagate("resize", e)
                        }
                    })
                }
            }), V.ui.plugin.add("resizable", "containment", {
                start: function() {
                    var i, s, n = V(this).resizable("instance"),
                        t = n.options,
                        e = n.element,
                        o = t.containment,
                        a = o instanceof V ? o.get(0) : /parent/.test(o) ? e.parent().get(0) : o;
                    a && (n.containerElement = V(a), /document/.test(o) || o === document ? (n.containerOffset = {
                        left: 0,
                        top: 0
                    }, n.containerPosition = {
                        left: 0,
                        top: 0
                    }, n.parentData = {
                        element: V(document),
                        left: 0,
                        top: 0,
                        width: V(document).width(),
                        height: V(document).height() || document.body.parentNode.scrollHeight
                    }) : (i = V(a), s = [], V(["Top", "Right", "Left", "Bottom"]).each(function(t, e) {
                        s[t] = n._num(i.css("padding" + e))
                    }), n.containerOffset = i.offset(), n.containerPosition = i.position(), n.containerSize = {
                        height: i.innerHeight() - s[3],
                        width: i.innerWidth() - s[1]
                    }, t = n.containerOffset, e = n.containerSize.height, o = n.containerSize.width, o = n._hasScroll(a, "left") ? a.scrollWidth : o, e = n._hasScroll(a) ? a.scrollHeight : e, n.parentData = {
                        element: a,
                        left: t.left,
                        top: t.top,
                        width: o,
                        height: e
                    }))
                },
                resize: function(t) {
                    var e = V(this).resizable("instance"),
                        i = e.options,
                        s = e.containerOffset,
                        n = e.position,
                        o = e._aspectRatio || t.shiftKey,
                        a = {
                            top: 0,
                            left: 0
                        },
                        r = e.containerElement,
                        t = !0;
                    r[0] !== document && /static/.test(r.css("position")) && (a = s), n.left < (e._helper ? s.left : 0) && (e.size.width = e.size.width + (e._helper ? e.position.left - s.left : e.position.left - a.left), o && (e.size.height = e.size.width / e.aspectRatio, t = !1), e.position.left = i.helper ? s.left : 0), n.top < (e._helper ? s.top : 0) && (e.size.height = e.size.height + (e._helper ? e.position.top - s.top : e.position.top), o && (e.size.width = e.size.height * e.aspectRatio, t = !1), e.position.top = e._helper ? s.top : 0), i = e.containerElement.get(0) === e.element.parent().get(0), n = /relative|absolute/.test(e.containerElement.css("position")), i && n ? (e.offset.left = e.parentData.left + e.position.left, e.offset.top = e.parentData.top + e.position.top) : (e.offset.left = e.element.offset().left, e.offset.top = e.element.offset().top), n = Math.abs(e.sizeDiff.width + (e._helper ? e.offset.left - a.left : e.offset.left - s.left)), s = Math.abs(e.sizeDiff.height + (e._helper ? e.offset.top - a.top : e.offset.top - s.top)), n + e.size.width >= e.parentData.width && (e.size.width = e.parentData.width - n, o && (e.size.height = e.size.width / e.aspectRatio, t = !1)), s + e.size.height >= e.parentData.height && (e.size.height = e.parentData.height - s, o && (e.size.width = e.size.height * e.aspectRatio, t = !1)), t || (e.position.left = e.prevPosition.left, e.position.top = e.prevPosition.top, e.size.width = e.prevSize.width, e.size.height = e.prevSize.height)
                },
                stop: function() {
                    var t = V(this).resizable("instance"),
                        e = t.options,
                        i = t.containerOffset,
                        s = t.containerPosition,
                        n = t.containerElement,
                        o = V(t.helper),
                        a = o.offset(),
                        r = o.outerWidth() - t.sizeDiff.width,
                        o = o.outerHeight() - t.sizeDiff.height;
                    t._helper && !e.animate && /relative/.test(n.css("position")) && V(this).css({
                        left: a.left - s.left - i.left,
                        width: r,
                        height: o
                    }), t._helper && !e.animate && /static/.test(n.css("position")) && V(this).css({
                        left: a.left - s.left - i.left,
                        width: r,
                        height: o
                    })
                }
            }), V.ui.plugin.add("resizable", "alsoResize", {
                start: function() {
                    var t = V(this).resizable("instance").options;
                    V(t.alsoResize).each(function() {
                        var t = V(this);
                        t.data("ui-resizable-alsoresize", {
                            width: parseFloat(t.width()),
                            height: parseFloat(t.height()),
                            left: parseFloat(t.css("left")),
                            top: parseFloat(t.css("top"))
                        })
                    })
                },
                resize: function(t, i) {
                    var e = V(this).resizable("instance"),
                        s = e.options,
                        n = e.originalSize,
                        o = e.originalPosition,
                        a = {
                            height: e.size.height - n.height || 0,
                            width: e.size.width - n.width || 0,
                            top: e.position.top - o.top || 0,
                            left: e.position.left - o.left || 0
                        };
                    V(s.alsoResize).each(function() {
                        var t = V(this),
                            s = V(this).data("ui-resizable-alsoresize"),
                            n = {},
                            e = t.parents(i.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                        V.each(e, function(t, e) {
                            var i = (s[e] || 0) + (a[e] || 0);
                            i && 0 <= i && (n[e] = i || null)
                        }), t.css(n)
                    })
                },
                stop: function() {
                    V(this).removeData("ui-resizable-alsoresize")
                }
            }), V.ui.plugin.add("resizable", "ghost", {
                start: function() {
                    var t = V(this).resizable("instance"),
                        e = t.size;
                    t.ghost = t.originalElement.clone(), t.ghost.css({
                        opacity: .25,
                        display: "block",
                        position: "relative",
                        height: e.height,
                        width: e.width,
                        margin: 0,
                        left: 0,
                        top: 0
                    }), t._addClass(t.ghost, "ui-resizable-ghost"), !1 !== V.uiBackCompat && "string" == typeof t.options.ghost && t.ghost.addClass(this.options.ghost), t.ghost.appendTo(t.helper)
                },
                resize: function() {
                    var t = V(this).resizable("instance");
                    t.ghost && t.ghost.css({
                        position: "relative",
                        height: t.size.height,
                        width: t.size.width
                    })
                },
                stop: function() {
                    var t = V(this).resizable("instance");
                    t.ghost && t.helper && t.helper.get(0).removeChild(t.ghost.get(0))
                }
            }), V.ui.plugin.add("resizable", "grid", {
                resize: function() {
                    var t, e = V(this).resizable("instance"),
                        i = e.options,
                        s = e.size,
                        n = e.originalSize,
                        o = e.originalPosition,
                        a = e.axis,
                        r = "number" == typeof i.grid ? [i.grid, i.grid] : i.grid,
                        l = r[0] || 1,
                        h = r[1] || 1,
                        c = Math.round((s.width - n.width) / l) * l,
                        u = Math.round((s.height - n.height) / h) * h,
                        d = n.width + c,
                        p = n.height + u,
                        f = i.maxWidth && i.maxWidth < d,
                        g = i.maxHeight && i.maxHeight < p,
                        m = i.minWidth && i.minWidth > d,
                        s = i.minHeight && i.minHeight > p;
                    i.grid = r, m && (d += l), s && (p += h), f && (d -= l), g && (p -= h), /^(se|s|e)$/.test(a) ? (e.size.width = d, e.size.height = p) : /^(ne)$/.test(a) ? (e.size.width = d, e.size.height = p, e.position.top = o.top - u) : /^(sw)$/.test(a) ? (e.size.width = d, e.size.height = p, e.position.left = o.left - c) : ((p - h <= 0 || d - l <= 0) && (t = e._getPaddingPlusBorderDimensions(this)), 0 < p - h ? (e.size.height = p, e.position.top = o.top - u) : (p = h - t.height, e.size.height = p, e.position.top = o.top + n.height - p), 0 < d - l ? (e.size.width = d, e.position.left = o.left - c) : (d = l - t.width, e.size.width = d, e.position.left = o.left + n.width - d))
                }
            });
            V.ui.resizable;
            V.widget("ui.dialog", {
                version: "1.13.2",
                options: {
                    appendTo: "body",
                    autoOpen: !0,
                    buttons: [],
                    classes: {
                        "ui-dialog": "ui-corner-all",
                        "ui-dialog-titlebar": "ui-corner-all"
                    },
                    closeOnEscape: !0,
                    closeText: "Close",
                    draggable: !0,
                    hide: null,
                    height: "auto",
                    maxHeight: null,
                    maxWidth: null,
                    minHeight: 150,
                    minWidth: 150,
                    modal: !1,
                    position: {
                        my: "center",
                        at: "center",
                        of: window,
                        collision: "fit",
                        using: function(t) {
                            var e = V(this).css(t).offset().top;
                            e < 0 && V(this).css("top", t.top - e)
                        }
                    },
                    resizable: !0,
                    show: null,
                    title: null,
                    width: 300,
                    beforeClose: null,
                    close: null,
                    drag: null,
                    dragStart: null,
                    dragStop: null,
                    focus: null,
                    open: null,
                    resize: null,
                    resizeStart: null,
                    resizeStop: null
                },
                sizeRelatedOptions: {
                    buttons: !0,
                    height: !0,
                    maxHeight: !0,
                    maxWidth: !0,
                    minHeight: !0,
                    minWidth: !0,
                    width: !0
                },
                resizableRelatedOptions: {
                    maxHeight: !0,
                    maxWidth: !0,
                    minHeight: !0,
                    minWidth: !0
                },
                _create: function() {
                    this.originalCss = {
                        display: this.element[0].style.display,
                        width: this.element[0].style.width,
                        minHeight: this.element[0].style.minHeight,
                        maxHeight: this.element[0].style.maxHeight,
                        height: this.element[0].style.height
                    }, this.originalPosition = {
                        parent: this.element.parent(),
                        index: this.element.parent().children().index(this.element)
                    }, this.originalTitle = this.element.attr("title"), null == this.options.title && null != this.originalTitle && (this.options.title = this.originalTitle), this.options.disabled && (this.options.disabled = !1), this._createWrapper(), this.element.show().removeAttr("title").appendTo(this.uiDialog), this._addClass("ui-dialog-content", "ui-widget-content"), this._createTitlebar(), this._createButtonPane(), this.options.draggable && V.fn.draggable && this._makeDraggable(), this.options.resizable && V.fn.resizable && this._makeResizable(), this._isOpen = !1, this._trackFocus()
                },
                _init: function() {
                    this.options.autoOpen && this.open()
                },
                _appendTo: function() {
                    var t = this.options.appendTo;
                    return t && (t.jquery || t.nodeType) ? V(t) : this.document.find(t || "body").eq(0)
                },
                _destroy: function() {
                    var t, e = this.originalPosition;
                    this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().css(this.originalCss).detach(), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), (t = e.parent.children().eq(e.index)).length && t[0] !== this.element[0] ? t.before(this.element) : e.parent.append(this.element)
                },
                widget: function() {
                    return this.uiDialog
                },
                disable: V.noop,
                enable: V.noop,
                close: function(t) {
                    var e = this;
                    this._isOpen && !1 !== this._trigger("beforeClose", t) && (this._isOpen = !1, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), this.opener.filter(":focusable").trigger("focus").length || V.ui.safeBlur(V.ui.safeActiveElement(this.document[0])), this._hide(this.uiDialog, this.options.hide, function() {
                        e._trigger("close", t)
                    }))
                },
                isOpen: function() {
                    return this._isOpen
                },
                moveToTop: function() {
                    this._moveToTop()
                },
                _moveToTop: function(t, e) {
                    var i = !1,
                        s = this.uiDialog.siblings(".ui-front:visible").map(function() {
                            return +V(this).css("z-index")
                        }).get(),
                        s = Math.max.apply(null, s);
                    return s >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", s + 1), i = !0), i && !e && this._trigger("focus", t), i
                },
                open: function() {
                    var t = this;
                    this._isOpen ? this._moveToTop() && this._focusTabbable() : (this._isOpen = !0, this.opener = V(V.ui.safeActiveElement(this.document[0])), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, !0), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this.options.show, function() {
                        t._focusTabbable(), t._trigger("focus")
                    }), this._makeFocusTarget(), this._trigger("open"))
                },
                _focusTabbable: function() {
                    var t = this._focusedElement;
                    (t = !(t = !(t = !(t = !(t = t || this.element.find("[autofocus]")).length ? this.element.find(":tabbable") : t).length ? this.uiDialogButtonPane.find(":tabbable") : t).length ? this.uiDialogTitlebarClose.filter(":tabbable") : t).length ? this.uiDialog : t).eq(0).trigger("focus")
                },
                _restoreTabbableFocus: function() {
                    var t = V.ui.safeActiveElement(this.document[0]);
                    this.uiDialog[0] === t || V.contains(this.uiDialog[0], t) || this._focusTabbable()
                },
                _keepFocus: function(t) {
                    t.preventDefault(), this._restoreTabbableFocus(), this._delay(this._restoreTabbableFocus)
                },
                _createWrapper: function() {
                    this.uiDialog = V("<div>").hide().attr({
                        tabIndex: -1,
                        role: "dialog"
                    }).appendTo(this._appendTo()), this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front"), this._on(this.uiDialog, {
                        keydown: function(t) {
                            if (this.options.closeOnEscape && !t.isDefaultPrevented() && t.keyCode && t.keyCode === V.ui.keyCode.ESCAPE) return t.preventDefault(), void this.close(t);
                            var e, i, s;
                            t.keyCode !== V.ui.keyCode.TAB || t.isDefaultPrevented() || (e = this.uiDialog.find(":tabbable"), i = e.first(), s = e.last(), t.target !== s[0] && t.target !== this.uiDialog[0] || t.shiftKey ? t.target !== i[0] && t.target !== this.uiDialog[0] || !t.shiftKey || (this._delay(function() {
                                s.trigger("focus")
                            }), t.preventDefault()) : (this._delay(function() {
                                i.trigger("focus")
                            }), t.preventDefault()))
                        },
                        mousedown: function(t) {
                            this._moveToTop(t) && this._focusTabbable()
                        }
                    }), this.element.find("[aria-describedby]").length || this.uiDialog.attr({
                        "aria-describedby": this.element.uniqueId().attr("id")
                    })
                },
                _createTitlebar: function() {
                    var t;
                    this.uiDialogTitlebar = V("<div>"), this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix"), this._on(this.uiDialogTitlebar, {
                        mousedown: function(t) {
                            V(t.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.trigger("focus")
                        }
                    }), this.uiDialogTitlebarClose = V("<button type='button'></button>").button({
                        label: V("<a>").text(this.options.closeText).html(),
                        icon: "ui-icon-closethick",
                        showLabel: !1
                    }).appendTo(this.uiDialogTitlebar), this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close"), this._on(this.uiDialogTitlebarClose, {
                        click: function(t) {
                            t.preventDefault(), this.close(t)
                        }
                    }), t = V("<span>").uniqueId().prependTo(this.uiDialogTitlebar), this._addClass(t, "ui-dialog-title"), this._title(t), this.uiDialogTitlebar.prependTo(this.uiDialog), this.uiDialog.attr({
                        "aria-labelledby": t.attr("id")
                    })
                },
                _title: function(t) {
                    this.options.title ? t.text(this.options.title) : t.html("&#160;")
                },
                _createButtonPane: function() {
                    this.uiDialogButtonPane = V("<div>"), this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix"), this.uiButtonSet = V("<div>").appendTo(this.uiDialogButtonPane), this._addClass(this.uiButtonSet, "ui-dialog-buttonset"), this._createButtons()
                },
                _createButtons: function() {
                    var s = this,
                        t = this.options.buttons;
                    this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), V.isEmptyObject(t) || Array.isArray(t) && !t.length ? this._removeClass(this.uiDialog, "ui-dialog-buttons") : (V.each(t, function(t, e) {
                        var i;
                        e = V.extend({
                            type: "button"
                        }, e = "function" == typeof e ? {
                            click: e,
                            text: t
                        } : e), i = e.click, t = {
                            icon: e.icon,
                            iconPosition: e.iconPosition,
                            showLabel: e.showLabel,
                            icons: e.icons,
                            text: e.text
                        }, delete e.click, delete e.icon, delete e.iconPosition, delete e.showLabel, delete e.icons, "boolean" == typeof e.text && delete e.text, V("<button></button>", e).button(t).appendTo(s.uiButtonSet).on("click", function() {
                            i.apply(s.element[0], arguments)
                        })
                    }), this._addClass(this.uiDialog, "ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog))
                },
                _makeDraggable: function() {
                    var n = this,
                        o = this.options;

                    function a(t) {
                        return {
                            position: t.position,
                            offset: t.offset
                        }
                    }
                    this.uiDialog.draggable({
                        cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                        handle: ".ui-dialog-titlebar",
                        containment: "document",
                        start: function(t, e) {
                            n._addClass(V(this), "ui-dialog-dragging"), n._blockFrames(), n._trigger("dragStart", t, a(e))
                        },
                        drag: function(t, e) {
                            n._trigger("drag", t, a(e))
                        },
                        stop: function(t, e) {
                            var i = e.offset.left - n.document.scrollLeft(),
                                s = e.offset.top - n.document.scrollTop();
                            o.position = {
                                my: "left top",
                                at: "left" + (0 <= i ? "+" : "") + i + " top" + (0 <= s ? "+" : "") + s,
                                of: n.window
                            }, n._removeClass(V(this), "ui-dialog-dragging"), n._unblockFrames(), n._trigger("dragStop", t, a(e))
                        }
                    })
                },
                _makeResizable: function() {
                    var n = this,
                        o = this.options,
                        t = o.resizable,
                        e = this.uiDialog.css("position"),
                        t = "string" == typeof t ? t : "n,e,s,w,se,sw,ne,nw";

                    function a(t) {
                        return {
                            originalPosition: t.originalPosition,
                            originalSize: t.originalSize,
                            position: t.position,
                            size: t.size
                        }
                    }
                    this.uiDialog.resizable({
                        cancel: ".ui-dialog-content",
                        containment: "document",
                        alsoResize: this.element,
                        maxWidth: o.maxWidth,
                        maxHeight: o.maxHeight,
                        minWidth: o.minWidth,
                        minHeight: this._minHeight(),
                        handles: t,
                        start: function(t, e) {
                            n._addClass(V(this), "ui-dialog-resizing"), n._blockFrames(), n._trigger("resizeStart", t, a(e))
                        },
                        resize: function(t, e) {
                            n._trigger("resize", t, a(e))
                        },
                        stop: function(t, e) {
                            var i = n.uiDialog.offset(),
                                s = i.left - n.document.scrollLeft(),
                                i = i.top - n.document.scrollTop();
                            o.height = n.uiDialog.height(), o.width = n.uiDialog.width(), o.position = {
                                my: "left top",
                                at: "left" + (0 <= s ? "+" : "") + s + " top" + (0 <= i ? "+" : "") + i,
                                of: n.window
                            }, n._removeClass(V(this), "ui-dialog-resizing"), n._unblockFrames(), n._trigger("resizeStop", t, a(e))
                        }
                    }).css("position", e)
                },
                _trackFocus: function() {
                    this._on(this.widget(), {
                        focusin: function(t) {
                            this._makeFocusTarget(), this._focusedElement = V(t.target)
                        }
                    })
                },
                _makeFocusTarget: function() {
                    this._untrackInstance(), this._trackingInstances().unshift(this)
                },
                _untrackInstance: function() {
                    var t = this._trackingInstances(),
                        e = V.inArray(this, t); - 1 !== e && t.splice(e, 1)
                },
                _trackingInstances: function() {
                    var t = this.document.data("ui-dialog-instances");
                    return t || this.document.data("ui-dialog-instances", t = []), t
                },
                _minHeight: function() {
                    var t = this.options;
                    return "auto" === t.height ? t.minHeight : Math.min(t.minHeight, t.height)
                },
                _position: function() {
                    var t = this.uiDialog.is(":visible");
                    t || this.uiDialog.show(), this.uiDialog.position(this.options.position), t || this.uiDialog.hide()
                },
                _setOptions: function(t) {
                    var i = this,
                        s = !1,
                        n = {};
                    V.each(t, function(t, e) {
                        i._setOption(t, e), t in i.sizeRelatedOptions && (s = !0), t in i.resizableRelatedOptions && (n[t] = e)
                    }), s && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", n)
                },
                _setOption: function(t, e) {
                    var i, s = this.uiDialog;
                    "disabled" !== t && (this._super(t, e), "appendTo" === t && this.uiDialog.appendTo(this._appendTo()), "buttons" === t && this._createButtons(), "closeText" === t && this.uiDialogTitlebarClose.button({
                        label: V("<a>").text("" + this.options.closeText).html()
                    }), "draggable" === t && ((i = s.is(":data(ui-draggable)")) && !e && s.draggable("destroy"), !i && e && this._makeDraggable()), "position" === t && this._position(), "resizable" === t && ((i = s.is(":data(ui-resizable)")) && !e && s.resizable("destroy"), i && "string" == typeof e && s.resizable("option", "handles", e), i || !1 === e || this._makeResizable()), "title" === t && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))
                },
                _size: function() {
                    var t, e, i, s = this.options;
                    this.element.show().css({
                        width: "auto",
                        minHeight: 0,
                        maxHeight: "none",
                        height: 0
                    }), s.minWidth > s.width && (s.width = s.minWidth), t = this.uiDialog.css({
                        height: "auto",
                        width: s.width
                    }).outerHeight(), e = Math.max(0, s.minHeight - t), i = "number" == typeof s.maxHeight ? Math.max(0, s.maxHeight - t) : "none", "auto" === s.height ? this.element.css({
                        minHeight: e,
                        maxHeight: i,
                        height: "auto"
                    }) : this.element.height(Math.max(0, s.height - t)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
                },
                _blockFrames: function() {
                    this.iframeBlocks = this.document.find("iframe").map(function() {
                        var t = V(this);
                        return V("<div>").css({
                            position: "absolute",
                            width: t.outerWidth(),
                            height: t.outerHeight()
                        }).appendTo(t.parent()).offset(t.offset())[0]
                    })
                },
                _unblockFrames: function() {
                    this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
                },
                _allowInteraction: function(t) {
                    return !!V(t.target).closest(".ui-dialog").length || !!V(t.target).closest(".ui-datepicker").length
                },
                _createOverlay: function() {
                    var i, s;
                    this.options.modal && (i = V.fn.jquery.substring(0, 4), s = !0, this._delay(function() {
                        s = !1
                    }), this.document.data("ui-dialog-overlays") || this.document.on("focusin.ui-dialog", function(t) {
                        var e;
                        s || ((e = this._trackingInstances()[0])._allowInteraction(t) || (t.preventDefault(), e._focusTabbable(), "3.4." !== i && "3.5." !== i || e._delay(e._restoreTabbableFocus)))
                    }.bind(this)), this.overlay = V("<div>").appendTo(this._appendTo()), this._addClass(this.overlay, null, "ui-widget-overlay ui-front"), this._on(this.overlay, {
                        mousedown: "_keepFocus"
                    }), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1))
                },
                _destroyOverlay: function() {
                    var t;
                    this.options.modal && this.overlay && ((t = this.document.data("ui-dialog-overlays") - 1) ? this.document.data("ui-dialog-overlays", t) : (this.document.off("focusin.ui-dialog"), this.document.removeData("ui-dialog-overlays")), this.overlay.remove(), this.overlay = null)
                }
            }), !1 !== V.uiBackCompat && V.widget("ui.dialog", V.ui.dialog, {
                options: {
                    dialogClass: ""
                },
                _createWrapper: function() {
                    this._super(), this.uiDialog.addClass(this.options.dialogClass)
                },
                _setOption: function(t, e) {
                    "dialogClass" === t && this.uiDialog.removeClass(this.options.dialogClass).addClass(e), this._superApply(arguments)
                }
            });
            V.ui.dialog;

            function lt(t, e, i) {
                return e <= t && t < e + i
            }
            V.widget("ui.droppable", {
                version: "1.13.2",
                widgetEventPrefix: "drop",
                options: {
                    accept: "*",
                    addClasses: !0,
                    greedy: !1,
                    scope: "default",
                    tolerance: "intersect",
                    activate: null,
                    deactivate: null,
                    drop: null,
                    out: null,
                    over: null
                },
                _create: function() {
                    var t, e = this.options,
                        i = e.accept;
                    this.isover = !1, this.isout = !0, this.accept = "function" == typeof i ? i : function(t) {
                        return t.is(i)
                    }, this.proportions = function() {
                        if (!arguments.length) return t = t || {
                            width: this.element[0].offsetWidth,
                            height: this.element[0].offsetHeight
                        };
                        t = arguments[0]
                    }, this._addToManager(e.scope), e.addClasses && this._addClass("ui-droppable")
                },
                _addToManager: function(t) {
                    V.ui.ddmanager.droppables[t] = V.ui.ddmanager.droppables[t] || [], V.ui.ddmanager.droppables[t].push(this)
                },
                _splice: function(t) {
                    for (var e = 0; e < t.length; e++) t[e] === this && t.splice(e, 1)
                },
                _destroy: function() {
                    var t = V.ui.ddmanager.droppables[this.options.scope];
                    this._splice(t)
                },
                _setOption: function(t, e) {
                    var i;
                    "accept" === t ? this.accept = "function" == typeof e ? e : function(t) {
                        return t.is(e)
                    } : "scope" === t && (i = V.ui.ddmanager.droppables[this.options.scope], this._splice(i), this._addToManager(e)), this._super(t, e)
                },
                _activate: function(t) {
                    var e = V.ui.ddmanager.current;
                    this._addActiveClass(), e && this._trigger("activate", t, this.ui(e))
                },
                _deactivate: function(t) {
                    var e = V.ui.ddmanager.current;
                    this._removeActiveClass(), e && this._trigger("deactivate", t, this.ui(e))
                },
                _over: function(t) {
                    var e = V.ui.ddmanager.current;
                    e && (e.currentItem || e.element)[0] !== this.element[0] && this.accept.call(this.element[0], e.currentItem || e.element) && (this._addHoverClass(), this._trigger("over", t, this.ui(e)))
                },
                _out: function(t) {
                    var e = V.ui.ddmanager.current;
                    e && (e.currentItem || e.element)[0] !== this.element[0] && this.accept.call(this.element[0], e.currentItem || e.element) && (this._removeHoverClass(), this._trigger("out", t, this.ui(e)))
                },
                _drop: function(e, t) {
                    var i = t || V.ui.ddmanager.current,
                        s = !1;
                    return !(!i || (i.currentItem || i.element)[0] === this.element[0]) && (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                        var t = V(this).droppable("instance");
                        if (t.options.greedy && !t.options.disabled && t.options.scope === i.options.scope && t.accept.call(t.element[0], i.currentItem || i.element) && V.ui.intersect(i, V.extend(t, {
                                offset: t.element.offset()
                            }), t.options.tolerance, e)) return !(s = !0)
                    }), !s && (!!this.accept.call(this.element[0], i.currentItem || i.element) && (this._removeActiveClass(), this._removeHoverClass(), this._trigger("drop", e, this.ui(i)), this.element)))
                },
                ui: function(t) {
                    return {
                        draggable: t.currentItem || t.element,
                        helper: t.helper,
                        position: t.position,
                        offset: t.positionAbs
                    }
                },
                _addHoverClass: function() {
                    this._addClass("ui-droppable-hover")
                },
                _removeHoverClass: function() {
                    this._removeClass("ui-droppable-hover")
                },
                _addActiveClass: function() {
                    this._addClass("ui-droppable-active")
                },
                _removeActiveClass: function() {
                    this._removeClass("ui-droppable-active")
                }
            }), V.ui.intersect = function(t, e, i, s) {
                if (!e.offset) return !1;
                var n = (t.positionAbs || t.position.absolute).left + t.margins.left,
                    o = (t.positionAbs || t.position.absolute).top + t.margins.top,
                    a = n + t.helperProportions.width,
                    r = o + t.helperProportions.height,
                    l = e.offset.left,
                    h = e.offset.top,
                    c = l + e.proportions().width,
                    u = h + e.proportions().height;
                switch (i) {
                    case "fit":
                        return l <= n && a <= c && h <= o && r <= u;
                    case "intersect":
                        return l < n + t.helperProportions.width / 2 && a - t.helperProportions.width / 2 < c && h < o + t.helperProportions.height / 2 && r - t.helperProportions.height / 2 < u;
                    case "pointer":
                        return lt(s.pageY, h, e.proportions().height) && lt(s.pageX, l, e.proportions().width);
                    case "touch":
                        return (h <= o && o <= u || h <= r && r <= u || o < h && u < r) && (l <= n && n <= c || l <= a && a <= c || n < l && c < a);
                    default:
                        return !1
                }
            }, !(V.ui.ddmanager = {
                current: null,
                droppables: {
                    default: []
                },
                prepareOffsets: function(t, e) {
                    var i, s, n = V.ui.ddmanager.droppables[t.options.scope] || [],
                        o = e ? e.type : null,
                        a = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
                    t: for (i = 0; i < n.length; i++)
                        if (!(n[i].options.disabled || t && !n[i].accept.call(n[i].element[0], t.currentItem || t.element))) {
                            for (s = 0; s < a.length; s++)
                                if (a[s] === n[i].element[0]) {
                                    n[i].proportions().height = 0;
                                    continue t
                                }
                            n[i].visible = "none" !== n[i].element.css("display"), n[i].visible && ("mousedown" === o && n[i]._activate.call(n[i], e), n[i].offset = n[i].element.offset(), n[i].proportions({
                                width: n[i].element[0].offsetWidth,
                                height: n[i].element[0].offsetHeight
                            }))
                        }
                },
                drop: function(t, e) {
                    var i = !1;
                    return V.each((V.ui.ddmanager.droppables[t.options.scope] || []).slice(), function() {
                        this.options && (!this.options.disabled && this.visible && V.ui.intersect(t, this, this.options.tolerance, e) && (i = this._drop.call(this, e) || i), !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = !0, this.isover = !1, this._deactivate.call(this, e)))
                    }), i
                },
                dragStart: function(t, e) {
                    t.element.parentsUntil("body").on("scroll.droppable", function() {
                        t.options.refreshPositions || V.ui.ddmanager.prepareOffsets(t, e)
                    })
                },
                drag: function(n, o) {
                    n.options.refreshPositions && V.ui.ddmanager.prepareOffsets(n, o), V.each(V.ui.ddmanager.droppables[n.options.scope] || [], function() {
                        var t, e, i, s;
                        this.options.disabled || this.greedyChild || !this.visible || (s = !(i = V.ui.intersect(n, this, this.options.tolerance, o)) && this.isover ? "isout" : i && !this.isover ? "isover" : null) && (this.options.greedy && (e = this.options.scope, (i = this.element.parents(":data(ui-droppable)").filter(function() {
                            return V(this).droppable("instance").options.scope === e
                        })).length && ((t = V(i[0]).droppable("instance")).greedyChild = "isover" === s)), t && "isover" === s && (t.isover = !1, t.isout = !0, t._out.call(t, o)), this[s] = !0, this["isout" === s ? "isover" : "isout"] = !1, this["isover" === s ? "_over" : "_out"].call(this, o), t && "isout" === s && (t.isout = !1, t.isover = !0, t._over.call(t, o)))
                    })
                },
                dragStop: function(t, e) {
                    t.element.parentsUntil("body").off("scroll.droppable"), t.options.refreshPositions || V.ui.ddmanager.prepareOffsets(t, e)
                }
            }) !== V.uiBackCompat && V.widget("ui.droppable", V.ui.droppable, {
                options: {
                    hoverClass: !1,
                    activeClass: !1
                },
                _addActiveClass: function() {
                    this._super(), this.options.activeClass && this.element.addClass(this.options.activeClass)
                },
                _removeActiveClass: function() {
                    this._super(), this.options.activeClass && this.element.removeClass(this.options.activeClass)
                },
                _addHoverClass: function() {
                    this._super(), this.options.hoverClass && this.element.addClass(this.options.hoverClass)
                },
                _removeHoverClass: function() {
                    this._super(), this.options.hoverClass && this.element.removeClass(this.options.hoverClass)
                }
            });
            V.ui.droppable, V.widget("ui.progressbar", {
                version: "1.13.2",
                options: {
                    classes: {
                        "ui-progressbar": "ui-corner-all",
                        "ui-progressbar-value": "ui-corner-left",
                        "ui-progressbar-complete": "ui-corner-right"
                    },
                    max: 100,
                    value: 0,
                    change: null,
                    complete: null
                },
                min: 0,
                _create: function() {
                    this.oldValue = this.options.value = this._constrainedValue(), this.element.attr({
                        role: "progressbar",
                        "aria-valuemin": this.min
                    }), this._addClass("ui-progressbar", "ui-widget ui-widget-content"), this.valueDiv = V("<div>").appendTo(this.element), this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header"), this._refreshValue()
                },
                _destroy: function() {
                    this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"), this.valueDiv.remove()
                },
                value: function(t) {
                    if (void 0 === t) return this.options.value;
                    this.options.value = this._constrainedValue(t), this._refreshValue()
                },
                _constrainedValue: function(t) {
                    return void 0 === t && (t = this.options.value), this.indeterminate = !1 === t, "number" != typeof t && (t = 0), !this.indeterminate && Math.min(this.options.max, Math.max(this.min, t))
                },
                _setOptions: function(t) {
                    var e = t.value;
                    delete t.value, this._super(t), this.options.value = this._constrainedValue(e), this._refreshValue()
                },
                _setOption: function(t, e) {
                    "max" === t && (e = Math.max(this.min, e)), this._super(t, e)
                },
                _setOptionDisabled: function(t) {
                    this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t)
                },
                _percentage: function() {
                    return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min)
                },
                _refreshValue: function() {
                    var t = this.options.value,
                        e = this._percentage();
                    this.valueDiv.toggle(this.indeterminate || t > this.min).width(e.toFixed(0) + "%"), this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, t === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = V("<div>").appendTo(this.valueDiv), this._addClass(this.overlayDiv, "ui-progressbar-overlay"))) : (this.element.attr({
                        "aria-valuemax": this.options.max,
                        "aria-valuenow": t
                    }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== t && (this.oldValue = t, this._trigger("change")), t === this.options.max && this._trigger("complete")
                }
            }), V.widget("ui.selectable", V.ui.mouse, {
                version: "1.13.2",
                options: {
                    appendTo: "body",
                    autoRefresh: !0,
                    distance: 0,
                    filter: "*",
                    tolerance: "touch",
                    selected: null,
                    selecting: null,
                    start: null,
                    stop: null,
                    unselected: null,
                    unselecting: null
                },
                _create: function() {
                    var i = this;
                    this._addClass("ui-selectable"), this.dragged = !1, this.refresh = function() {
                        i.elementPos = V(i.element[0]).offset(), i.selectees = V(i.options.filter, i.element[0]), i._addClass(i.selectees, "ui-selectee"), i.selectees.each(function() {
                            var t = V(this),
                                e = t.offset(),
                                e = {
                                    left: e.left - i.elementPos.left,
                                    top: e.top - i.elementPos.top
                                };
                            V.data(this, "selectable-item", {
                                element: this,
                                $element: t,
                                left: e.left,
                                top: e.top,
                                right: e.left + t.outerWidth(),
                                bottom: e.top + t.outerHeight(),
                                startselected: !1,
                                selected: t.hasClass("ui-selected"),
                                selecting: t.hasClass("ui-selecting"),
                                unselecting: t.hasClass("ui-unselecting")
                            })
                        })
                    }, this.refresh(), this._mouseInit(), this.helper = V("<div>"), this._addClass(this.helper, "ui-selectable-helper")
                },
                _destroy: function() {
                    this.selectees.removeData("selectable-item"), this._mouseDestroy()
                },
                _mouseStart: function(i) {
                    var s = this,
                        t = this.options;
                    this.opos = [i.pageX, i.pageY], this.elementPos = V(this.element[0]).offset(), this.options.disabled || (this.selectees = V(t.filter, this.element[0]), this._trigger("start", i), V(t.appendTo).append(this.helper), this.helper.css({
                        left: i.pageX,
                        top: i.pageY,
                        width: 0,
                        height: 0
                    }), t.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function() {
                        var t = V.data(this, "selectable-item");
                        t.startselected = !0, i.metaKey || i.ctrlKey || (s._removeClass(t.$element, "ui-selected"), t.selected = !1, s._addClass(t.$element, "ui-unselecting"), t.unselecting = !0, s._trigger("unselecting", i, {
                            unselecting: t.element
                        }))
                    }), V(i.target).parents().addBack().each(function() {
                        var t, e = V.data(this, "selectable-item");
                        if (e) return t = !i.metaKey && !i.ctrlKey || !e.$element.hasClass("ui-selected"), s._removeClass(e.$element, t ? "ui-unselecting" : "ui-selected")._addClass(e.$element, t ? "ui-selecting" : "ui-unselecting"), e.unselecting = !t, e.selecting = t, (e.selected = t) ? s._trigger("selecting", i, {
                            selecting: e.element
                        }) : s._trigger("unselecting", i, {
                            unselecting: e.element
                        }), !1
                    }))
                },
                _mouseDrag: function(s) {
                    if (this.dragged = !0, !this.options.disabled) {
                        var t, n = this,
                            o = this.options,
                            a = this.opos[0],
                            r = this.opos[1],
                            l = s.pageX,
                            h = s.pageY;
                        return l < a && (t = l, l = a, a = t), h < r && (t = h, h = r, r = t), this.helper.css({
                            left: a,
                            top: r,
                            width: l - a,
                            height: h - r
                        }), this.selectees.each(function() {
                            var t = V.data(this, "selectable-item"),
                                e = !1,
                                i = {};
                            t && t.element !== n.element[0] && (i.left = t.left + n.elementPos.left, i.right = t.right + n.elementPos.left, i.top = t.top + n.elementPos.top, i.bottom = t.bottom + n.elementPos.top, "touch" === o.tolerance ? e = !(i.left > l || i.right < a || i.top > h || i.bottom < r) : "fit" === o.tolerance && (e = i.left > a && i.right < l && i.top > r && i.bottom < h), e ? (t.selected && (n._removeClass(t.$element, "ui-selected"), t.selected = !1), t.unselecting && (n._removeClass(t.$element, "ui-unselecting"), t.unselecting = !1), t.selecting || (n._addClass(t.$element, "ui-selecting"), t.selecting = !0, n._trigger("selecting", s, {
                                selecting: t.element
                            }))) : (t.selecting && ((s.metaKey || s.ctrlKey) && t.startselected ? (n._removeClass(t.$element, "ui-selecting"), t.selecting = !1, n._addClass(t.$element, "ui-selected"), t.selected = !0) : (n._removeClass(t.$element, "ui-selecting"), t.selecting = !1, t.startselected && (n._addClass(t.$element, "ui-unselecting"), t.unselecting = !0), n._trigger("unselecting", s, {
                                unselecting: t.element
                            }))), t.selected && (s.metaKey || s.ctrlKey || t.startselected || (n._removeClass(t.$element, "ui-selected"), t.selected = !1, n._addClass(t.$element, "ui-unselecting"), t.unselecting = !0, n._trigger("unselecting", s, {
                                unselecting: t.element
                            })))))
                        }), !1
                    }
                },
                _mouseStop: function(e) {
                    var i = this;
                    return this.dragged = !1, V(".ui-unselecting", this.element[0]).each(function() {
                        var t = V.data(this, "selectable-item");
                        i._removeClass(t.$element, "ui-unselecting"), t.unselecting = !1, t.startselected = !1, i._trigger("unselected", e, {
                            unselected: t.element
                        })
                    }), V(".ui-selecting", this.element[0]).each(function() {
                        var t = V.data(this, "selectable-item");
                        i._removeClass(t.$element, "ui-selecting")._addClass(t.$element, "ui-selected"), t.selecting = !1, t.selected = !0, t.startselected = !0, i._trigger("selected", e, {
                            selected: t.element
                        })
                    }), this._trigger("stop", e), this.helper.remove(), !1
                }
            }), V.widget("ui.selectmenu", [V.ui.formResetMixin, {
                version: "1.13.2",
                defaultElement: "<select>",
                options: {
                    appendTo: null,
                    classes: {
                        "ui-selectmenu-button-open": "ui-corner-top",
                        "ui-selectmenu-button-closed": "ui-corner-all"
                    },
                    disabled: null,
                    icons: {
                        button: "ui-icon-triangle-1-s"
                    },
                    position: {
                        my: "left top",
                        at: "left bottom",
                        collision: "none"
                    },
                    width: !1,
                    change: null,
                    close: null,
                    focus: null,
                    open: null,
                    select: null
                },
                _create: function() {
                    var t = this.element.uniqueId().attr("id");
                    this.ids = {
                        element: t,
                        button: t + "-button",
                        menu: t + "-menu"
                    }, this._drawButton(), this._drawMenu(), this._bindFormResetHandler(), this._rendered = !1, this.menuItems = V()
                },
                _drawButton: function() {
                    var t, e = this,
                        i = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);
                    this.labels = this.element.labels().attr("for", this.ids.button), this._on(this.labels, {
                        click: function(t) {
                            this.button.trigger("focus"), t.preventDefault()
                        }
                    }), this.element.hide(), this.button = V("<span>", {
                        tabindex: this.options.disabled ? -1 : 0,
                        id: this.ids.button,
                        role: "combobox",
                        "aria-expanded": "false",
                        "aria-autocomplete": "list",
                        "aria-owns": this.ids.menu,
                        "aria-haspopup": "true",
                        title: this.element.attr("title")
                    }).insertAfter(this.element), this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget"), t = V("<span>").appendTo(this.button), this._addClass(t, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button), this.buttonItem = this._renderButtonItem(i).appendTo(this.button), !1 !== this.options.width && this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function() {
                        e._rendered || e._refreshMenu()
                    })
                },
                _drawMenu: function() {
                    var i = this;
                    this.menu = V("<ul>", {
                        "aria-hidden": "true",
                        "aria-labelledby": this.ids.button,
                        id: this.ids.menu
                    }), this.menuWrap = V("<div>").append(this.menu), this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front"), this.menuWrap.appendTo(this._appendTo()), this.menuInstance = this.menu.menu({
                        classes: {
                            "ui-menu": "ui-corner-bottom"
                        },
                        role: "listbox",
                        select: function(t, e) {
                            t.preventDefault(), i._setSelection(), i._select(e.item.data("ui-selectmenu-item"), t)
                        },
                        focus: function(t, e) {
                            e = e.item.data("ui-selectmenu-item");
                            null != i.focusIndex && e.index !== i.focusIndex && (i._trigger("focus", t, {
                                item: e
                            }), i.isOpen || i._select(e, t)), i.focusIndex = e.index, i.button.attr("aria-activedescendant", i.menuItems.eq(e.index).attr("id"))
                        }
                    }).menu("instance"), this.menuInstance._off(this.menu, "mouseleave"), this.menuInstance._closeOnDocumentClick = function() {
                        return !1
                    }, this.menuInstance._isDivider = function() {
                        return !1
                    }
                },
                refresh: function() {
                    this._refreshMenu(), this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {})), null === this.options.width && this._resizeButton()
                },
                _refreshMenu: function() {
                    var t = this.element.find("option");
                    this.menu.empty(), this._parseOptions(t), this._renderMenu(this.menu, this.items), this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"), this._rendered = !0, t.length && (t = this._getSelectedItem(), this.menuInstance.focus(null, t), this._setAria(t.data("ui-selectmenu-item")), this._setOption("disabled", this.element.prop("disabled")))
                },
                open: function(t) {
                    this.options.disabled || (this._rendered ? (this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), this.menuItems.length && (this.isOpen = !0, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), this._trigger("open", t)))
                },
                _position: function() {
                    this.menuWrap.position(V.extend({
                        of: this.button
                    }, this.options.position))
                },
                close: function(t) {
                    this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this._off(this.document), this._trigger("close", t))
                },
                widget: function() {
                    return this.button
                },
                menuWidget: function() {
                    return this.menu
                },
                _renderButtonItem: function(t) {
                    var e = V("<span>");
                    return this._setText(e, t.label), this._addClass(e, "ui-selectmenu-text"), e
                },
                _renderMenu: function(s, t) {
                    var n = this,
                        o = "";
                    V.each(t, function(t, e) {
                        var i;
                        e.optgroup !== o && (i = V("<li>", {
                            text: e.optgroup
                        }), n._addClass(i, "ui-selectmenu-optgroup", "ui-menu-divider" + (e.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : "")), i.appendTo(s), o = e.optgroup), n._renderItemData(s, e)
                    })
                },
                _renderItemData: function(t, e) {
                    return this._renderItem(t, e).data("ui-selectmenu-item", e)
                },
                _renderItem: function(t, e) {
                    var i = V("<li>"),
                        s = V("<div>", {
                            title: e.element.attr("title")
                        });
                    return e.disabled && this._addClass(i, null, "ui-state-disabled"), this._setText(s, e.label), i.append(s).appendTo(t)
                },
                _setText: function(t, e) {
                    e ? t.text(e) : t.html("&#160;")
                },
                _move: function(t, e) {
                    var i, s = ".ui-menu-item";
                    this.isOpen ? i = this.menuItems.eq(this.focusIndex).parent("li") : (i = this.menuItems.eq(this.element[0].selectedIndex).parent("li"), s += ":not(.ui-state-disabled)"), (s = "first" === t || "last" === t ? i["first" === t ? "prevAll" : "nextAll"](s).eq(-1) : i[t + "All"](s).eq(0)).length && this.menuInstance.focus(e, s)
                },
                _getSelectedItem: function() {
                    return this.menuItems.eq(this.element[0].selectedIndex).parent("li")
                },
                _toggle: function(t) {
                    this[this.isOpen ? "close" : "open"](t)
                },
                _setSelection: function() {
                    var t;
                    this.range && (window.getSelection ? ((t = window.getSelection()).removeAllRanges(), t.addRange(this.range)) : this.range.select(), this.button.trigger("focus"))
                },
                _documentClick: {
                    mousedown: function(t) {
                        this.isOpen && (V(t.target).closest(".ui-selectmenu-menu, #" + V.escapeSelector(this.ids.button)).length || this.close(t))
                    }
                },
                _buttonEvents: {
                    mousedown: function() {
                        var t;
                        window.getSelection ? (t = window.getSelection()).rangeCount && (this.range = t.getRangeAt(0)) : this.range = document.selection.createRange()
                    },
                    click: function(t) {
                        this._setSelection(), this._toggle(t)
                    },
                    keydown: function(t) {
                        var e = !0;
                        switch (t.keyCode) {
                            case V.ui.keyCode.TAB:
                            case V.ui.keyCode.ESCAPE:
                                this.close(t), e = !1;
                                break;
                            case V.ui.keyCode.ENTER:
                                this.isOpen && this._selectFocusedItem(t);
                                break;
                            case V.ui.keyCode.UP:
                                t.altKey ? this._toggle(t) : this._move("prev", t);
                                break;
                            case V.ui.keyCode.DOWN:
                                t.altKey ? this._toggle(t) : this._move("next", t);
                                break;
                            case V.ui.keyCode.SPACE:
                                this.isOpen ? this._selectFocusedItem(t) : this._toggle(t);
                                break;
                            case V.ui.keyCode.LEFT:
                                this._move("prev", t);
                                break;
                            case V.ui.keyCode.RIGHT:
                                this._move("next", t);
                                break;
                            case V.ui.keyCode.HOME:
                            case V.ui.keyCode.PAGE_UP:
                                this._move("first", t);
                                break;
                            case V.ui.keyCode.END:
                            case V.ui.keyCode.PAGE_DOWN:
                                this._move("last", t);
                                break;
                            default:
                                this.menu.trigger(t), e = !1
                        }
                        e && t.preventDefault()
                    }
                },
                _selectFocusedItem: function(t) {
                    var e = this.menuItems.eq(this.focusIndex).parent("li");
                    e.hasClass("ui-state-disabled") || this._select(e.data("ui-selectmenu-item"), t)
                },
                _select: function(t, e) {
                    var i = this.element[0].selectedIndex;
                    this.element[0].selectedIndex = t.index, this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(t)), this._setAria(t), this._trigger("select", e, {
                        item: t
                    }), t.index !== i && this._trigger("change", e, {
                        item: t
                    }), this.close(e)
                },
                _setAria: function(t) {
                    t = this.menuItems.eq(t.index).attr("id");
                    this.button.attr({
                        "aria-labelledby": t,
                        "aria-activedescendant": t
                    }), this.menu.attr("aria-activedescendant", t)
                },
                _setOption: function(t, e) {
                    var i;
                    "icons" === t && (i = this.button.find("span.ui-icon"), this._removeClass(i, null, this.options.icons.button)._addClass(i, null, e.button)), this._super(t, e), "appendTo" === t && this.menuWrap.appendTo(this._appendTo()), "width" === t && this._resizeButton()
                },
                _setOptionDisabled: function(t) {
                    this._super(t), this.menuInstance.option("disabled", t), this.button.attr("aria-disabled", t), this._toggleClass(this.button, null, "ui-state-disabled", t), this.element.prop("disabled", t), t ? (this.button.attr("tabindex", -1), this.close()) : this.button.attr("tabindex", 0)
                },
                _appendTo: function() {
                    var t = this.options.appendTo;
                    return t = !(t = !(t = t && (t.jquery || t.nodeType ? V(t) : this.document.find(t).eq(0))) || !t[0] ? this.element.closest(".ui-front, dialog") : t).length ? this.document[0].body : t
                },
                _toggleAttr: function() {
                    this.button.attr("aria-expanded", this.isOpen), this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen), this.menu.attr("aria-hidden", !this.isOpen)
                },
                _resizeButton: function() {
                    var t = this.options.width;
                    !1 !== t ? (null === t && (t = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(t)) : this.button.css("width", "")
                },
                _resizeMenu: function() {
                    this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1))
                },
                _getCreateOptions: function() {
                    var t = this._super();
                    return t.disabled = this.element.prop("disabled"), t
                },
                _parseOptions: function(t) {
                    var i = this,
                        s = [];
                    t.each(function(t, e) {
                        e.hidden || s.push(i._parseOption(V(e), t))
                    }), this.items = s
                },
                _parseOption: function(t, e) {
                    var i = t.parent("optgroup");
                    return {
                        element: t,
                        index: e,
                        value: t.val(),
                        label: t.text(),
                        optgroup: i.attr("label") || "",
                        disabled: i.prop("disabled") || t.prop("disabled")
                    }
                },
                _destroy: function() {
                    this._unbindFormResetHandler(), this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), this.labels.attr("for", this.ids.element)
                }
            }]), V.widget("ui.slider", V.ui.mouse, {
                version: "1.13.2",
                widgetEventPrefix: "slide",
                options: {
                    animate: !1,
                    classes: {
                        "ui-slider": "ui-corner-all",
                        "ui-slider-handle": "ui-corner-all",
                        "ui-slider-range": "ui-corner-all ui-widget-header"
                    },
                    distance: 0,
                    max: 100,
                    min: 0,
                    orientation: "horizontal",
                    range: !1,
                    step: 1,
                    value: 0,
                    values: null,
                    change: null,
                    slide: null,
                    start: null,
                    stop: null
                },
                numPages: 5,
                _create: function() {
                    this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1
                },
                _refresh: function() {
                    this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
                },
                _createHandles: function() {
                    var t, e = this.options,
                        i = this.element.find(".ui-slider-handle"),
                        s = [],
                        n = e.values && e.values.length || 1;
                    for (i.length > n && (i.slice(n).remove(), i = i.slice(0, n)), t = i.length; t < n; t++) s.push("<span tabindex='0'></span>");
                    this.handles = i.add(V(s.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function(t) {
                        V(this).data("ui-slider-handle-index", t).attr("tabIndex", 0)
                    })
                },
                _createRange: function() {
                    var t = this.options;
                    t.range ? (!0 === t.range && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : Array.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
                        left: "",
                        bottom: ""
                    })) : (this.range = V("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t.range && "max" !== t.range || this._addClass(this.range, "ui-slider-range-" + t.range)) : (this.range && this.range.remove(), this.range = null)
                },
                _setupEvents: function() {
                    this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
                },
                _destroy: function() {
                    this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy()
                },
                _mouseCapture: function(t) {
                    var i, s, n, o, e, a, r = this,
                        l = this.options;
                    return !l.disabled && (this.elementSize = {
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight()
                    }, this.elementOffset = this.element.offset(), a = {
                        x: t.pageX,
                        y: t.pageY
                    }, i = this._normValueFromMouse(a), s = this._valueMax() - this._valueMin() + 1, this.handles.each(function(t) {
                        var e = Math.abs(i - r.values(t));
                        (e < s || s === e && (t === r._lastChangedValue || r.values(t) === l.min)) && (s = e, n = V(this), o = t)
                    }), !1 !== this._start(t, o) && (this._mouseSliding = !0, this._handleIndex = o, this._addClass(n, null, "ui-state-active"), n.trigger("focus"), e = n.offset(), a = !V(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = a ? {
                        left: 0,
                        top: 0
                    } : {
                        left: t.pageX - e.left - n.width() / 2,
                        top: t.pageY - e.top - n.height() / 2 - (parseInt(n.css("borderTopWidth"), 10) || 0) - (parseInt(n.css("borderBottomWidth"), 10) || 0) + (parseInt(n.css("marginTop"), 10) || 0)
                    }, this.handles.hasClass("ui-state-hover") || this._slide(t, o, i), this._animateOff = !0))
                },
                _mouseStart: function() {
                    return !0
                },
                _mouseDrag: function(t) {
                    var e = {
                            x: t.pageX,
                            y: t.pageY
                        },
                        e = this._normValueFromMouse(e);
                    return this._slide(t, this._handleIndex, e), !1
                },
                _mouseStop: function(t) {
                    return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(t, this._handleIndex), this._change(t, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1
                },
                _detectOrientation: function() {
                    this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
                },
                _normValueFromMouse: function(t) {
                    var e, t = "horizontal" === this.orientation ? (e = this.elementSize.width, t.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (e = this.elementSize.height, t.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)),
                        t = t / e;
                    return (t = 1 < t ? 1 : t) < 0 && (t = 0), "vertical" === this.orientation && (t = 1 - t), e = this._valueMax() - this._valueMin(), e = this._valueMin() + t * e, this._trimAlignValue(e)
                },
                _uiHash: function(t, e, i) {
                    var s = {
                        handle: this.handles[t],
                        handleIndex: t,
                        value: void 0 !== e ? e : this.value()
                    };
                    return this._hasMultipleValues() && (s.value = void 0 !== e ? e : this.values(t), s.values = i || this.values()), s
                },
                _hasMultipleValues: function() {
                    return this.options.values && this.options.values.length
                },
                _start: function(t, e) {
                    return this._trigger("start", t, this._uiHash(e))
                },
                _slide: function(t, e, i) {
                    var s, n = this.value(),
                        o = this.values();
                    this._hasMultipleValues() && (s = this.values(e ? 0 : 1), n = this.values(e), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === e ? Math.min(s, i) : Math.max(s, i)), o[e] = i), i !== n && !1 !== this._trigger("slide", t, this._uiHash(e, i, o)) && (this._hasMultipleValues() ? this.values(e, i) : this.value(i))
                },
                _stop: function(t, e) {
                    this._trigger("stop", t, this._uiHash(e))
                },
                _change: function(t, e) {
                    this._keySliding || this._mouseSliding || (this._lastChangedValue = e, this._trigger("change", t, this._uiHash(e)))
                },
                value: function(t) {
                    return arguments.length ? (this.options.value = this._trimAlignValue(t), this._refreshValue(), void this._change(null, 0)) : this._value()
                },
                values: function(t, e) {
                    var i, s, n;
                    if (1 < arguments.length) return this.options.values[t] = this._trimAlignValue(e), this._refreshValue(), void this._change(null, t);
                    if (!arguments.length) return this._values();
                    if (!Array.isArray(t)) return this._hasMultipleValues() ? this._values(t) : this.value();
                    for (i = this.options.values, s = t, n = 0; n < i.length; n += 1) i[n] = this._trimAlignValue(s[n]), this._change(null, n);
                    this._refreshValue()
                },
                _setOption: function(t, e) {
                    var i, s = 0;
                    switch ("range" === t && !0 === this.options.range && ("min" === e ? (this.options.value = this._values(0), this.options.values = null) : "max" === e && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), Array.isArray(this.options.values) && (s = this.options.values.length), this._super(t, e), t) {
                        case "orientation":
                            this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(e), this.handles.css("horizontal" === e ? "bottom" : "left", "");
                            break;
                        case "value":
                            this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                            break;
                        case "values":
                            for (this._animateOff = !0, this._refreshValue(), i = s - 1; 0 <= i; i--) this._change(null, i);
                            this._animateOff = !1;
                            break;
                        case "step":
                        case "min":
                        case "max":
                            this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
                            break;
                        case "range":
                            this._animateOff = !0, this._refresh(), this._animateOff = !1
                    }
                },
                _setOptionDisabled: function(t) {
                    this._super(t), this._toggleClass(null, "ui-state-disabled", !!t)
                },
                _value: function() {
                    var t = this.options.value;
                    return t = this._trimAlignValue(t)
                },
                _values: function(t) {
                    var e, i;
                    if (arguments.length) return t = this.options.values[t], t = this._trimAlignValue(t);
                    if (this._hasMultipleValues()) {
                        for (e = this.options.values.slice(), i = 0; i < e.length; i += 1) e[i] = this._trimAlignValue(e[i]);
                        return e
                    }
                    return []
                },
                _trimAlignValue: function(t) {
                    if (t <= this._valueMin()) return this._valueMin();
                    if (t >= this._valueMax()) return this._valueMax();
                    var e = 0 < this.options.step ? this.options.step : 1,
                        i = (t - this._valueMin()) % e,
                        t = t - i;
                    return 2 * Math.abs(i) >= e && (t += 0 < i ? e : -e), parseFloat(t.toFixed(5))
                },
                _calculateNewMax: function() {
                    var t = this.options.max,
                        e = this._valueMin(),
                        i = this.options.step;
                    (t = Math.round((t - e) / i) * i + e) > this.options.max && (t -= i), this.max = parseFloat(t.toFixed(this._precision()))
                },
                _precision: function() {
                    var t = this._precisionOf(this.options.step);
                    return t = null !== this.options.min ? Math.max(t, this._precisionOf(this.options.min)) : t
                },
                _precisionOf: function(t) {
                    var e = t.toString(),
                        t = e.indexOf(".");
                    return -1 === t ? 0 : e.length - t - 1
                },
                _valueMin: function() {
                    return this.options.min
                },
                _valueMax: function() {
                    return this.max
                },
                _refreshRange: function(t) {
                    "vertical" === t && this.range.css({
                        width: "",
                        left: ""
                    }), "horizontal" === t && this.range.css({
                        height: "",
                        bottom: ""
                    })
                },
                _refreshValue: function() {
                    var e, i, t, s, n, o = this.options.range,
                        a = this.options,
                        r = this,
                        l = !this._animateOff && a.animate,
                        h = {};
                    this._hasMultipleValues() ? this.handles.each(function(t) {
                        i = (r.values(t) - r._valueMin()) / (r._valueMax() - r._valueMin()) * 100, h["horizontal" === r.orientation ? "left" : "bottom"] = i + "%", V(this).stop(1, 1)[l ? "animate" : "css"](h, a.animate), !0 === r.options.range && ("horizontal" === r.orientation ? (0 === t && r.range.stop(1, 1)[l ? "animate" : "css"]({
                            left: i + "%"
                        }, a.animate), 1 === t && r.range[l ? "animate" : "css"]({
                            width: i - e + "%"
                        }, {
                            queue: !1,
                            duration: a.animate
                        })) : (0 === t && r.range.stop(1, 1)[l ? "animate" : "css"]({
                            bottom: i + "%"
                        }, a.animate), 1 === t && r.range[l ? "animate" : "css"]({
                            height: i - e + "%"
                        }, {
                            queue: !1,
                            duration: a.animate
                        }))), e = i
                    }) : (t = this.value(), s = this._valueMin(), n = this._valueMax(), i = n !== s ? (t - s) / (n - s) * 100 : 0, h["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[l ? "animate" : "css"](h, a.animate), "min" === o && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
                        width: i + "%"
                    }, a.animate), "max" === o && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
                        width: 100 - i + "%"
                    }, a.animate), "min" === o && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
                        height: i + "%"
                    }, a.animate), "max" === o && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
                        height: 100 - i + "%"
                    }, a.animate))
                },
                _handleEvents: {
                    keydown: function(t) {
                        var e, i, s, n = V(t.target).data("ui-slider-handle-index");
                        switch (t.keyCode) {
                            case V.ui.keyCode.HOME:
                            case V.ui.keyCode.END:
                            case V.ui.keyCode.PAGE_UP:
                            case V.ui.keyCode.PAGE_DOWN:
                            case V.ui.keyCode.UP:
                            case V.ui.keyCode.RIGHT:
                            case V.ui.keyCode.DOWN:
                            case V.ui.keyCode.LEFT:
                                if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(V(t.target), null, "ui-state-active"), !1 === this._start(t, n))) return
                        }
                        switch (s = this.options.step, e = i = this._hasMultipleValues() ? this.values(n) : this.value(), t.keyCode) {
                            case V.ui.keyCode.HOME:
                                i = this._valueMin();
                                break;
                            case V.ui.keyCode.END:
                                i = this._valueMax();
                                break;
                            case V.ui.keyCode.PAGE_UP:
                                i = this._trimAlignValue(e + (this._valueMax() - this._valueMin()) / this.numPages);
                                break;
                            case V.ui.keyCode.PAGE_DOWN:
                                i = this._trimAlignValue(e - (this._valueMax() - this._valueMin()) / this.numPages);
                                break;
                            case V.ui.keyCode.UP:
                            case V.ui.keyCode.RIGHT:
                                if (e === this._valueMax()) return;
                                i = this._trimAlignValue(e + s);
                                break;
                            case V.ui.keyCode.DOWN:
                            case V.ui.keyCode.LEFT:
                                if (e === this._valueMin()) return;
                                i = this._trimAlignValue(e - s)
                        }
                        this._slide(t, n, i)
                    },
                    keyup: function(t) {
                        var e = V(t.target).data("ui-slider-handle-index");
                        this._keySliding && (this._keySliding = !1, this._stop(t, e), this._change(t, e), this._removeClass(V(t.target), null, "ui-state-active"))
                    }
                }
            }), V.widget("ui.sortable", V.ui.mouse, {
                version: "1.13.2",
                widgetEventPrefix: "sort",
                ready: !1,
                options: {
                    appendTo: "parent",
                    axis: !1,
                    connectWith: !1,
                    containment: !1,
                    cursor: "auto",
                    cursorAt: !1,
                    dropOnEmpty: !0,
                    forcePlaceholderSize: !1,
                    forceHelperSize: !1,
                    grid: !1,
                    handle: !1,
                    helper: "original",
                    items: "> *",
                    opacity: !1,
                    placeholder: !1,
                    revert: !1,
                    scroll: !0,
                    scrollSensitivity: 20,
                    scrollSpeed: 20,
                    scope: "default",
                    tolerance: "intersect",
                    zIndex: 1e3,
                    activate: null,
                    beforeStop: null,
                    change: null,
                    deactivate: null,
                    out: null,
                    over: null,
                    receive: null,
                    remove: null,
                    sort: null,
                    start: null,
                    stop: null,
                    update: null
                },
                _isOverAxis: function(t, e, i) {
                    return e <= t && t < e + i
                },
                _isFloating: function(t) {
                    return /left|right/.test(t.css("float")) || /inline|table-cell/.test(t.css("display"))
                },
                _create: function() {
                    this.containerCache = {}, this._addClass("ui-sortable"), this.refresh(), this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = !0
                },
                _setOption: function(t, e) {
                    this._super(t, e), "handle" === t && this._setHandleClassName()
                },
                _setHandleClassName: function() {
                    var t = this;
                    this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle"), V.each(this.items, function() {
                        t._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle")
                    })
                },
                _destroy: function() {
                    this._mouseDestroy();
                    for (var t = this.items.length - 1; 0 <= t; t--) this.items[t].item.removeData(this.widgetName + "-item");
                    return this
                },
                _mouseCapture: function(t, e) {
                    var i = null,
                        s = !1,
                        n = this;
                    return !this.reverting && (!this.options.disabled && "static" !== this.options.type && (this._refreshItems(t), V(t.target).parents().each(function() {
                        if (V.data(this, n.widgetName + "-item") === n) return i = V(this), !1
                    }), !!(i = V.data(t.target, n.widgetName + "-item") === n ? V(t.target) : i) && (!(this.options.handle && !e && (V(this.options.handle, i).find("*").addBack().each(function() {
                        this === t.target && (s = !0)
                    }), !s)) && (this.currentItem = i, this._removeCurrentsFromItems(), !0))))
                },
                _mouseStart: function(t, e, i) {
                    var s, n, o = this.options;
                    if ((this.currentContainer = this).refreshPositions(), this.appendTo = V("parent" !== o.appendTo ? o.appendTo : this.currentItem.parent()), this.helper = this._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(), this.offset = this.currentItem.offset(), this.offset = {
                            top: this.offset.top - this.margins.top,
                            left: this.offset.left - this.margins.left
                        }, V.extend(this.offset, {
                            click: {
                                left: t.pageX - this.offset.left,
                                top: t.pageY - this.offset.top
                            },
                            relative: this._getRelativeOffset()
                        }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this.domPosition = {
                            prev: this.currentItem.prev()[0],
                            parent: this.currentItem.parent()[0]
                        }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), this.scrollParent = this.placeholder.scrollParent(), V.extend(this.offset, {
                            parent: this._getParentOffset()
                        }), o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (n = this.document.find("body"), this.storedCursor = n.css("cursor"), n.css("cursor", o.cursor), this.storedStylesheet = V("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(n)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o.opacity)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !i)
                        for (s = this.containers.length - 1; 0 <= s; s--) this.containers[s]._trigger("activate", t, this._uiHash(this));
                    return V.ui.ddmanager && (V.ui.ddmanager.current = this), V.ui.ddmanager && !o.dropBehaviour && V.ui.ddmanager.prepareOffsets(this, t), this.dragging = !0, this._addClass(this.helper, "ui-sortable-helper"), this.helper.parent().is(this.appendTo) || (this.helper.detach().appendTo(this.appendTo), this.offset.parent = this._getParentOffset()), this.position = this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, this.lastPositionAbs = this.positionAbs = this._convertPositionTo("absolute"), this._mouseDrag(t), !0
                },
                _scroll: function(t) {
                    var e = this.options,
                        i = !1;
                    return this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < e.scrollSensitivity ? this.scrollParent[0].scrollTop = i = this.scrollParent[0].scrollTop + e.scrollSpeed : t.pageY - this.overflowOffset.top < e.scrollSensitivity && (this.scrollParent[0].scrollTop = i = this.scrollParent[0].scrollTop - e.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < e.scrollSensitivity ? this.scrollParent[0].scrollLeft = i = this.scrollParent[0].scrollLeft + e.scrollSpeed : t.pageX - this.overflowOffset.left < e.scrollSensitivity && (this.scrollParent[0].scrollLeft = i = this.scrollParent[0].scrollLeft - e.scrollSpeed)) : (t.pageY - this.document.scrollTop() < e.scrollSensitivity ? i = this.document.scrollTop(this.document.scrollTop() - e.scrollSpeed) : this.window.height() - (t.pageY - this.document.scrollTop()) < e.scrollSensitivity && (i = this.document.scrollTop(this.document.scrollTop() + e.scrollSpeed)), t.pageX - this.document.scrollLeft() < e.scrollSensitivity ? i = this.document.scrollLeft(this.document.scrollLeft() - e.scrollSpeed) : this.window.width() - (t.pageX - this.document.scrollLeft()) < e.scrollSensitivity && (i = this.document.scrollLeft(this.document.scrollLeft() + e.scrollSpeed))), i
                },
                _mouseDrag: function(t) {
                    var e, i, s, n, o = this.options;
                    for (this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), o.scroll && !1 !== this._scroll(t) && (this._refreshItemPositions(!0), V.ui.ddmanager && !o.dropBehaviour && V.ui.ddmanager.prepareOffsets(this, t)), this.dragDirection = {
                            vertical: this._getDragVerticalDirection(),
                            horizontal: this._getDragHorizontalDirection()
                        }, e = this.items.length - 1; 0 <= e; e--)
                        if (s = (i = this.items[e]).item[0], (n = this._intersectsWithPointer(i)) && i.instance === this.currentContainer && !(s === this.currentItem[0] || this.placeholder[1 === n ? "next" : "prev"]()[0] === s || V.contains(this.placeholder[0], s) || "semi-dynamic" === this.options.type && V.contains(this.element[0], s))) {
                            if (this.direction = 1 === n ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(i)) break;
                            this._rearrange(t, i), this._trigger("change", t, this._uiHash());
                            break
                        }
                    return this._contactContainers(t), V.ui.ddmanager && V.ui.ddmanager.drag(this, t), this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
                },
                _mouseStop: function(t, e) {
                    var i, s, n, o;
                    if (t) return V.ui.ddmanager && !this.options.dropBehaviour && V.ui.ddmanager.drop(this, t), this.options.revert ? (s = (i = this).placeholder.offset(), o = {}, (n = this.options.axis) && "x" !== n || (o.left = s.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), n && "y" !== n || (o.top = s.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, V(this.helper).animate(o, parseInt(this.options.revert, 10) || 500, function() {
                        i._clear(t)
                    })) : this._clear(t, e), !1
                },
                cancel: function() {
                    if (this.dragging) {
                        this._mouseUp(new V.Event("mouseup", {
                            target: null
                        })), "original" === this.options.helper ? (this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")) : this.currentItem.show();
                        for (var t = this.containers.length - 1; 0 <= t; t--) this.containers[t]._trigger("deactivate", null, this._uiHash(this)), this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), this.containers[t].containerCache.over = 0)
                    }
                    return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), V.extend(this, {
                        helper: null,
                        dragging: !1,
                        reverting: !1,
                        _noFinalSort: null
                    }), this.domPosition.prev ? V(this.domPosition.prev).after(this.currentItem) : V(this.domPosition.parent).prepend(this.currentItem)), this
                },
                serialize: function(e) {
                    var t = this._getItemsAsjQuery(e && e.connected),
                        i = [];
                    return e = e || {}, V(t).each(function() {
                        var t = (V(e.item || this).attr(e.attribute || "id") || "").match(e.expression || /(.+)[\-=_](.+)/);
                        t && i.push((e.key || t[1] + "[]") + "=" + (e.key && e.expression ? t[1] : t[2]))
                    }), !i.length && e.key && i.push(e.key + "="), i.join("&")
                },
                toArray: function(t) {
                    var e = this._getItemsAsjQuery(t && t.connected),
                        i = [];
                    return t = t || {}, e.each(function() {
                        i.push(V(t.item || this).attr(t.attribute || "id") || "")
                    }), i
                },
                _intersectsWith: function(t) {
                    var e = this.positionAbs.left,
                        i = e + this.helperProportions.width,
                        s = this.positionAbs.top,
                        n = s + this.helperProportions.height,
                        o = t.left,
                        a = o + t.width,
                        r = t.top,
                        l = r + t.height,
                        h = this.offset.click.top,
                        c = this.offset.click.left,
                        h = "x" === this.options.axis || r < s + h && s + h < l,
                        c = "y" === this.options.axis || o < e + c && e + c < a;
                    return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > t[this.floating ? "width" : "height"] ? h && c : o < e + this.helperProportions.width / 2 && i - this.helperProportions.width / 2 < a && r < s + this.helperProportions.height / 2 && n - this.helperProportions.height / 2 < l
                },
                _intersectsWithPointer: function(t) {
                    var e = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top, t.height),
                        t = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left, t.width);
                    return !(!e || !t) && (e = this.dragDirection.vertical, t = this.dragDirection.horizontal, this.floating ? "right" === t || "down" === e ? 2 : 1 : e && ("down" === e ? 2 : 1))
                },
                _intersectsWithSides: function(t) {
                    var e = this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top + t.height / 2, t.height),
                        i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left + t.width / 2, t.width),
                        s = this.dragDirection.vertical,
                        t = this.dragDirection.horizontal;
                    return this.floating && t ? "right" === t && i || "left" === t && !i : s && ("down" === s && e || "up" === s && !e)
                },
                _getDragVerticalDirection: function() {
                    var t = this.positionAbs.top - this.lastPositionAbs.top;
                    return 0 != t && (0 < t ? "down" : "up")
                },
                _getDragHorizontalDirection: function() {
                    var t = this.positionAbs.left - this.lastPositionAbs.left;
                    return 0 != t && (0 < t ? "right" : "left")
                },
                refresh: function(t) {
                    return this._refreshItems(t), this._setHandleClassName(), this.refreshPositions(), this
                },
                _connectWith: function() {
                    var t = this.options;
                    return t.connectWith.constructor === String ? [t.connectWith] : t.connectWith
                },
                _getItemsAsjQuery: function(t) {
                    var e, i, s, n, o = [],
                        a = [],
                        r = this._connectWith();
                    if (r && t)
                        for (e = r.length - 1; 0 <= e; e--)
                            for (i = (s = V(r[e], this.document[0])).length - 1; 0 <= i; i--)(n = V.data(s[i], this.widgetFullName)) && n !== this && !n.options.disabled && a.push(["function" == typeof n.options.items ? n.options.items.call(n.element) : V(n.options.items, n.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), n]);

                    function l() {
                        o.push(this)
                    }
                    for (a.push(["function" == typeof this.options.items ? this.options.items.call(this.element, null, {
                            options: this.options,
                            item: this.currentItem
                        }) : V(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), e = a.length - 1; 0 <= e; e--) a[e][0].each(l);
                    return V(o)
                },
                _removeCurrentsFromItems: function() {
                    var i = this.currentItem.find(":data(" + this.widgetName + "-item)");
                    this.items = V.grep(this.items, function(t) {
                        for (var e = 0; e < i.length; e++)
                            if (i[e] === t.item[0]) return !1;
                        return !0
                    })
                },
                _refreshItems: function(t) {
                    this.items = [], this.containers = [this];
                    var e, i, s, n, o, a, r, l, h = this.items,
                        c = [
                            ["function" == typeof this.options.items ? this.options.items.call(this.element[0], t, {
                                item: this.currentItem
                            }) : V(this.options.items, this.element), this]
                        ],
                        u = this._connectWith();
                    if (u && this.ready)
                        for (e = u.length - 1; 0 <= e; e--)
                            for (i = (s = V(u[e], this.document[0])).length - 1; 0 <= i; i--)(n = V.data(s[i], this.widgetFullName)) && n !== this && !n.options.disabled && (c.push(["function" == typeof n.options.items ? n.options.items.call(n.element[0], t, {
                                item: this.currentItem
                            }) : V(n.options.items, n.element), n]), this.containers.push(n));
                    for (e = c.length - 1; 0 <= e; e--)
                        for (o = c[e][1], l = (a = c[e][i = 0]).length; i < l; i++)(r = V(a[i])).data(this.widgetName + "-item", o), h.push({
                            item: r,
                            instance: o,
                            width: 0,
                            height: 0,
                            left: 0,
                            top: 0
                        })
                },
                _refreshItemPositions: function(t) {
                    for (var e, i, s = this.items.length - 1; 0 <= s; s--) e = this.items[s], this.currentContainer && e.instance !== this.currentContainer && e.item[0] !== this.currentItem[0] || (i = this.options.toleranceElement ? V(this.options.toleranceElement, e.item) : e.item, t || (e.width = i.outerWidth(), e.height = i.outerHeight()), i = i.offset(), e.left = i.left, e.top = i.top)
                },
                refreshPositions: function(t) {
                    var e, i;
                    if (this.floating = !!this.items.length && ("x" === this.options.axis || this._isFloating(this.items[0].item)), this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset()), this._refreshItemPositions(t), this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
                    else
                        for (e = this.containers.length - 1; 0 <= e; e--) i = this.containers[e].element.offset(), this.containers[e].containerCache.left = i.left, this.containers[e].containerCache.top = i.top, this.containers[e].containerCache.width = this.containers[e].element.outerWidth(), this.containers[e].containerCache.height = this.containers[e].element.outerHeight();
                    return this
                },
                _createPlaceholder: function(i) {
                    var s, n, o = (i = i || this).options;
                    o.placeholder && o.placeholder.constructor !== String || (s = o.placeholder, n = i.currentItem[0].nodeName.toLowerCase(), o.placeholder = {
                        element: function() {
                            var t = V("<" + n + ">", i.document[0]);
                            return i._addClass(t, "ui-sortable-placeholder", s || i.currentItem[0].className)._removeClass(t, "ui-sortable-helper"), "tbody" === n ? i._createTrPlaceholder(i.currentItem.find("tr").eq(0), V("<tr>", i.document[0]).appendTo(t)) : "tr" === n ? i._createTrPlaceholder(i.currentItem, t) : "img" === n && t.attr("src", i.currentItem.attr("src")), s || t.css("visibility", "hidden"), t
                        },
                        update: function(t, e) {
                            s && !o.forcePlaceholderSize || (e.height() && (!o.forcePlaceholderSize || "tbody" !== n && "tr" !== n) || e.height(i.currentItem.innerHeight() - parseInt(i.currentItem.css("paddingTop") || 0, 10) - parseInt(i.currentItem.css("paddingBottom") || 0, 10)), e.width() || e.width(i.currentItem.innerWidth() - parseInt(i.currentItem.css("paddingLeft") || 0, 10) - parseInt(i.currentItem.css("paddingRight") || 0, 10)))
                        }
                    }), i.placeholder = V(o.placeholder.element.call(i.element, i.currentItem)), i.currentItem.after(i.placeholder), o.placeholder.update(i, i.placeholder)
                },
                _createTrPlaceholder: function(t, e) {
                    var i = this;
                    t.children().each(function() {
                        V("<td>&#160;</td>", i.document[0]).attr("colspan", V(this).attr("colspan") || 1).appendTo(e)
                    })
                },
                _contactContainers: function(t) {
                    for (var e, i, s, n, o, a, r, l, h, c = null, u = null, d = this.containers.length - 1; 0 <= d; d--) V.contains(this.currentItem[0], this.containers[d].element[0]) || (this._intersectsWith(this.containers[d].containerCache) ? c && V.contains(this.containers[d].element[0], c.element[0]) || (c = this.containers[d], u = d) : this.containers[d].containerCache.over && (this.containers[d]._trigger("out", t, this._uiHash(this)), this.containers[d].containerCache.over = 0));
                    if (c)
                        if (1 === this.containers.length) this.containers[u].containerCache.over || (this.containers[u]._trigger("over", t, this._uiHash(this)), this.containers[u].containerCache.over = 1);
                        else {
                            for (i = 1e4, s = null, n = (l = c.floating || this._isFloating(this.currentItem)) ? "left" : "top", o = l ? "width" : "height", h = l ? "pageX" : "pageY", e = this.items.length - 1; 0 <= e; e--) V.contains(this.containers[u].element[0], this.items[e].item[0]) && this.items[e].item[0] !== this.currentItem[0] && (a = this.items[e].item.offset()[n], r = !1, t[h] - a > this.items[e][o] / 2 && (r = !0), Math.abs(t[h] - a) < i && (i = Math.abs(t[h] - a), s = this.items[e], this.direction = r ? "up" : "down"));
                            (s || this.options.dropOnEmpty) && (this.currentContainer !== this.containers[u] ? (s ? this._rearrange(t, s, null, !0) : this._rearrange(t, null, this.containers[u].element, !0), this._trigger("change", t, this._uiHash()), this.containers[u]._trigger("change", t, this._uiHash(this)), this.currentContainer = this.containers[u], this.options.placeholder.update(this.currentContainer, this.placeholder), this.scrollParent = this.placeholder.scrollParent(), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this.containers[u]._trigger("over", t, this._uiHash(this)), this.containers[u].containerCache.over = 1) : this.currentContainer.containerCache.over || (this.containers[u]._trigger("over", t, this._uiHash()), this.currentContainer.containerCache.over = 1))
                        }
                },
                _createHelper: function(t) {
                    var e = this.options,
                        t = "function" == typeof e.helper ? V(e.helper.apply(this.element[0], [t, this.currentItem])) : "clone" === e.helper ? this.currentItem.clone() : this.currentItem;
                    return t.parents("body").length || this.appendTo[0].appendChild(t[0]), t[0] === this.currentItem[0] && (this._storedCSS = {
                        width: this.currentItem[0].style.width,
                        height: this.currentItem[0].style.height,
                        position: this.currentItem.css("position"),
                        top: this.currentItem.css("top"),
                        left: this.currentItem.css("left")
                    }), t[0].style.width && !e.forceHelperSize || t.width(this.currentItem.width()), t[0].style.height && !e.forceHelperSize || t.height(this.currentItem.height()), t
                },
                _adjustOffsetFromHelper: function(t) {
                    "string" == typeof t && (t = t.split(" ")), "left" in (t = Array.isArray(t) ? {
                        left: +t[0],
                        top: +t[1] || 0
                    } : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
                },
                _getParentOffset: function() {
                    this.offsetParent = this.helper.offsetParent();
                    var t = this.offsetParent.offset();
                    return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && V.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), {
                        top: (t = this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && V.ui.ie ? {
                            top: 0,
                            left: 0
                        } : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                        left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    }
                },
                _getRelativeOffset: function() {
                    if ("relative" !== this.cssPosition) return {
                        top: 0,
                        left: 0
                    };
                    var t = this.currentItem.position();
                    return {
                        top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    }
                },
                _cacheMargins: function() {
                    this.margins = {
                        left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                        top: parseInt(this.currentItem.css("marginTop"), 10) || 0
                    }
                },
                _cacheHelperProportions: function() {
                    this.helperProportions = {
                        width: this.helper.outerWidth(),
                        height: this.helper.outerHeight()
                    }
                },
                _setContainment: function() {
                    var t, e, i = this.options;
                    "parent" === i.containment && (i.containment = this.helper[0].parentNode), "document" !== i.containment && "window" !== i.containment || (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === i.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === i.containment ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(i.containment) || (t = V(i.containment)[0], e = V(i.containment).offset(), i = "hidden" !== V(t).css("overflow"), this.containment = [e.left + (parseInt(V(t).css("borderLeftWidth"), 10) || 0) + (parseInt(V(t).css("paddingLeft"), 10) || 0) - this.margins.left, e.top + (parseInt(V(t).css("borderTopWidth"), 10) || 0) + (parseInt(V(t).css("paddingTop"), 10) || 0) - this.margins.top, e.left + (i ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) - (parseInt(V(t).css("borderLeftWidth"), 10) || 0) - (parseInt(V(t).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, e.top + (i ? Math.max(t.scrollHeight, t.offsetHeight) : t.offsetHeight) - (parseInt(V(t).css("borderTopWidth"), 10) || 0) - (parseInt(V(t).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
                },
                _convertPositionTo: function(t, e) {
                    e = e || this.position;
                    var i = "absolute" === t ? 1 : -1,
                        s = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && V.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                        t = /(html|body)/i.test(s[0].tagName);
                    return {
                        top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : t ? 0 : s.scrollTop()) * i,
                        left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : t ? 0 : s.scrollLeft()) * i
                    }
                },
                _generatePosition: function(t) {
                    var e = this.options,
                        i = t.pageX,
                        s = t.pageY,
                        n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && V.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                        o = /(html|body)/i.test(n[0].tagName);
                    return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (i = this.containment[0] + this.offset.click.left), t.pageY - this.offset.click.top < this.containment[1] && (s = this.containment[1] + this.offset.click.top), t.pageX - this.offset.click.left > this.containment[2] && (i = this.containment[2] + this.offset.click.left), t.pageY - this.offset.click.top > this.containment[3] && (s = this.containment[3] + this.offset.click.top)), e.grid && (t = this.originalPageY + Math.round((s - this.originalPageY) / e.grid[1]) * e.grid[1], s = !this.containment || t - this.offset.click.top >= this.containment[1] && t - this.offset.click.top <= this.containment[3] ? t : t - this.offset.click.top >= this.containment[1] ? t - e.grid[1] : t + e.grid[1], t = this.originalPageX + Math.round((i - this.originalPageX) / e.grid[0]) * e.grid[0], i = !this.containment || t - this.offset.click.left >= this.containment[0] && t - this.offset.click.left <= this.containment[2] ? t : t - this.offset.click.left >= this.containment[0] ? t - e.grid[0] : t + e.grid[0])), {
                        top: s - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : o ? 0 : n.scrollTop()),
                        left: i - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : o ? 0 : n.scrollLeft())
                    }
                },
                _rearrange: function(t, e, i, s) {
                    i ? i[0].appendChild(this.placeholder[0]) : e.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? e.item[0] : e.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
                    var n = this.counter;
                    this._delay(function() {
                        n === this.counter && this.refreshPositions(!s)
                    })
                },
                _clear: function(t, e) {
                    this.reverting = !1;
                    var i, s = [];
                    if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                        for (i in this._storedCSS) "auto" !== this._storedCSS[i] && "static" !== this._storedCSS[i] || (this._storedCSS[i] = "");
                        this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")
                    } else this.currentItem.show();

                    function n(e, i, s) {
                        return function(t) {
                            s._trigger(e, t, i._uiHash(i))
                        }
                    }
                    for (this.fromOutside && !e && s.push(function(t) {
                            this._trigger("receive", t, this._uiHash(this.fromOutside))
                        }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || e || s.push(function(t) {
                            this._trigger("update", t, this._uiHash())
                        }), this !== this.currentContainer && (e || (s.push(function(t) {
                            this._trigger("remove", t, this._uiHash())
                        }), s.push(function(e) {
                            return function(t) {
                                e._trigger("receive", t, this._uiHash(this))
                            }
                        }.call(this, this.currentContainer)), s.push(function(e) {
                            return function(t) {
                                e._trigger("update", t, this._uiHash(this))
                            }
                        }.call(this, this.currentContainer)))), i = this.containers.length - 1; 0 <= i; i--) e || s.push(n("deactivate", this, this.containers[i])), this.containers[i].containerCache.over && (s.push(n("out", this, this.containers[i])), this.containers[i].containerCache.over = 0);
                    if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, e || this._trigger("beforeStop", t, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !e) {
                        for (i = 0; i < s.length; i++) s[i].call(this, t);
                        this._trigger("stop", t, this._uiHash())
                    }
                    return this.fromOutside = !1, !this.cancelHelperRemoval
                },
                _trigger: function() {
                    !1 === V.Widget.prototype._trigger.apply(this, arguments) && this.cancel()
                },
                _uiHash: function(t) {
                    var e = t || this;
                    return {
                        helper: e.helper,
                        placeholder: e.placeholder || V([]),
                        position: e.position,
                        originalPosition: e.originalPosition,
                        offset: e.positionAbs,
                        item: e.currentItem,
                        sender: t ? t.element : null
                    }
                }
            });

            function ht(e) {
                return function() {
                    var t = this.element.val();
                    e.apply(this, arguments), this._refresh(), t !== this.element.val() && this._trigger("change")
                }
            }
            V.widget("ui.spinner", {
                version: "1.13.2",
                defaultElement: "<input>",
                widgetEventPrefix: "spin",
                options: {
                    classes: {
                        "ui-spinner": "ui-corner-all",
                        "ui-spinner-down": "ui-corner-br",
                        "ui-spinner-up": "ui-corner-tr"
                    },
                    culture: null,
                    icons: {
                        down: "ui-icon-triangle-1-s",
                        up: "ui-icon-triangle-1-n"
                    },
                    incremental: !0,
                    max: null,
                    min: null,
                    numberFormat: null,
                    page: 10,
                    step: 1,
                    change: null,
                    spin: null,
                    start: null,
                    stop: null
                },
                _create: function() {
                    this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), "" !== this.value() && this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
                        beforeunload: function() {
                            this.element.removeAttr("autocomplete")
                        }
                    })
                },
                _getCreateOptions: function() {
                    var s = this._super(),
                        n = this.element;
                    return V.each(["min", "max", "step"], function(t, e) {
                        var i = n.attr(e);
                        null != i && i.length && (s[e] = i)
                    }), s
                },
                _events: {
                    keydown: function(t) {
                        this._start(t) && this._keydown(t) && t.preventDefault()
                    },
                    keyup: "_stop",
                    focus: function() {
                        this.previous = this.element.val()
                    },
                    blur: function(t) {
                        this.cancelBlur ? delete this.cancelBlur : (this._stop(), this._refresh(), this.previous !== this.element.val() && this._trigger("change", t))
                    },
                    mousewheel: function(t, e) {
                        var i = V.ui.safeActiveElement(this.document[0]);
                        if (this.element[0] === i && e) {
                            if (!this.spinning && !this._start(t)) return !1;
                            this._spin((0 < e ? 1 : -1) * this.options.step, t), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function() {
                                this.spinning && this._stop(t)
                            }, 100), t.preventDefault()
                        }
                    },
                    "mousedown .ui-spinner-button": function(t) {
                        var e;

                        function i() {
                            this.element[0] === V.ui.safeActiveElement(this.document[0]) || (this.element.trigger("focus"), this.previous = e, this._delay(function() {
                                this.previous = e
                            }))
                        }
                        e = this.element[0] === V.ui.safeActiveElement(this.document[0]) ? this.previous : this.element.val(), t.preventDefault(), i.call(this), this.cancelBlur = !0, this._delay(function() {
                            delete this.cancelBlur, i.call(this)
                        }), !1 !== this._start(t) && this._repeat(null, V(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
                    },
                    "mouseup .ui-spinner-button": "_stop",
                    "mouseenter .ui-spinner-button": function(t) {
                        if (V(t.currentTarget).hasClass("ui-state-active")) return !1 !== this._start(t) && void this._repeat(null, V(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
                    },
                    "mouseleave .ui-spinner-button": "_stop"
                },
                _enhance: function() {
                    this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>")
                },
                _draw: function() {
                    this._enhance(), this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content"), this._addClass("ui-spinner-input"), this.element.attr("role", "spinbutton"), this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", !0).button({
                        classes: {
                            "ui-button": ""
                        }
                    }), this._removeClass(this.buttons, "ui-corner-all"), this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up"), this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down"), this.buttons.first().button({
                        icon: this.options.icons.up,
                        showLabel: !1
                    }), this.buttons.last().button({
                        icon: this.options.icons.down,
                        showLabel: !1
                    }), this.buttons.height() > Math.ceil(.5 * this.uiSpinner.height()) && 0 < this.uiSpinner.height() && this.uiSpinner.height(this.uiSpinner.height())
                },
                _keydown: function(t) {
                    var e = this.options,
                        i = V.ui.keyCode;
                    switch (t.keyCode) {
                        case i.UP:
                            return this._repeat(null, 1, t), !0;
                        case i.DOWN:
                            return this._repeat(null, -1, t), !0;
                        case i.PAGE_UP:
                            return this._repeat(null, e.page, t), !0;
                        case i.PAGE_DOWN:
                            return this._repeat(null, -e.page, t), !0
                    }
                    return !1
                },
                _start: function(t) {
                    return !(!this.spinning && !1 === this._trigger("start", t)) && (this.counter || (this.counter = 1), this.spinning = !0)
                },
                _repeat: function(t, e, i) {
                    t = t || 500, clearTimeout(this.timer), this.timer = this._delay(function() {
                        this._repeat(40, e, i)
                    }, t), this._spin(e * this.options.step, i)
                },
                _spin: function(t, e) {
                    var i = this.value() || 0;
                    this.counter || (this.counter = 1), i = this._adjustValue(i + t * this._increment(this.counter)), this.spinning && !1 === this._trigger("spin", e, {
                        value: i
                    }) || (this._value(i), this.counter++)
                },
                _increment: function(t) {
                    var e = this.options.incremental;
                    return e ? "function" == typeof e ? e(t) : Math.floor(t * t * t / 5e4 - t * t / 500 + 17 * t / 200 + 1) : 1
                },
                _precision: function() {
                    var t = this._precisionOf(this.options.step);
                    return t = null !== this.options.min ? Math.max(t, this._precisionOf(this.options.min)) : t
                },
                _precisionOf: function(t) {
                    var e = t.toString(),
                        t = e.indexOf(".");
                    return -1 === t ? 0 : e.length - t - 1
                },
                _adjustValue: function(t) {
                    var e = this.options,
                        i = null !== e.min ? e.min : 0,
                        s = t - i;
                    return t = i + Math.round(s / e.step) * e.step, t = parseFloat(t.toFixed(this._precision())), null !== e.max && t > e.max ? e.max : null !== e.min && t < e.min ? e.min : t
                },
                _stop: function(t) {
                    this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", t))
                },
                _setOption: function(t, e) {
                    var i;
                    if ("culture" === t || "numberFormat" === t) return i = this._parse(this.element.val()), this.options[t] = e, void this.element.val(this._format(i));
                    "max" !== t && "min" !== t && "step" !== t || "string" == typeof e && (e = this._parse(e)), "icons" === t && (i = this.buttons.first().find(".ui-icon"), this._removeClass(i, null, this.options.icons.up), this._addClass(i, null, e.up), i = this.buttons.last().find(".ui-icon"), this._removeClass(i, null, this.options.icons.down), this._addClass(i, null, e.down)), this._super(t, e)
                },
                _setOptionDisabled: function(t) {
                    this._super(t), this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!t), this.element.prop("disabled", !!t), this.buttons.button(t ? "disable" : "enable")
                },
                _setOptions: ht(function(t) {
                    this._super(t)
                }),
                _parse: function(t) {
                    return "" === (t = "string" == typeof t && "" !== t ? window.Globalize && this.options.numberFormat ? Globalize.parseFloat(t, 10, this.options.culture) : +t : t) || isNaN(t) ? null : t
                },
                _format: function(t) {
                    return "" === t ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(t, this.options.numberFormat, this.options.culture) : t
                },
                _refresh: function() {
                    this.element.attr({
                        "aria-valuemin": this.options.min,
                        "aria-valuemax": this.options.max,
                        "aria-valuenow": this._parse(this.element.val())
                    })
                },
                isValid: function() {
                    var t = this.value();
                    return null !== t && t === this._adjustValue(t)
                },
                _value: function(t, e) {
                    var i;
                    "" !== t && null !== (i = this._parse(t)) && (e || (i = this._adjustValue(i)), t = this._format(i)), this.element.val(t), this._refresh()
                },
                _destroy: function() {
                    this.element.prop("disabled", !1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"), this.uiSpinner.replaceWith(this.element)
                },
                stepUp: ht(function(t) {
                    this._stepUp(t)
                }),
                _stepUp: function(t) {
                    this._start() && (this._spin((t || 1) * this.options.step), this._stop())
                },
                stepDown: ht(function(t) {
                    this._stepDown(t)
                }),
                _stepDown: function(t) {
                    this._start() && (this._spin((t || 1) * -this.options.step), this._stop())
                },
                pageUp: ht(function(t) {
                    this._stepUp((t || 1) * this.options.page)
                }),
                pageDown: ht(function(t) {
                    this._stepDown((t || 1) * this.options.page)
                }),
                value: function(t) {
                    if (!arguments.length) return this._parse(this.element.val());
                    ht(this._value).call(this, t)
                },
                widget: function() {
                    return this.uiSpinner
                }
            }), !1 !== V.uiBackCompat && V.widget("ui.spinner", V.ui.spinner, {
                _enhance: function() {
                    this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())
                },
                _uiSpinnerHtml: function() {
                    return "<span>"
                },
                _buttonHtml: function() {
                    return "<a></a><a></a>"
                }
            });
            var ct;
            V.ui.spinner;
            V.widget("ui.tabs", {
                version: "1.13.2",
                delay: 300,
                options: {
                    active: null,
                    classes: {
                        "ui-tabs": "ui-corner-all",
                        "ui-tabs-nav": "ui-corner-all",
                        "ui-tabs-panel": "ui-corner-bottom",
                        "ui-tabs-tab": "ui-corner-top"
                    },
                    collapsible: !1,
                    event: "click",
                    heightStyle: "content",
                    hide: null,
                    show: null,
                    activate: null,
                    beforeActivate: null,
                    beforeLoad: null,
                    load: null
                },
                _isLocal: (ct = /#.*$/, function(t) {
                    var e = t.href.replace(ct, ""),
                        i = location.href.replace(ct, "");
                    try {
                        e = decodeURIComponent(e)
                    } catch (t) {}
                    try {
                        i = decodeURIComponent(i)
                    } catch (t) {}
                    return 1 < t.hash.length && e === i
                }),
                _create: function() {
                    var e = this,
                        t = this.options;
                    this.running = !1, this._addClass("ui-tabs", "ui-widget ui-widget-content"), this._toggleClass("ui-tabs-collapsible", null, t.collapsible), this._processTabs(), t.active = this._initialActive(), Array.isArray(t.disabled) && (t.disabled = V.uniqueSort(t.disabled.concat(V.map(this.tabs.filter(".ui-state-disabled"), function(t) {
                        return e.tabs.index(t)
                    }))).sort()), !1 !== this.options.active && this.anchors.length ? this.active = this._findActive(t.active) : this.active = V(), this._refresh(), this.active.length && this.load(t.active)
                },
                _initialActive: function() {
                    var i = this.options.active,
                        t = this.options.collapsible,
                        s = location.hash.substring(1);
                    return null === i && (s && this.tabs.each(function(t, e) {
                        if (V(e).attr("aria-controls") === s) return i = t, !1
                    }), null !== (i = null === i ? this.tabs.index(this.tabs.filter(".ui-tabs-active")) : i) && -1 !== i || (i = !!this.tabs.length && 0)), !1 !== i && -1 === (i = this.tabs.index(this.tabs.eq(i))) && (i = !t && 0), i = !t && !1 === i && this.anchors.length ? 0 : i
                },
                _getCreateEventData: function() {
                    return {
                        tab: this.active,
                        panel: this.active.length ? this._getPanelForTab(this.active) : V()
                    }
                },
                _tabKeydown: function(t) {
                    var e = V(V.ui.safeActiveElement(this.document[0])).closest("li"),
                        i = this.tabs.index(e),
                        s = !0;
                    if (!this._handlePageNav(t)) {
                        switch (t.keyCode) {
                            case V.ui.keyCode.RIGHT:
                            case V.ui.keyCode.DOWN:
                                i++;
                                break;
                            case V.ui.keyCode.UP:
                            case V.ui.keyCode.LEFT:
                                s = !1, i--;
                                break;
                            case V.ui.keyCode.END:
                                i = this.anchors.length - 1;
                                break;
                            case V.ui.keyCode.HOME:
                                i = 0;
                                break;
                            case V.ui.keyCode.SPACE:
                                return t.preventDefault(), clearTimeout(this.activating), void this._activate(i);
                            case V.ui.keyCode.ENTER:
                                return t.preventDefault(), clearTimeout(this.activating), void this._activate(i !== this.options.active && i);
                            default:
                                return
                        }
                        t.preventDefault(), clearTimeout(this.activating), i = this._focusNextTab(i, s), t.ctrlKey || t.metaKey || (e.attr("aria-selected", "false"), this.tabs.eq(i).attr("aria-selected", "true"), this.activating = this._delay(function() {
                            this.option("active", i)
                        }, this.delay))
                    }
                },
                _panelKeydown: function(t) {
                    this._handlePageNav(t) || t.ctrlKey && t.keyCode === V.ui.keyCode.UP && (t.preventDefault(), this.active.trigger("focus"))
                },
                _handlePageNav: function(t) {
                    return t.altKey && t.keyCode === V.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : t.altKey && t.keyCode === V.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0
                },
                _findNextTab: function(t, e) {
                    var i = this.tabs.length - 1;
                    for (; - 1 !== V.inArray(t = (t = i < t ? 0 : t) < 0 ? i : t, this.options.disabled);) t = e ? t + 1 : t - 1;
                    return t
                },
                _focusNextTab: function(t, e) {
                    return t = this._findNextTab(t, e), this.tabs.eq(t).trigger("focus"), t
                },
                _setOption: function(t, e) {
                    "active" !== t ? (this._super(t, e), "collapsible" === t && (this._toggleClass("ui-tabs-collapsible", null, e), e || !1 !== this.options.active || this._activate(0)), "event" === t && this._setupEvents(e), "heightStyle" === t && this._setupHeightStyle(e)) : this._activate(e)
                },
                _sanitizeSelector: function(t) {
                    return t ? t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
                },
                refresh: function() {
                    var t = this.options,
                        e = this.tablist.children(":has(a[href])");
                    t.disabled = V.map(e.filter(".ui-state-disabled"), function(t) {
                        return e.index(t)
                    }), this._processTabs(), !1 !== t.active && this.anchors.length ? this.active.length && !V.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, this.active = V()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active) : (t.active = !1, this.active = V()), this._refresh()
                },
                _refresh: function() {
                    this._setOptionDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                        "aria-selected": "false",
                        "aria-expanded": "false",
                        tabIndex: -1
                    }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                        "aria-hidden": "true"
                    }), this.active.length ? (this.active.attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    }), this._addClass(this.active, "ui-tabs-active", "ui-state-active"), this._getPanelForTab(this.active).show().attr({
                        "aria-hidden": "false"
                    })) : this.tabs.eq(0).attr("tabIndex", 0)
                },
                _processTabs: function() {
                    var l = this,
                        t = this.tabs,
                        e = this.anchors,
                        i = this.panels;
                    this.tablist = this._getList().attr("role", "tablist"), this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header"), this.tablist.on("mousedown" + this.eventNamespace, "> li", function(t) {
                        V(this).is(".ui-state-disabled") && t.preventDefault()
                    }).on("focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
                        V(this).closest("li").is(".ui-state-disabled") && this.blur()
                    }), this.tabs = this.tablist.find("> li:has(a[href])").attr({
                        role: "tab",
                        tabIndex: -1
                    }), this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default"), this.anchors = this.tabs.map(function() {
                        return V("a", this)[0]
                    }).attr({
                        tabIndex: -1
                    }), this._addClass(this.anchors, "ui-tabs-anchor"), this.panels = V(), this.anchors.each(function(t, e) {
                        var i, s, n, o = V(e).uniqueId().attr("id"),
                            a = V(e).closest("li"),
                            r = a.attr("aria-controls");
                        l._isLocal(e) ? (n = (i = e.hash).substring(1), s = l.element.find(l._sanitizeSelector(i))) : (n = a.attr("aria-controls") || V({}).uniqueId()[0].id, (s = l.element.find(i = "#" + n)).length || (s = l._createPanel(n)).insertAfter(l.panels[t - 1] || l.tablist), s.attr("aria-live", "polite")), s.length && (l.panels = l.panels.add(s)), r && a.data("ui-tabs-aria-controls", r), a.attr({
                            "aria-controls": n,
                            "aria-labelledby": o
                        }), s.attr("aria-labelledby", o)
                    }), this.panels.attr("role", "tabpanel"), this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content"), t && (this._off(t.not(this.tabs)), this._off(e.not(this.anchors)), this._off(i.not(this.panels)))
                },
                _getList: function() {
                    return this.tablist || this.element.find("ol, ul").eq(0)
                },
                _createPanel: function(t) {
                    return V("<div>").attr("id", t).data("ui-tabs-destroy", !0)
                },
                _setOptionDisabled: function(t) {
                    var e, i;
                    for (Array.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1), i = 0; e = this.tabs[i]; i++) e = V(e), !0 === t || -1 !== V.inArray(i, t) ? (e.attr("aria-disabled", "true"), this._addClass(e, null, "ui-state-disabled")) : (e.removeAttr("aria-disabled"), this._removeClass(e, null, "ui-state-disabled"));
                    this.options.disabled = t, this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !0 === t)
                },
                _setupEvents: function(t) {
                    var i = {};
                    t && V.each(t.split(" "), function(t, e) {
                        i[e] = "_eventHandler"
                    }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
                        click: function(t) {
                            t.preventDefault()
                        }
                    }), this._on(this.anchors, i), this._on(this.tabs, {
                        keydown: "_tabKeydown"
                    }), this._on(this.panels, {
                        keydown: "_panelKeydown"
                    }), this._focusable(this.tabs), this._hoverable(this.tabs)
                },
                _setupHeightStyle: function(t) {
                    var i, e = this.element.parent();
                    "fill" === t ? (i = e.height(), i -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function() {
                        var t = V(this),
                            e = t.css("position");
                        "absolute" !== e && "fixed" !== e && (i -= t.outerHeight(!0))
                    }), this.element.children().not(this.panels).each(function() {
                        i -= V(this).outerHeight(!0)
                    }), this.panels.each(function() {
                        V(this).height(Math.max(0, i - V(this).innerHeight() + V(this).height()))
                    }).css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(function() {
                        i = Math.max(i, V(this).height("").height())
                    }).height(i))
                },
                _eventHandler: function(t) {
                    var e = this.options,
                        i = this.active,
                        s = V(t.currentTarget).closest("li"),
                        n = s[0] === i[0],
                        o = n && e.collapsible,
                        a = o ? V() : this._getPanelForTab(s),
                        r = i.length ? this._getPanelForTab(i) : V(),
                        i = {
                            oldTab: i,
                            oldPanel: r,
                            newTab: o ? V() : s,
                            newPanel: a
                        };
                    t.preventDefault(), s.hasClass("ui-state-disabled") || s.hasClass("ui-tabs-loading") || this.running || n && !e.collapsible || !1 === this._trigger("beforeActivate", t, i) || (e.active = !o && this.tabs.index(s), this.active = n ? V() : s, this.xhr && this.xhr.abort(), r.length || a.length || V.error("jQuery UI Tabs: Mismatching fragment identifier."), a.length && this.load(this.tabs.index(s), t), this._toggle(t, i))
                },
                _toggle: function(t, e) {
                    var i = this,
                        s = e.newPanel,
                        n = e.oldPanel;

                    function o() {
                        i.running = !1, i._trigger("activate", t, e)
                    }

                    function a() {
                        i._addClass(e.newTab.closest("li"), "ui-tabs-active", "ui-state-active"), s.length && i.options.show ? i._show(s, i.options.show, o) : (s.show(), o())
                    }
                    this.running = !0, n.length && this.options.hide ? this._hide(n, this.options.hide, function() {
                        i._removeClass(e.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), a()
                    }) : (this._removeClass(e.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), n.hide(), a()), n.attr("aria-hidden", "true"), e.oldTab.attr({
                        "aria-selected": "false",
                        "aria-expanded": "false"
                    }), s.length && n.length ? e.oldTab.attr("tabIndex", -1) : s.length && this.tabs.filter(function() {
                        return 0 === V(this).attr("tabIndex")
                    }).attr("tabIndex", -1), s.attr("aria-hidden", "false"), e.newTab.attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    })
                },
                _activate: function(t) {
                    var t = this._findActive(t);
                    t[0] !== this.active[0] && (t = (t = !t.length ? this.active : t).find(".ui-tabs-anchor")[0], this._eventHandler({
                        target: t,
                        currentTarget: t,
                        preventDefault: V.noop
                    }))
                },
                _findActive: function(t) {
                    return !1 === t ? V() : this.tabs.eq(t)
                },
                _getIndex: function(t) {
                    return t = "string" == typeof t ? this.anchors.index(this.anchors.filter("[href$='" + V.escapeSelector(t) + "']")) : t
                },
                _destroy: function() {
                    this.xhr && this.xhr.abort(), this.tablist.removeAttr("role").off(this.eventNamespace), this.anchors.removeAttr("role tabIndex").removeUniqueId(), this.tabs.add(this.panels).each(function() {
                        V.data(this, "ui-tabs-destroy") ? V(this).remove() : V(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")
                    }), this.tabs.each(function() {
                        var t = V(this),
                            e = t.data("ui-tabs-aria-controls");
                        e ? t.attr("aria-controls", e).removeData("ui-tabs-aria-controls") : t.removeAttr("aria-controls")
                    }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "")
                },
                enable: function(i) {
                    var t = this.options.disabled;
                    !1 !== t && (t = void 0 !== i && (i = this._getIndex(i), Array.isArray(t) ? V.map(t, function(t) {
                        return t !== i ? t : null
                    }) : V.map(this.tabs, function(t, e) {
                        return e !== i ? e : null
                    })), this._setOptionDisabled(t))
                },
                disable: function(t) {
                    var e = this.options.disabled;
                    if (!0 !== e) {
                        if (void 0 === t) e = !0;
                        else {
                            if (t = this._getIndex(t), -1 !== V.inArray(t, e)) return;
                            e = Array.isArray(e) ? V.merge([t], e).sort() : [t]
                        }
                        this._setOptionDisabled(e)
                    }
                },
                load: function(t, s) {
                    t = this._getIndex(t);

                    function n(t, e) {
                        "abort" === e && o.panels.stop(!1, !0), o._removeClass(i, "ui-tabs-loading"), a.removeAttr("aria-busy"), t === o.xhr && delete o.xhr
                    }
                    var o = this,
                        i = this.tabs.eq(t),
                        t = i.find(".ui-tabs-anchor"),
                        a = this._getPanelForTab(i),
                        r = {
                            tab: i,
                            panel: a
                        };
                    this._isLocal(t[0]) || (this.xhr = V.ajax(this._ajaxSettings(t, s, r)), this.xhr && "canceled" !== this.xhr.statusText && (this._addClass(i, "ui-tabs-loading"), a.attr("aria-busy", "true"), this.xhr.done(function(t, e, i) {
                        setTimeout(function() {
                            a.html(t), o._trigger("load", s, r), n(i, e)
                        }, 1)
                    }).fail(function(t, e) {
                        setTimeout(function() {
                            n(t, e)
                        }, 1)
                    })))
                },
                _ajaxSettings: function(t, i, s) {
                    var n = this;
                    return {
                        url: t.attr("href").replace(/#.*$/, ""),
                        beforeSend: function(t, e) {
                            return n._trigger("beforeLoad", i, V.extend({
                                jqXHR: t,
                                ajaxSettings: e
                            }, s))
                        }
                    }
                },
                _getPanelForTab: function(t) {
                    t = V(t).attr("aria-controls");
                    return this.element.find(this._sanitizeSelector("#" + t))
                }
            }), !1 !== V.uiBackCompat && V.widget("ui.tabs", V.ui.tabs, {
                _processTabs: function() {
                    this._superApply(arguments), this._addClass(this.tabs, "ui-tab")
                }
            });
            V.ui.tabs;
            V.widget("ui.tooltip", {
                version: "1.13.2",
                options: {
                    classes: {
                        "ui-tooltip": "ui-corner-all ui-widget-shadow"
                    },
                    content: function() {
                        var t = V(this).attr("title");
                        return V("<a>").text(t).html()
                    },
                    hide: !0,
                    items: "[title]:not([disabled])",
                    position: {
                        my: "left top+15",
                        at: "left bottom",
                        collision: "flipfit flip"
                    },
                    show: !0,
                    track: !1,
                    close: null,
                    open: null
                },
                _addDescribedBy: function(t, e) {
                    var i = (t.attr("aria-describedby") || "").split(/\s+/);
                    i.push(e), t.data("ui-tooltip-id", e).attr("aria-describedby", String.prototype.trim.call(i.join(" ")))
                },
                _removeDescribedBy: function(t) {
                    var e = t.data("ui-tooltip-id"),
                        i = (t.attr("aria-describedby") || "").split(/\s+/),
                        e = V.inArray(e, i); - 1 !== e && i.splice(e, 1), t.removeData("ui-tooltip-id"), (i = String.prototype.trim.call(i.join(" "))) ? t.attr("aria-describedby", i) : t.removeAttr("aria-describedby")
                },
                _create: function() {
                    this._on({
                        mouseover: "open",
                        focusin: "open"
                    }), this.tooltips = {}, this.parents = {}, this.liveRegion = V("<div>").attr({
                        role: "log",
                        "aria-live": "assertive",
                        "aria-relevant": "additions"
                    }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this.disabledTitles = V([])
                },
                _setOption: function(t, e) {
                    var i = this;
                    this._super(t, e), "content" === t && V.each(this.tooltips, function(t, e) {
                        i._updateContent(e.element)
                    })
                },
                _setOptionDisabled: function(t) {
                    this[t ? "_disable" : "_enable"]()
                },
                _disable: function() {
                    var s = this;
                    V.each(this.tooltips, function(t, e) {
                        var i = V.Event("blur");
                        i.target = i.currentTarget = e.element[0], s.close(i, !0)
                    }), this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function() {
                        var t = V(this);
                        if (t.is("[title]")) return t.data("ui-tooltip-title", t.attr("title")).removeAttr("title")
                    }))
                },
                _enable: function() {
                    this.disabledTitles.each(function() {
                        var t = V(this);
                        t.data("ui-tooltip-title") && t.attr("title", t.data("ui-tooltip-title"))
                    }), this.disabledTitles = V([])
                },
                open: function(t) {
                    var i = this,
                        e = V(t ? t.target : this.element).closest(this.options.items);
                    e.length && !e.data("ui-tooltip-id") && (e.attr("title") && e.data("ui-tooltip-title", e.attr("title")), e.data("ui-tooltip-open", !0), t && "mouseover" === t.type && e.parents().each(function() {
                        var t, e = V(this);
                        e.data("ui-tooltip-open") && ((t = V.Event("blur")).target = t.currentTarget = this, i.close(t, !0)), e.attr("title") && (e.uniqueId(), i.parents[this.id] = {
                            element: this,
                            title: e.attr("title")
                        }, e.attr("title", ""))
                    }), this._registerCloseHandlers(t, e), this._updateContent(e, t))
                },
                _updateContent: function(e, i) {
                    var t = this.options.content,
                        s = this,
                        n = i ? i.type : null;
                    if ("string" == typeof t || t.nodeType || t.jquery) return this._open(i, e, t);
                    (t = t.call(e[0], function(t) {
                        s._delay(function() {
                            e.data("ui-tooltip-open") && (i && (i.type = n), this._open(i, e, t))
                        })
                    })) && this._open(i, e, t)
                },
                _open: function(t, e, i) {
                    var s, n, o, a = V.extend({}, this.options.position);

                    function r(t) {
                        a.of = t, n.is(":hidden") || n.position(a)
                    }
                    i && ((s = this._find(e)) ? s.tooltip.find(".ui-tooltip-content").html(i) : (e.is("[title]") && (t && "mouseover" === t.type ? e.attr("title", "") : e.removeAttr("title")), s = this._tooltip(e), n = s.tooltip, this._addDescribedBy(e, n.attr("id")), n.find(".ui-tooltip-content").html(i), this.liveRegion.children().hide(), (i = V("<div>").html(n.find(".ui-tooltip-content").html())).removeAttr("name").find("[name]").removeAttr("name"), i.removeAttr("id").find("[id]").removeAttr("id"), i.appendTo(this.liveRegion), this.options.track && t && /^mouse/.test(t.type) ? (this._on(this.document, {
                        mousemove: r
                    }), r(t)) : n.position(V.extend({
                        of: e
                    }, this.options.position)), n.hide(), this._show(n, this.options.show), this.options.track && this.options.show && this.options.show.delay && (o = this.delayedShow = setInterval(function() {
                        n.is(":visible") && (r(a.of), clearInterval(o))
                    }, 13)), this._trigger("open", t, {
                        tooltip: n
                    })))
                },
                _registerCloseHandlers: function(t, e) {
                    var i = {
                        keyup: function(t) {
                            t.keyCode === V.ui.keyCode.ESCAPE && ((t = V.Event(t)).currentTarget = e[0], this.close(t, !0))
                        }
                    };
                    e[0] !== this.element[0] && (i.remove = function() {
                        var t = this._find(e);
                        t && this._removeTooltip(t.tooltip)
                    }), t && "mouseover" !== t.type || (i.mouseleave = "close"), t && "focusin" !== t.type || (i.focusout = "close"), this._on(!0, e, i)
                },
                close: function(t) {
                    var e, i = this,
                        s = V(t ? t.currentTarget : this.element),
                        n = this._find(s);
                    n ? (e = n.tooltip, n.closing || (clearInterval(this.delayedShow), s.data("ui-tooltip-title") && !s.attr("title") && s.attr("title", s.data("ui-tooltip-title")), this._removeDescribedBy(s), n.hiding = !0, e.stop(!0), this._hide(e, this.options.hide, function() {
                        i._removeTooltip(V(this))
                    }), s.removeData("ui-tooltip-open"), this._off(s, "mouseleave focusout keyup"), s[0] !== this.element[0] && this._off(s, "remove"), this._off(this.document, "mousemove"), t && "mouseleave" === t.type && V.each(this.parents, function(t, e) {
                        V(e.element).attr("title", e.title), delete i.parents[t]
                    }), n.closing = !0, this._trigger("close", t, {
                        tooltip: e
                    }), n.hiding || (n.closing = !1))) : s.removeData("ui-tooltip-open")
                },
                _tooltip: function(t) {
                    var e = V("<div>").attr("role", "tooltip"),
                        i = V("<div>").appendTo(e),
                        s = e.uniqueId().attr("id");
                    return this._addClass(i, "ui-tooltip-content"), this._addClass(e, "ui-tooltip", "ui-widget ui-widget-content"), e.appendTo(this._appendTo(t)), this.tooltips[s] = {
                        element: t,
                        tooltip: e
                    }
                },
                _find: function(t) {
                    t = t.data("ui-tooltip-id");
                    return t ? this.tooltips[t] : null
                },
                _removeTooltip: function(t) {
                    clearInterval(this.delayedShow), t.remove(), delete this.tooltips[t.attr("id")]
                },
                _appendTo: function(t) {
                    t = t.closest(".ui-front, dialog");
                    return t = !t.length ? this.document[0].body : t
                },
                _destroy: function() {
                    var s = this;
                    V.each(this.tooltips, function(t, e) {
                        var i = V.Event("blur"),
                            e = e.element;
                        i.target = i.currentTarget = e[0], s.close(i, !0), V("#" + t).remove(), e.data("ui-tooltip-title") && (e.attr("title") || e.attr("title", e.data("ui-tooltip-title")), e.removeData("ui-tooltip-title"))
                    }), this.liveRegion.remove()
                }
            }), !1 !== V.uiBackCompat && V.widget("ui.tooltip", V.ui.tooltip, {
                options: {
                    tooltipClass: null
                },
                _tooltip: function() {
                    var t = this._superApply(arguments);
                    return this.options.tooltipClass && t.tooltip.addClass(this.options.tooltipClass), t
                }
            });
            V.ui.tooltip
        });
    </script>
    <!-- datatables.js & .css -->
    <style>
        /* * This combined file was created by the DataTables downloader builder: * https://datatables.net/download * * To rebuild or modify this file with the latest versions of the included * software please visit: * https://datatables.net/download/#ju/dt-2.0.2 * * Included libraries: * DataTables 2.0.2 */
        
         :root {
            --dt-row-selected: 13, 110, 253;
            --dt-row-selected-text: 255, 255, 255;
            --dt-row-selected-link: 9, 10, 11;
            --dt-row-stripe: 0, 0, 0;
            --dt-row-hover: 0, 0, 0;
            --dt-column-ordering: 0, 0, 0;
            --dt-html-background: white
        }
        
        :root.dark {
            --dt-html-background: rgb(33, 37, 41)
        }
        
        table.dataTable td.dt-control {
            text-align: center;
            cursor: pointer
        }
        
        table.dataTable td.dt-control:before {
            display: inline-block;
            box-sizing: border-box;
            content: "";
            border-top: 5px solid transparent;
            border-left: 10px solid rgba(0, 0, 0, 0.5);
            border-bottom: 5px solid transparent;
            border-right: 0px solid transparent
        }
        
        table.dataTable tr.dt-hasChild td.dt-control:before {
            border-top: 10px solid rgba(0, 0, 0, 0.5);
            border-left: 5px solid transparent;
            border-bottom: 0px solid transparent;
            border-right: 5px solid transparent
        }
        
        html.dark table.dataTable td.dt-control:before,
        :root[data-bs-theme=dark] table.dataTable td.dt-control:before {
            border-left-color: rgba(255, 255, 255, 0.5)
        }
        
        html.dark table.dataTable tr.dt-hasChild td.dt-control:before,
        :root[data-bs-theme=dark] table.dataTable tr.dt-hasChild td.dt-control:before {
            border-top-color: rgba(255, 255, 255, 0.5);
            border-left-color: transparent
        }
        
        div.dt-scroll-body thead tr,
        div.dt-scroll-body tfoot tr {
            height: 0
        }
        
        div.dt-scroll-body thead tr th,
        div.dt-scroll-body thead tr td,
        div.dt-scroll-body tfoot tr th,
        div.dt-scroll-body tfoot tr td {
            height: 0 !important;
            padding-top: 0px !important;
            padding-bottom: 0px !important;
            border-top-width: 0px !important;
            border-bottom-width: 0px !important
        }
        
        div.dt-scroll-body thead tr th div.dt-scroll-sizing,
        div.dt-scroll-body thead tr td div.dt-scroll-sizing,
        div.dt-scroll-body tfoot tr th div.dt-scroll-sizing,
        div.dt-scroll-body tfoot tr td div.dt-scroll-sizing {
            height: 0 !important;
            overflow: hidden !important
        }
        
        :root {
            --dt-row-selected: 13, 110, 253;
            --dt-row-selected-text: 255, 255, 255;
            --dt-row-selected-link: 9, 10, 11;
            --dt-row-stripe: 0, 0, 0;
            --dt-row-hover: 0, 0, 0;
            --dt-column-ordering: 0, 0, 0;
            --dt-html-background: white
        }
        
        :root.dark {
            --dt-html-background: rgb(33, 37, 41)
        }
        
        table.dataTable td.dt-control {
            text-align: center;
            cursor: pointer
        }
        
        table.dataTable td.dt-control:before {
            display: inline-block;
            box-sizing: border-box;
            content: "";
            border-top: 5px solid transparent;
            border-left: 10px solid rgba(0, 0, 0, 0.5);
            border-bottom: 5px solid transparent;
            border-right: 0px solid transparent
        }
        
        table.dataTable tr.dt-hasChild td.dt-control:before {
            border-top: 10px solid rgba(0, 0, 0, 0.5);
            border-left: 5px solid transparent;
            border-bottom: 0px solid transparent;
            border-right: 5px solid transparent
        }
        
        html.dark table.dataTable td.dt-control:before,
        :root[data-bs-theme=dark] table.dataTable td.dt-control:before {
            border-left-color: rgba(255, 255, 255, 0.5)
        }
        
        html.dark table.dataTable tr.dt-hasChild td.dt-control:before,
        :root[data-bs-theme=dark] table.dataTable tr.dt-hasChild td.dt-control:before {
            border-top-color: rgba(255, 255, 255, 0.5);
            border-left-color: transparent
        }
        
        div.dt-scroll-body thead tr,
        div.dt-scroll-body tfoot tr {
            height: 0
        }
        
        div.dt-scroll-body thead tr th,
        div.dt-scroll-body thead tr td,
        div.dt-scroll-body tfoot tr th,
        div.dt-scroll-body tfoot tr td {
            height: 0 !important;
            padding-top: 0px !important;
            padding-bottom: 0px !important;
            border-top-width: 0px !important;
            border-bottom-width: 0px !important
        }
        
        div.dt-scroll-body thead tr th div.dt-scroll-sizing,
        div.dt-scroll-body thead tr td div.dt-scroll-sizing,
        div.dt-scroll-body tfoot tr th div.dt-scroll-sizing,
        div.dt-scroll-body tfoot tr td div.dt-scroll-sizing {
            height: 0 !important;
            overflow: hidden !important
        }
        
        table.dataTable thead>tr>th:active,
        table.dataTable thead>tr>td:active {
            outline: none
        }
        
        table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:before,
        table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before {
            position: absolute;
            display: block;
            bottom: 50%;
            content: "";
            content: ""/""
        }
        
        table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:after,
        table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after {
            position: absolute;
            display: block;
            top: 50%;
            content: "";
            content: ""/""
        }
        
        table.dataTable thead>tr>th.dt-orderable-asc,
        table.dataTable thead>tr>th.dt-orderable-desc,
        table.dataTable thead>tr>th.dt-ordering-asc,
        table.dataTable thead>tr>th.dt-ordering-desc,
        table.dataTable thead>tr>td.dt-orderable-asc,
        table.dataTable thead>tr>td.dt-orderable-desc,
        table.dataTable thead>tr>td.dt-ordering-asc,
        table.dataTable thead>tr>td.dt-ordering-desc {
            position: relative;
            padding-right: 30px
        }
        
        table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order,
        table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order,
        table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order,
        table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order,
        table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order,
        table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order,
        table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order,
        table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order {
            position: absolute;
            right: 12px;
            top: 0;
            bottom: 0;
            width: 12px
        }
        
        table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:before,
        table.dataTable thead>tr>th.dt-orderable-asc span.dt-column-order:after,
        table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:before,
        table.dataTable thead>tr>th.dt-orderable-desc span.dt-column-order:after,
        table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,
        table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:after,
        table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:before,
        table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-orderable-asc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-orderable-desc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after {
            left: 0;
            opacity: .125;
            line-height: 9px;
            font-size: .8em
        }
        
        table.dataTable thead>tr>th.dt-orderable-asc,
        table.dataTable thead>tr>th.dt-orderable-desc,
        table.dataTable thead>tr>td.dt-orderable-asc,
        table.dataTable thead>tr>td.dt-orderable-desc {
            cursor: pointer
        }
        
        table.dataTable thead>tr>th.dt-orderable-asc:hover,
        table.dataTable thead>tr>th.dt-orderable-desc:hover,
        table.dataTable thead>tr>td.dt-orderable-asc:hover,
        table.dataTable thead>tr>td.dt-orderable-desc:hover {
            outline: 2px solid rgba(0, 0, 0, 0.05);
            outline-offset: -2px
        }
        
        table.dataTable thead>tr>th.dt-ordering-asc span.dt-column-order:before,
        table.dataTable thead>tr>th.dt-ordering-desc span.dt-column-order:after,
        table.dataTable thead>tr>td.dt-ordering-asc span.dt-column-order:before,
        table.dataTable thead>tr>td.dt-ordering-desc span.dt-column-order:after {
            opacity: .6
        }
        
        table.dataTable thead>tr>th.sorting_desc_disabled span.dt-column-order:after,
        table.dataTable thead>tr>th.sorting_asc_disabled span.dt-column-order:before,
        table.dataTable thead>tr>td.sorting_desc_disabled span.dt-column-order:after,
        table.dataTable thead>tr>td.sorting_asc_disabled span.dt-column-order:before {
            display: none
        }
        
        table.dataTable thead>tr>th:active,
        table.dataTable thead>tr>td:active {
            outline: none
        }
        
        div.dt-scroll-body>table.dataTable>thead>tr>th,
        div.dt-scroll-body>table.dataTable>thead>tr>td {
            overflow: hidden
        }
        
        :root.dark table.dataTable thead>tr>th.dt-orderable-asc:hover,
        :root.dark table.dataTable thead>tr>th.dt-orderable-desc:hover,
        :root.dark table.dataTable thead>tr>td.dt-orderable-asc:hover,
        :root.dark table.dataTable thead>tr>td.dt-orderable-desc:hover,
        :root[data-bs-theme=dark] table.dataTable thead>tr>th.dt-orderable-asc:hover,
        :root[data-bs-theme=dark] table.dataTable thead>tr>th.dt-orderable-desc:hover,
        :root[data-bs-theme=dark] table.dataTable thead>tr>td.dt-orderable-asc:hover,
        :root[data-bs-theme=dark] table.dataTable thead>tr>td.dt-orderable-desc:hover {
            outline: 2px solid rgba(255, 255, 255, 0.05)
        }
        
        div.dt-processing {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            margin-left: -100px;
            margin-top: -22px;
            text-align: center;
            padding: 2px;
            z-index: 10
        }
        
        div.dt-processing>div:last-child {
            position: relative;
            width: 80px;
            height: 15px;
            margin: 1em auto
        }
        
        div.dt-processing>div:last-child>div {
            position: absolute;
            top: 0;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: rgb(13, 110, 253);
            background: rgb(var(--dt-row-selected));
            animation-timing-function: cubic-bezier(0, 1, 1, 0)
        }
        
        div.dt-processing>div:last-child>div:nth-child(1) {
            left: 8px;
            animation: datatables-loader-1 .6s infinite
        }
        
        div.dt-processing>div:last-child>div:nth-child(2) {
            left: 8px;
            animation: datatables-loader-2 .6s infinite
        }
        
        div.dt-processing>div:last-child>div:nth-child(3) {
            left: 32px;
            animation: datatables-loader-2 .6s infinite
        }
        
        div.dt-processing>div:last-child>div:nth-child(4) {
            left: 56px;
            animation: datatables-loader-3 .6s infinite
        }
        
        @keyframes datatables-loader-1 {
            0% {
                transform: scale(0)
            }
            100% {
                transform: scale(1)
            }
        }
        
        @keyframes datatables-loader-3 {
            0% {
                transform: scale(1)
            }
            100% {
                transform: scale(0)
            }
        }
        
        @keyframes datatables-loader-2 {
            0% {
                transform: translate(0, 0)
            }
            100% {
                transform: translate(24px, 0)
            }
        }
        
        table.dataTable.nowrap th,
        table.dataTable.nowrap td {
            white-space: nowrap
        }
        
        table.dataTable th,
        table.dataTable td {
            box-sizing: border-box
        }
        
        table.dataTable th.dt-left,
        table.dataTable td.dt-left {
            text-align: left
        }
        
        table.dataTable th.dt-center,
        table.dataTable td.dt-center {
            text-align: center
        }
        
        table.dataTable th.dt-right,
        table.dataTable td.dt-right {
            text-align: right
        }
        
        table.dataTable th.dt-justify,
        table.dataTable td.dt-justify {
            text-align: justify
        }
        
        table.dataTable th.dt-nowrap,
        table.dataTable td.dt-nowrap {
            white-space: nowrap
        }
        
        table.dataTable th.dt-empty,
        table.dataTable td.dt-empty {
            text-align: center;
            vertical-align: top
        }
        
        table.dataTable th.dt-type-numeric,
        table.dataTable th.dt-type-date,
        table.dataTable td.dt-type-numeric,
        table.dataTable td.dt-type-date {
            text-align: right
        }
        
        table.dataTable thead th,
        table.dataTable thead td,
        table.dataTable tfoot th,
        table.dataTable tfoot td {
            text-align: left
        }
        
        table.dataTable thead th.dt-head-left,
        table.dataTable thead td.dt-head-left,
        table.dataTable tfoot th.dt-head-left,
        table.dataTable tfoot td.dt-head-left {
            text-align: left
        }
        
        table.dataTable thead th.dt-head-center,
        table.dataTable thead td.dt-head-center,
        table.dataTable tfoot th.dt-head-center,
        table.dataTable tfoot td.dt-head-center {
            text-align: center
        }
        
        table.dataTable thead th.dt-head-right,
        table.dataTable thead td.dt-head-right,
        table.dataTable tfoot th.dt-head-right,
        table.dataTable tfoot td.dt-head-right {
            text-align: right
        }
        
        table.dataTable thead th.dt-head-justify,
        table.dataTable thead td.dt-head-justify,
        table.dataTable tfoot th.dt-head-justify,
        table.dataTable tfoot td.dt-head-justify {
            text-align: justify
        }
        
        table.dataTable thead th.dt-head-nowrap,
        table.dataTable thead td.dt-head-nowrap,
        table.dataTable tfoot th.dt-head-nowrap,
        table.dataTable tfoot td.dt-head-nowrap {
            white-space: nowrap
        }
        
        table.dataTable tbody th.dt-body-left,
        table.dataTable tbody td.dt-body-left {
            text-align: left
        }
        
        table.dataTable tbody th.dt-body-center,
        table.dataTable tbody td.dt-body-center {
            text-align: center
        }
        
        table.dataTable tbody th.dt-body-right,
        table.dataTable tbody td.dt-body-right {
            text-align: right
        }
        
        table.dataTable tbody th.dt-body-justify,
        table.dataTable tbody td.dt-body-justify {
            text-align: justify
        }
        
        table.dataTable tbody th.dt-body-nowrap,
        table.dataTable tbody td.dt-body-nowrap {
            white-space: nowrap
        }
        
        table.dataTable {
            width: 100%;
            margin: 0 auto;
            border-spacing: 0
        }
        
        table.dataTable thead th,
        table.dataTable tfoot th {
            font-weight: bold
        }
        
        table.dataTable>thead>tr>th,
        table.dataTable>thead>tr>td {
            padding: 10px
        }
        
        table.dataTable>thead>tr>th:active,
        table.dataTable>thead>tr>td:active {
            outline: none
        }
        
        table.dataTable>tfoot>tr>th,
        table.dataTable>tfoot>tr>td {
            padding: 10px 10px 6px 10px
        }
        
        table.dataTable>tbody>tr {
            background-color: transparent
        }
        
        table.dataTable>tbody>tr:first-child>* {
            border-top: none
        }
        
        table.dataTable>tbody>tr:last-child>* {
            border-bottom: none
        }
        
        table.dataTable>tbody>tr.selected>* {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.9);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.9);
            color: rgb(255, 255, 255);
            color: rgb(var(--dt-row-selected-text))
        }
        
        table.dataTable>tbody>tr.selected a {
            color: rgb(9, 10, 11);
            color: rgb(var(--dt-row-selected-link))
        }
        
        table.dataTable>tbody>tr>th,
        table.dataTable>tbody>tr>td {
            padding: 8px 10px
        }
        
        table.dataTable.row-border>tbody>tr>*,
        table.dataTable.display>tbody>tr>* {
            border-top: 1px solid rgba(0, 0, 0, 0.15)
        }
        
        table.dataTable.row-border>tbody>tr:first-child>*,
        table.dataTable.display>tbody>tr:first-child>* {
            border-top: none
        }
        
        table.dataTable.row-border>tbody>tr.selected+tr.selected>td,
        table.dataTable.display>tbody>tr.selected+tr.selected>td {
            border-top-color: rgba(13, 110, 253, 0.65);
            border-top-color: rgba(var(--dt-row-selected), 0.65)
        }
        
        table.dataTable.cell-border>tbody>tr>* {
            border-top: 1px solid rgba(0, 0, 0, 0.15);
            border-right: 1px solid rgba(0, 0, 0, 0.15)
        }
        
        table.dataTable.cell-border>tbody>tr>*:first-child {
            border-left: 1px solid rgba(0, 0, 0, 0.15)
        }
        
        table.dataTable.cell-border>tbody>tr:first-child>* {
            border-top: 1px solid rgba(0, 0, 0, 0.3)
        }
        
        table.dataTable.stripe>tbody>tr:nth-child(odd)>*,
        table.dataTable.display>tbody>tr:nth-child(odd)>* {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.023);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-stripe), 0.023)
        }
        
        table.dataTable.stripe>tbody>tr:nth-child(odd).selected>*,
        table.dataTable.display>tbody>tr:nth-child(odd).selected>* {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.923);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.923)
        }
        
        table.dataTable.hover>tbody>tr:hover>*,
        table.dataTable.display>tbody>tr:hover>* {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.035);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-hover), 0.035)
        }
        
        table.dataTable.hover>tbody>tr.selected:hover>*,
        table.dataTable.display>tbody>tr.selected:hover>* {
            box-shadow: inset 0 0 0 9999px #0d6efd !important;
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 1) !important
        }
        
        table.dataTable.order-column>tbody tr>.sorting_1,
        table.dataTable.order-column>tbody tr>.sorting_2,
        table.dataTable.order-column>tbody tr>.sorting_3,
        table.dataTable.display>tbody tr>.sorting_1,
        table.dataTable.display>tbody tr>.sorting_2,
        table.dataTable.display>tbody tr>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.019);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.019)
        }
        
        table.dataTable.order-column>tbody tr.selected>.sorting_1,
        table.dataTable.order-column>tbody tr.selected>.sorting_2,
        table.dataTable.order-column>tbody tr.selected>.sorting_3,
        table.dataTable.display>tbody tr.selected>.sorting_1,
        table.dataTable.display>tbody tr.selected>.sorting_2,
        table.dataTable.display>tbody tr.selected>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.919);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.919)
        }
        
        table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_1,
        table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_1 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.054);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.054)
        }
        
        table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_2,
        table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_2 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.047);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.047)
        }
        
        table.dataTable.display>tbody>tr:nth-child(odd)>.sorting_3,
        table.dataTable.order-column.stripe>tbody>tr:nth-child(odd)>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.039);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.039)
        }
        
        table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_1,
        table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_1 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.954);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.954)
        }
        
        table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_2,
        table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_2 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.947);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.947)
        }
        
        table.dataTable.display>tbody>tr:nth-child(odd).selected>.sorting_3,
        table.dataTable.order-column.stripe>tbody>tr:nth-child(odd).selected>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.939);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.939)
        }
        
        table.dataTable.display>tbody>tr.even>.sorting_1,
        table.dataTable.order-column.stripe>tbody>tr.even>.sorting_1 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.019);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.019)
        }
        
        table.dataTable.display>tbody>tr.even>.sorting_2,
        table.dataTable.order-column.stripe>tbody>tr.even>.sorting_2 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.011);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.011)
        }
        
        table.dataTable.display>tbody>tr.even>.sorting_3,
        table.dataTable.order-column.stripe>tbody>tr.even>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.003);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-column-ordering), 0.003)
        }
        
        table.dataTable.display>tbody>tr.even.selected>.sorting_1,
        table.dataTable.order-column.stripe>tbody>tr.even.selected>.sorting_1 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.919);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.919)
        }
        
        table.dataTable.display>tbody>tr.even.selected>.sorting_2,
        table.dataTable.order-column.stripe>tbody>tr.even.selected>.sorting_2 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.911);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.911)
        }
        
        table.dataTable.display>tbody>tr.even.selected>.sorting_3,
        table.dataTable.order-column.stripe>tbody>tr.even.selected>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.903);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.903)
        }
        
        table.dataTable.display tbody tr:hover>.sorting_1,
        table.dataTable.order-column.hover tbody tr:hover>.sorting_1 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.082);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-hover), 0.082)
        }
        
        table.dataTable.display tbody tr:hover>.sorting_2,
        table.dataTable.order-column.hover tbody tr:hover>.sorting_2 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.074);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-hover), 0.074)
        }
        
        table.dataTable.display tbody tr:hover>.sorting_3,
        table.dataTable.order-column.hover tbody tr:hover>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.062);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-hover), 0.062)
        }
        
        table.dataTable.display tbody tr:hover.selected>.sorting_1,
        table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_1 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.982);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.982)
        }
        
        table.dataTable.display tbody tr:hover.selected>.sorting_2,
        table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_2 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.974);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.974)
        }
        
        table.dataTable.display tbody tr:hover.selected>.sorting_3,
        table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(13, 110, 253, 0.962);
            box-shadow: inset 0 0 0 9999px rgba(var(--dt-row-selected), 0.962)
        }
        
        table.dataTable.compact thead th,
        table.dataTable.compact thead td,
        table.dataTable.compact tfoot th,
        table.dataTable.compact tfoot td,
        table.dataTable.compact tbody th,
        table.dataTable.compact tbody td {
            padding: 4px
        }
        
        div.dt-container {
            position: relative;
            clear: both
        }
        
        div.dt-container div.dt-layout-row {
            display: table;
            clear: both;
            width: 100%
        }
        
        div.dt-container div.dt-layout-row.dt-layout-table {
            display: block
        }
        
        div.dt-container div.dt-layout-row.dt-layout-table div.dt-layout-cell {
            display: block
        }
        
        div.dt-container div.dt-layout-cell {
            display: table-cell;
            vertical-align: middle;
            padding: 5px 0
        }
        
        div.dt-container div.dt-layout-cell.dt-full {
            text-align: center
        }
        
        div.dt-container div.dt-layout-cell.dt-start {
            text-align: left
        }
        
        div.dt-container div.dt-layout-cell.dt-end {
            text-align: right
        }
        
        div.dt-container div.dt-layout-cell:empty {
            display: none
        }
        
        div.dt-container .dt-search input {
            border: 1px solid #aaa;
            border-radius: 3px;
            padding: 5px;
            background-color: transparent;
            color: inherit;
            margin-left: 3px
        }
        
        div.dt-container .dt-input {
            border: 1px solid #aaa;
            border-radius: 3px;
            padding: 5px;
            background-color: transparent;
            color: inherit
        }
        
        div.dt-container select.dt-input {
            padding: 4px
        }
        
        div.dt-container .dt-paging .dt-paging-button {
            box-sizing: border-box;
            display: inline-block;
            min-width: 1.5em;
            padding: .5em 1em;
            margin-left: 2px;
            text-align: center;
            text-decoration: none !important;
            cursor: pointer;
            color: inherit !important;
            border: 1px solid transparent;
            border-radius: 2px;
            background: transparent
        }
        
        div.dt-container .dt-paging .dt-paging-button.current,
        div.dt-container .dt-paging .dt-paging-button.current:hover {
            color: inherit !important;
            border: 1px solid rgba(0, 0, 0, 0.3);
            background-color: rgba(0, 0, 0, 0.05);
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, rgba(230, 230, 230, 0.05)), color-stop(100%, rgba(0, 0, 0, 0.05)));
            background: -webkit-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);
            background: -moz-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);
            background: -ms-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);
            background: -o-linear-gradient(top, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%);
            background: linear-gradient(to bottom, rgba(230, 230, 230, 0.05) 0%, rgba(0, 0, 0, 0.05) 100%)
        }
        
        div.dt-container .dt-paging .dt-paging-button.disabled,
        div.dt-container .dt-paging .dt-paging-button.disabled:hover,
        div.dt-container .dt-paging .dt-paging-button.disabled:active {
            cursor: default;
            color: rgba(0, 0, 0, 0.5) !important;
            border: 1px solid transparent;
            background: transparent;
            box-shadow: none
        }
        
        div.dt-container .dt-paging .dt-paging-button:hover {
            color: white !important;
            border: 1px solid #111;
            background-color: #111;
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #585858), color-stop(100%, #111));
            background: -webkit-linear-gradient(top, #585858 0%, #111 100%);
            background: -moz-linear-gradient(top, #585858 0%, #111 100%);
            background: -ms-linear-gradient(top, #585858 0%, #111 100%);
            background: -o-linear-gradient(top, #585858 0%, #111 100%);
            background: linear-gradient(to bottom, #585858 0%, #111 100%)
        }
        
        div.dt-container .dt-paging .dt-paging-button:active {
            outline: none;
            background-color: #0c0c0c;
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #2b2b2b), color-stop(100%, #0c0c0c));
            background: -webkit-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
            background: -moz-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
            background: -ms-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
            background: -o-linear-gradient(top, #2b2b2b 0%, #0c0c0c 100%);
            background: linear-gradient(to bottom, #2b2b2b 0%, #0c0c0c 100%);
            box-shadow: inset 0 0 3px #111
        }
        
        div.dt-container .dt-paging .ellipsis {
            padding: 0 1em
        }
        
        div.dt-container .dt-length,
        div.dt-container .dt-search,
        div.dt-container .dt-info,
        div.dt-container .dt-processing,
        div.dt-container .dt-paging {
            color: inherit
        }
        
        div.dt-container .dataTables_scroll {
            clear: both
        }
        
        div.dt-container .dataTables_scroll div.dt-scroll-body {
            -webkit-overflow-scrolling: touch
        }
        
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>th,
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>td,
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>th,
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>td {
            vertical-align: middle
        }
        
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>th>div.dataTables_sizing,
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>thead>tr>td>div.dataTables_sizing,
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>th>div.dataTables_sizing,
        div.dt-container .dataTables_scroll div.dt-scroll-body>table>tbody>tr>td>div.dataTables_sizing {
            height: 0;
            overflow: hidden;
            margin: 0 !important;
            padding: 0 !important
        }
        
        div.dt-container.dt-empty-footer tbody>tr:last-child>* {
            border-bottom: 1px solid rgba(0, 0, 0, 0.3)
        }
        
        div.dt-container.dt-empty-footer .dt-scroll-body {
            border-bottom: 1px solid rgba(0, 0, 0, 0.3)
        }
        
        div.dt-container.dt-empty-footer .dt-scroll-body tbody>tr:last-child>* {
            border-bottom: none
        }
        
        @media screen and (max-width: 767px) {
            div.dt-container div.dt-layout-row {
                display: block
            }
            div.dt-container div.dt-layout-cell {
                display: block
            }
            div.dt-container div.dt-layout-cell.dt-full,
            div.dt-container div.dt-layout-cell.dt-start,
            div.dt-container div.dt-layout-cell.dt-end {
                text-align: center
            }
        }
        
        @media screen and (max-width: 640px) {
            .dt-container .dt-length,
            .dt-container .dt-search {
                float: none;
                text-align: center
            }
            .dt-container .dt-search {
                margin-top: .5em
            }
        }
        
        html.dark {
            --dt-row-hover: 255, 255, 255;
            --dt-row-stripe: 255, 255, 255;
            --dt-column-ordering: 255, 255, 255
        }
        
        html.dark table.dataTable>thead>tr>th:active,
        html.dark table.dataTable>thead>tr>td:active {
            outline: none
        }
        
        html.dark table.dataTable.row-border>tbody>tr>*,
        html.dark table.dataTable.display>tbody>tr>* {
            border-top: 1px solid rgb(64, 67, 70)
        }
        
        html.dark table.dataTable.row-border>tbody>tr:first-child>*,
        html.dark table.dataTable.display>tbody>tr:first-child>* {
            border-top: none
        }
        
        html.dark table.dataTable.row-border>tbody>tr.selected+tr.selected>td,
        html.dark table.dataTable.display>tbody>tr.selected+tr.selected>td {
            border-top-color: rgba(13, 110, 253, 0.65);
            border-top-color: rgba(var(--dt-row-selected), 0.65)
        }
        
        html.dark table.dataTable.cell-border>tbody>tr>th,
        html.dark table.dataTable.cell-border>tbody>tr>td {
            border-top: 1px solid rgb(64, 67, 70);
            border-right: 1px solid rgb(64, 67, 70)
        }
        
        html.dark table.dataTable.cell-border>tbody>tr>th:first-child,
        html.dark table.dataTable.cell-border>tbody>tr>td:first-child {
            border-left: 1px solid rgb(64, 67, 70)
        }
        
        html.dark .dt-container.dt-empty-footer table.dataTable {
            border-bottom: 1px solid rgb(89, 91, 94)
        }
        
        html.dark .dt-container .dt-search input,
        html.dark .dt-container .dt-length select {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: var(--dt-html-background)
        }
        
        html.dark .dt-container .dt-paging .dt-paging-button.current,
        html.dark .dt-container .dt-paging .dt-paging-button.current:hover {
            border: 1px solid rgb(89, 91, 94);
            background: rgba(255, 255, 255, 0.15)
        }
        
        html.dark .dt-container .dt-paging .dt-paging-button.disabled,
        html.dark .dt-container .dt-paging .dt-paging-button.disabled:hover,
        html.dark .dt-container .dt-paging .dt-paging-button.disabled:active {
            color: #666 !important
        }
        
        html.dark .dt-container .dt-paging .dt-paging-button:hover {
            border: 1px solid rgb(53, 53, 53);
            background: rgb(53, 53, 53)
        }
        
        html.dark .dt-container .dt-paging .dt-paging-button:active {
            background: #3a3a3a
        }
        
        *[dir=rtl] table.dataTable thead th,
        *[dir=rtl] table.dataTable thead td,
        *[dir=rtl] table.dataTable tfoot th,
        *[dir=rtl] table.dataTable tfoot td {
            text-align: right
        }
        
        *[dir=rtl] table.dataTable th.dt-type-numeric,
        *[dir=rtl] table.dataTable th.dt-type-date,
        *[dir=rtl] table.dataTable td.dt-type-numeric,
        *[dir=rtl] table.dataTable td.dt-type-date {
            text-align: left
        }
        
        *[dir=rtl] div.dt-container div.dt-layout-cell.dt-start {
            text-align: right
        }
        
        *[dir=rtl] div.dt-container div.dt-layout-cell.dt-end {
            text-align: left
        }
        
        *[dir=rtl] div.dt-container div.dt-search input {
            margin: 0 3px 0 0
        }
        
        table.dataTable thead th div.DataTables_sort_wrapper {
            position: relative
        }
        
        table.dataTable thead th div.DataTables_sort_wrapper span {
            position: absolute;
            top: 50%;
            margin-top: -8px;
            right: -18px
        }
        
        table.dataTable thead th.ui-state-default,
        table.dataTable tfoot th.ui-state-default {
            border-left-width: 0
        }
        
        table.dataTable thead th.ui-state-default:first-child,
        table.dataTable tfoot th.ui-state-default:first-child {
            border-left-width: 1px
        }
        
        div.dt-container div.dt-layout-row {
            padding: 0
        }
        
        div.dt-container div.dt-layout-cell {
            padding: 10px 0
        }
        
        div.dt-container div.dt-layout-cell.table {
            padding: 0
        }
        
        div.dt-container .dt-paging .fg-button {
            box-sizing: border-box;
            display: inline-block;
            min-width: 1.5em;
            padding: .5em;
            margin-left: 2px;
            text-align: center;
            text-decoration: none !important;
            cursor: pointer;
            border: 1px solid transparent
        }
        
        div.dt-container .dt-paging .fg-button:active {
            outline: none
        }
        
        div.dt-container .dt-paging .fg-button:first-child {
            border-top-left-radius: 3px;
            border-bottom-left-radius: 3px
        }
        
        div.dt-container .dt-paging .fg-button:last-child {
            border-top-right-radius: 3px;
            border-bottom-right-radius: 3px
        }
        
        div.dt-container .ui-widget-header {
            font-weight: normal
        }
        
        div.dt-container .ui-toolbar {
            padding: 8px
        }
        
        div.dt-container.no-footer .dt-scroll-body {
            border-bottom: none
        }
        
        div.dt-container .dt-length,
        div.dt-container .dt-search,
        div.dt-container .dt-info,
        div.dt-container .dt-processing,
        div.dt-container .dt-paging {
            color: inherit
        }
    </style>
    <script>
        /* * This combined file was created by the DataTables downloader builder: * https://datatables.net/download * * To rebuild or modify this file with the latest versions of the included * software please visit: * https://datatables.net/download/#ju/dt-2.0.2 * * Included libraries: * DataTables 2.0.2 */ /*! DataTables 2.0.2 *  SpryMedia Ltd - datatables.net/license */ ! function(n) {
            "use strict";
            var a;
            "function" == typeof define && define.amd ? define(["jquery"], function(e) {
                return n(e, window, document)
            }) : "object" == typeof exports ? (a = require("jquery"), "undefined" == typeof window ? module.exports = function(e, t) {
                return e = e || window, t = t || a(e), n(t, e, e.document)
            } : module.exports = n(a, window, window.document)) : window.DataTable = n(jQuery, window, document)
        }(function(B, q, _) {
            "use strict";

            function g(e) {
                var t = parseInt(e, 10);
                return !isNaN(t) && isFinite(e) ? t : null
            }

            function o(e, t, n) {
                var a = typeof e,
                    r = "string" == a;
                return "number" == a || "bigint" == a || !!y(e) || (t && r && (e = P(e, t)), n && r && (e = e.replace(j, "")), !isNaN(parseFloat(e)) && isFinite(e))
            }

            function l(e, t, n) {
                var a;
                return !!y(e) || ("string" != typeof e || !e.match(/<(input|select)/i)) && (y(a = e) || "string" == typeof a) && !!o(I(e), t, n) || null
            }

            function v(e, t, n, a) {
                var r = [],
                    o = 0,
                    i = t.length;
                if (void 0 !== a)
                    for (; o < i; o++) e[t[o]][n] && r.push(e[t[o]][n][a]);
                else
                    for (; o < i; o++) e[t[o]] && r.push(e[t[o]][n]);
                return r
            }

            function h(e, t) {
                var n, a = [];
                void 0 === t ? (t = 0, n = e) : (n = t, t = e);
                for (var r = t; r < n; r++) a.push(r);
                return a
            }

            function b(e) {
                for (var t = [], n = 0, a = e.length; n < a; n++) e[n] && t.push(e[n]);
                return t
            }
            var C, U, t, e, $ = function(e, H) {
                    var W, X, V;
                    return $.factory(e, H) ? $ : this instanceof $ ? B(e).DataTable(H) : (X = void 0 === (H = e), V = (W = this).length, X && (H = {}), this.api = function() {
                        return new U(this)
                    }, this.each(function() {
                        var n = 1 < V ? Ge({}, H, !0) : H,
                            a = 0,
                            e = this.getAttribute("id"),
                            r = !1,
                            t = $.defaults,
                            o = B(this);
                        if ("table" != this.nodeName.toLowerCase()) Z(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
                        else {
                            B(this).trigger("options.dt", n), ne(t), ae(t.column), z(t, t, !0), z(t.column, t.column, !0), z(t, B.extend(n, o.data()), !0);
                            for (var i = $.settings, a = 0, l = i.length; a < l; a++) {
                                var s = i[a];
                                if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
                                    var k = (void 0 !== n.bRetrieve ? n : t).bRetrieve,
                                        E = (void 0 !== n.bDestroy ? n : t).bDestroy;
                                    if (X || k) return s.oInstance;
                                    if (E) {
                                        new $.Api(s).destroy();
                                        break
                                    }
                                    return void Z(s, 0, "Cannot reinitialise DataTable", 3)
                                }
                                if (s.sTableId == this.id) {
                                    i.splice(a, 1);
                                    break
                                }
                            }
                            null !== e && "" !== e || (e = "DataTables_Table_" + $.ext._unique++, this.id = e);
                            var u = B.extend(!0, {}, $.models.oSettings, {
                                    sDestroyWidth: o[0].style.width,
                                    sInstance: e,
                                    sTableId: e,
                                    colgroup: B("<colgroup>").prependTo(this),
                                    fastData: function(e, t, n) {
                                        return G(u, e, t, n)
                                    }
                                }),
                                e = (u.nTable = this, u.oInit = n, i.push(u), u.api = new U(u), u.oInstance = 1 === W.length ? W : o.dataTable(), ne(n), n.aLengthMenu && !n.iDisplayLength && (n.iDisplayLength = Array.isArray(n.aLengthMenu[0]) ? n.aLengthMenu[0][0] : B.isPlainObject(n.aLengthMenu[0]) ? n.aLengthMenu[0].value : n.aLengthMenu[0]), n = Ge(B.extend(!0, {}, t), n), Q(u.oFeatures, n, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]), Q(u, n, ["ajax", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "iStateDuration", "bSortCellsTop", "iTabIndex", "sDom", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", "caption", "layout", ["iCookieDuration", "iStateDuration"],
                                    ["oSearch", "oPreviousSearch"],
                                    ["aoSearchCols", "aoPreSearchCols"],
                                    ["iDisplayLength", "_iDisplayLength"]
                                ]), Q(u.oScroll, n, [
                                    ["sScrollX", "sX"],
                                    ["sScrollXInner", "sXInner"],
                                    ["sScrollY", "sY"],
                                    ["bScrollCollapse", "bCollapse"]
                                ]), Q(u.oLanguage, n, "fnInfoCallback"), K(u, "aoDrawCallback", n.fnDrawCallback), K(u, "aoStateSaveParams", n.fnStateSaveParams), K(u, "aoStateLoadParams", n.fnStateLoadParams), K(u, "aoStateLoaded", n.fnStateLoaded), K(u, "aoRowCallback", n.fnRowCallback), K(u, "aoRowCreatedCallback", n.fnCreatedRow), K(u, "aoHeaderCallback", n.fnHeaderCallback), K(u, "aoFooterCallback", n.fnFooterCallback), K(u, "aoInitComplete", n.fnInitComplete), K(u, "aoPreDrawCallback", n.fnPreDrawCallback), u.rowIdFn = J(n.rowId), u),
                                c = ($.__browser || (P = {}, $.__browser = P, j = B("<div/>").css({
                                    position: "fixed",
                                    top: 0,
                                    left: -1 * q.pageXOffset,
                                    height: 1,
                                    width: 1,
                                    overflow: "hidden"
                                }).append(B("<div/>").css({
                                    position: "absolute",
                                    top: 1,
                                    left: 1,
                                    width: 100,
                                    overflow: "scroll"
                                }).append(B("<div/>").css({
                                    width: "100%",
                                    height: 10
                                }))).appendTo("body"), p = j.children(), O = p.children(), P.barWidth = p[0].offsetWidth - p[0].clientWidth, P.bScrollbarLeft = 1 !== Math.round(O.offset().left), j.remove()), B.extend(e.oBrowser, $.__browser), e.oScroll.iBarWidth = $.__browser.barWidth, u.oClasses),
                                d = (B.extend(c, $.ext.classes, n.oClasses), o.addClass(c.table), u.oFeatures.bPaginate || (n.iDisplayStart = 0), void 0 === u.iInitDisplayStart && (u.iInitDisplayStart = n.iDisplayStart, u._iDisplayStart = n.iDisplayStart), u.oLanguage),
                                f = (B.extend(!0, d, n.oLanguage), d.sUrl ? (B.ajax({
                                    dataType: "json",
                                    url: d.sUrl,
                                    success: function(e) {
                                        z(t.oLanguage, e), B.extend(!0, d, e, u.oInit.oLanguage), ee(u, null, "i18n", [u], !0), Oe(u)
                                    },
                                    error: function() {
                                        Z(u, 0, "i18n file loading error", 21), Oe(u)
                                    }
                                }), r = !0) : ee(u, null, "i18n", [u]), []),
                                h = this.getElementsByTagName("thead"),
                                p = Ce(u, h[0]);
                            if (n.aoColumns) f = n.aoColumns;
                            else if (p.length)
                                for (l = p[a = 0].length; a < l; a++) f.push(null);
                            for (a = 0, l = f.length; a < l; a++) re(u);
                            var g, m, v, b, y, D, x, S = u,
                                T = n.aoColumnDefs,
                                w = f,
                                M = p,
                                _ = function(e, t) {
                                    oe(u, e, t)
                                },
                                C = S.aoColumns;
                            if (w)
                                for (g = 0, m = w.length; g < m; g++) w[g] && w[g].name && (C[g].sName = w[g].name);
                            if (T)
                                for (g = T.length - 1; 0 <= g; g--) {
                                    var I = void 0 !== (x = T[g]).target ? x.target : void 0 !== x.targets ? x.targets : x.aTargets;
                                    for (Array.isArray(I) || (I = [I]), v = 0, b = I.length; v < b; v++) {
                                        var A = I[v];
                                        if ("number" == typeof A && 0 <= A) {
                                            for (; C.length <= A;) re(S);
                                            _(A, x)
                                        } else if ("number" == typeof A && A < 0) _(C.length + A, x);
                                        else if ("string" == typeof A)
                                            for (y = 0, D = C.length; y < D; y++) "_all" === A ? _(y, x) : -1 !== A.indexOf(":name") ? C[y].sName === A.replace(":name", "") && _(y, x) : M.forEach(function(e) {
                                                e[y] && (e = B(e[y].cell), A.match(/^[a-z][\w-]*$/i) && (A = "." + A), e.is(A)) && _(y, x)
                                            })
                                    }
                                }
                            if (w)
                                for (g = 0, m = w.length; g < m; g++) _(g, w[g]);
                            var F, L, N, j, P = o.children("tbody").find("tr").eq(0),
                                R = (P.length && (F = function(e, t) {
                                    return null !== e.getAttribute("data-" + t) ? t : null
                                }, B(P[0]).children("th, td").each(function(e, t) {
                                    var n, a = u.aoColumns[e];
                                    a || Z(u, 0, "Incorrect column count", 18), a.mData === e && (n = F(t, "sort") || F(t, "order"), t = F(t, "filter") || F(t, "search"), null === n && null === t || (a.mData = {
                                        _: e + ".display",
                                        sort: null !== n ? e + ".@data-" + n : void 0,
                                        type: null !== n ? e + ".@data-" + n : void 0,
                                        filter: null !== t ? e + ".@data-" + t : void 0
                                    }, a._isArrayHost = !0, oe(u, e)))
                                })), u.oFeatures),
                                O = function() {
                                    if (void 0 === n.aaSorting) {
                                        var e = u.aaSorting;
                                        for (a = 0, l = e.length; a < l; a++) e[a][1] = u.aoColumns[a].asSorting[0]
                                    }
                                    $e(u), K(u, "aoDrawCallback", function() {
                                        (u.bSorted || "ssp" === te(u) || R.bDeferRender) && $e(u)
                                    });
                                    var t = o.children("caption"),
                                        t = (u.caption && (t = 0 === t.length ? B("<caption/>").appendTo(o) : t).html(u.caption), t.length && (t[0]._captionSide = t.css("caption-side"), u.captionNode = t[0]), 0 === h.length && (h = B("<thead/>").appendTo(o)), u.nTHead = h[0], B("tr", h).addClass(c.thead.row), o.children("tbody")),
                                        t = (0 === t.length && (t = B("<tbody/>").insertAfter(h)), u.nTBody = t[0], o.children("tfoot"));
                                    if (0 === t.length && (t = B("<tfoot/>").appendTo(o)), u.nTFoot = t[0], B("tr", t).addClass(c.tfoot.row), n.aaData)
                                        for (a = 0; a < n.aaData.length; a++) Y(u, n.aaData[a]);
                                    else "dom" == te(u) && se(u, B(u.nTBody).children("tr"));
                                    u.aiDisplay = u.aiDisplayMaster.slice(), !(u.bInitialised = !0) === r && Oe(u)
                                };
                            K(u, "aoDrawCallback", ze), n.bStateSave ? (R.bStateSave = !0, N = O, (L = u).oFeatures.bStateSave ? void 0 !== (j = L.fnStateLoadCallback.call(L.oInstance, L, function(e) {
                                Ye(L, e, N)
                            })) && Ye(L, j, N) : N()) : O()
                        }
                    }), W = null, this)
                },
                c = ($.ext = C = {
                    buttons: {},
                    classes: {},
                    builder: "ju/dt-2.0.2",
                    errMode: "alert",
                    feature: [],
                    features: {},
                    search: [],
                    selector: {
                        cell: [],
                        column: [],
                        row: []
                    },
                    legacy: {
                        ajax: null
                    },
                    pager: {},
                    renderer: {
                        pageButton: {},
                        header: {}
                    },
                    order: {},
                    type: {
                        className: {},
                        detect: [],
                        render: {},
                        search: {},
                        order: {}
                    },
                    _unique: 0,
                    fnVersionCheck: $.fnVersionCheck,
                    iApiIndex: 0,
                    sVersion: $.version
                }, B.extend(C, {
                    afnFiltering: C.search,
                    aTypes: C.type.detect,
                    ofnSearch: C.type.search,
                    oSort: C.type.order,
                    afnSortData: C.order,
                    aoFeatures: C.feature,
                    oStdClasses: C.classes,
                    oPagination: C.pager
                }), B.extend($.ext.classes, {
                    container: "dt-container",
                    empty: {
                        row: "dt-empty"
                    },
                    info: {
                        container: "dt-info"
                    },
                    length: {
                        container: "dt-length",
                        select: "dt-input"
                    },
                    order: {
                        canAsc: "dt-orderable-asc",
                        canDesc: "dt-orderable-desc",
                        isAsc: "dt-ordering-asc",
                        isDesc: "dt-ordering-desc",
                        none: "dt-orderable-none",
                        position: "sorting_"
                    },
                    processing: {
                        container: "dt-processing"
                    },
                    scrolling: {
                        body: "dt-scroll-body",
                        container: "dt-scroll",
                        footer: {
                            self: "dt-scroll-foot",
                            inner: "dt-scroll-footInner"
                        },
                        header: {
                            self: "dt-scroll-head",
                            inner: "dt-scroll-headInner"
                        }
                    },
                    search: {
                        container: "dt-search",
                        input: "dt-input"
                    },
                    table: "dataTable",
                    tbody: {
                        cell: "",
                        row: ""
                    },
                    thead: {
                        cell: "",
                        row: ""
                    },
                    tfoot: {
                        cell: "",
                        row: ""
                    },
                    paging: {
                        active: "current",
                        button: "dt-paging-button",
                        container: "dt-paging",
                        disabled: "disabled"
                    }
                }), {}),
                d = /[\r\n\u2028]/g,
                F = /<.*?>/g,
                L = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/,
                N = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g"),
                j = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi,
                y = function(e) {
                    return !e || !0 === e || "-" === e
                },
                P = function(e, t) {
                    return c[t] || (c[t] = new RegExp(je(t), "g")), "string" == typeof e && "." !== t ? e.replace(/\./g, "").replace(c[t], ".") : e
                },
                f = function(e, t, n) {
                    var a = [],
                        r = 0,
                        o = e.length;
                    if (void 0 !== n)
                        for (; r < o; r++) e[r] && e[r][t] && a.push(e[r][t][n]);
                    else
                        for (; r < o; r++) e[r] && a.push(e[r][t]);
                    return a
                },
                I = function(e) {
                    return e.replace(F, "").replace(/<script/i, "")
                },
                u = function(e) {
                    return "string" == typeof(e = Array.isArray(e) ? e.join(",") : e) ? e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : e
                },
                R = function(e, t) {
                    var n;
                    return "string" != typeof e ? e : (n = e.normalize("NFD")).length !== e.length ? (!0 === t ? e + " " : "") + n.replace(/[\u0300-\u036f]/g, "") : n
                },
                x = function(e) {
                    if (Array.from && Set) return Array.from(new Set(e));
                    if (function(e) {
                            if (!(e.length < 2))
                                for (var t = e.slice().sort(), n = t[0], a = 1, r = t.length; a < r; a++) {
                                    if (t[a] === n) return !1;
                                    n = t[a]
                                }
                            return !0
                        }(e)) return e.slice();
                    var t, n, a, r = [],
                        o = e.length,
                        i = 0;
                    e: for (n = 0; n < o; n++) {
                        for (t = e[n], a = 0; a < i; a++)
                            if (r[a] === t) continue e;
                        r.push(t), i++
                    }
                    return r
                },
                O = function(e, t) {
                    if (Array.isArray(t))
                        for (var n = 0; n < t.length; n++) O(e, t[n]);
                    else e.push(t);
                    return e
                };

            function D(t, e) {
                e && e.split(" ").forEach(function(e) {
                    e && t.classList.add(e)
                })
            }

            function k(t) {
                var n, a, r = {};
                B.each(t, function(e) {
                    (n = e.match(/^([^A-Z]+?)([A-Z])/)) && -1 !== "a aa ai ao as b fn i m o s ".indexOf(n[1] + " ") && (a = e.replace(n[0], n[2].toLowerCase()), r[a] = e, "o" === n[1]) && k(t[e])
                }), t._hungarianMap = r
            }

            function z(t, n, a) {
                var r;
                t._hungarianMap || k(t), B.each(n, function(e) {
                    void 0 === (r = t._hungarianMap[e]) || !a && void 0 !== n[r] || ("o" === r.charAt(0) ? (n[r] || (n[r] = {}), B.extend(!0, n[r], n[e]), z(t[r], n[r], a)) : n[r] = n[e])
                })
            }
            $.util = {
                diacritics: function(e, t) {
                    if ("function" != typeof e) return R(e, t);
                    R = e
                },
                debounce: function(n, a) {
                    var r;
                    return function() {
                        var e = this,
                            t = arguments;
                        clearTimeout(r), r = setTimeout(function() {
                            n.apply(e, t)
                        }, a || 250)
                    }
                },
                throttle: function(a, e) {
                    var r, o, i = void 0 !== e ? e : 200;
                    return function() {
                        var e = this,
                            t = +new Date,
                            n = arguments;
                        r && t < r + i ? (clearTimeout(o), o = setTimeout(function() {
                            r = void 0, a.apply(e, n)
                        }, i)) : (r = t, a.apply(e, n))
                    }
                },
                escapeRegex: function(e) {
                    return e.replace(N, "\\$1")
                },
                set: function(a) {
                    var f;
                    return B.isPlainObject(a) ? $.util.set(a._) : null === a ? function() {} : "function" == typeof a ? function(e, t, n) {
                        a(e, "set", t, n)
                    } : "string" != typeof a || -1 === a.indexOf(".") && -1 === a.indexOf("[") && -1 === a.indexOf("(") ? function(e, t) {
                        e[a] = t
                    } : (f = function(e, t, n) {
                        for (var a, r, o, i, l = de(n), n = l[l.length - 1], s = 0, u = l.length - 1; s < u; s++) {
                            if ("__proto__" === l[s] || "constructor" === l[s]) throw new Error("Cannot set prototype values");
                            if (a = l[s].match(ce), r = l[s].match(p), a) {
                                if (l[s] = l[s].replace(ce, ""), e[l[s]] = [], (a = l.slice()).splice(0, s + 1), i = a.join("."), Array.isArray(t))
                                    for (var c = 0, d = t.length; c < d; c++) f(o = {}, t[c], i), e[l[s]].push(o);
                                else e[l[s]] = t;
                                return
                            }
                            r && (l[s] = l[s].replace(p, ""), e = e[l[s]](t)), null !== e[l[s]] && void 0 !== e[l[s]] || (e[l[s]] = {}), e = e[l[s]]
                        }
                        n.match(p) ? e[n.replace(p, "")](t) : e[n.replace(ce, "")] = t
                    }, function(e, t) {
                        return f(e, t, a)
                    })
                },
                get: function(r) {
                    var o, f;
                    return B.isPlainObject(r) ? (o = {}, B.each(r, function(e, t) {
                        t && (o[e] = $.util.get(t))
                    }), function(e, t, n, a) {
                        var r = o[t] || o._;
                        return void 0 !== r ? r(e, t, n, a) : e
                    }) : null === r ? function(e) {
                        return e
                    } : "function" == typeof r ? function(e, t, n, a) {
                        return r(e, t, n, a)
                    } : "string" != typeof r || -1 === r.indexOf(".") && -1 === r.indexOf("[") && -1 === r.indexOf("(") ? function(e) {
                        return e[r]
                    } : (f = function(e, t, n) {
                        var a, r, o;
                        if ("" !== n)
                            for (var i = de(n), l = 0, s = i.length; l < s; l++) {
                                if (d = i[l].match(ce), a = i[l].match(p), d) {
                                    if (i[l] = i[l].replace(ce, ""), "" !== i[l] && (e = e[i[l]]), r = [], i.splice(0, l + 1), o = i.join("."), Array.isArray(e))
                                        for (var u = 0, c = e.length; u < c; u++) r.push(f(e[u], t, o));
                                    var d = d[0].substring(1, d[0].length - 1);
                                    e = "" === d ? r : r.join(d);
                                    break
                                }
                                if (a) i[l] = i[l].replace(p, ""), e = e[i[l]]();
                                else {
                                    if (null === e || null === e[i[l]]) return null;
                                    if (void 0 === e || void 0 === e[i[l]]) return;
                                    e = e[i[l]]
                                }
                            }
                        return e
                    }, function(e, t) {
                        return f(e, t, r)
                    })
                },
                stripHtml: function(e) {
                    var t = typeof e;
                    if ("function" != t) return "string" == t ? I(e) : e;
                    I = e
                },
                escapeHtml: function(e) {
                    var t = typeof e;
                    if ("function" != t) return "string" == t || Array.isArray(e) ? u(e) : e;
                    u = e
                },
                unique: x
            };
            var r = function(e, t, n) {
                void 0 !== e[t] && (e[n] = e[t])
            };

            function ne(e) {
                r(e, "ordering", "bSort"), r(e, "orderMulti", "bSortMulti"), r(e, "orderClasses", "bSortClasses"), r(e, "orderCellsTop", "bSortCellsTop"), r(e, "order", "aaSorting"), r(e, "orderFixed", "aaSortingFixed"), r(e, "paging", "bPaginate"), r(e, "pagingType", "sPaginationType"), r(e, "pageLength", "iDisplayLength"), r(e, "searching", "bFilter"), "boolean" == typeof e.sScrollX && (e.sScrollX = e.sScrollX ? "100%" : ""), "boolean" == typeof e.scrollX && (e.scrollX = e.scrollX ? "100%" : "");
                var t = e.aoSearchCols;
                if (t)
                    for (var n = 0, a = t.length; n < a; n++) t[n] && z($.models.oSearch, t[n]);
                e.serverSide && !e.searchDelay && (e.searchDelay = 400)
            }

            function ae(e) {
                r(e, "orderable", "bSortable"), r(e, "orderData", "aDataSort"), r(e, "orderSequence", "asSorting"), r(e, "orderDataType", "sortDataType");
                var t = e.aDataSort;
                "number" != typeof t || Array.isArray(t) || (e.aDataSort = [t])
            }

            function re(e) {
                var t = $.defaults.column,
                    n = e.aoColumns.length,
                    t = B.extend({}, $.models.oColumn, t, {
                        aDataSort: t.aDataSort || [n],
                        mData: t.mData || n,
                        idx: n,
                        searchFixed: {},
                        colEl: B("<col>")
                    }),
                    t = (e.aoColumns.push(t), e.aoPreSearchCols);
                t[n] = B.extend({}, $.models.oSearch, t[n])
            }

            function oe(e, t, n) {
                function a(e) {
                    return "string" == typeof e && -1 !== e.indexOf("@")
                }
                var r = e.aoColumns[t],
                    o = (null != n && (ae(n), z($.defaults.column, n, !0), void 0 === n.mDataProp || n.mData || (n.mData = n.mDataProp), n.sType && (r._sManualType = n.sType), n.className && !n.sClass && (n.sClass = n.className), t = r.sClass, B.extend(r, n), Q(r, n, "sWidth", "sWidthOrig"), t !== r.sClass && (r.sClass = t + " " + r.sClass), void 0 !== n.iDataSort && (r.aDataSort = [n.iDataSort]), Q(r, n, "aDataSort")), r.mData),
                    i = J(o);
                r.mRender && Array.isArray(r.mRender) && (n = (t = r.mRender.slice()).shift(), r.mRender = $.render[n].apply(q, t)), r._render = r.mRender ? J(r.mRender) : null;
                r._bAttrSrc = B.isPlainObject(o) && (a(o.sort) || a(o.type) || a(o.filter)), r._setter = null, r.fnGetData = function(e, t, n) {
                    var a = i(e, t, void 0, n);
                    return r._render && t ? r._render(a, t, e, n) : a
                }, r.fnSetData = function(e, t, n) {
                    return m(o)(e, t, n)
                }, "number" == typeof o || r._isArrayHost || (e._rowReadObject = !0), e.oFeatures.bSort || (r.bSortable = !1)
            }

            function E(e) {
                var t = e;
                if (t.oFeatures.bAutoWidth) {
                    var n, a, r = t.nTable,
                        o = t.aoColumns,
                        i = t.oScroll,
                        l = i.sY,
                        s = i.sX,
                        i = i.sXInner,
                        u = W(t, "bVisible"),
                        c = r.getAttribute("width"),
                        d = r.parentNode,
                        f = r.style.width,
                        f = (f && -1 !== f.indexOf("%") && (c = f), ee(t, null, "column-calc", {
                            visible: u
                        }, !1), B(r.cloneNode()).css("visibility", "hidden").removeAttr("id")),
                        h = (f.append("<tbody>"), B("<tr/>").appendTo(f.find("tbody")));
                    for (f.append(B(t.nTHead).clone()).append(B(t.nTFoot).clone()), f.find("tfoot th, tfoot td").css("width", ""), f.find("thead th, thead td").each(function() {
                            var e = ie(t, this, !0, !1);
                            e ? (this.style.width = e, s && B(this).append(B("<div/>").css({
                                width: e,
                                margin: 0,
                                padding: 0,
                                border: 0,
                                height: 1
                            }))) : this.style.width = ""
                        }), n = 0; n < u.length; n++) {
                        p = u[n], a = o[p];
                        var p = function(e, t) {
                                var n = e.aoColumns[t];
                                if (!n.maxLenString) {
                                    for (var a, r = "", o = -1, i = 0, l = e.aiDisplayMaster.length; i < l; i++) {
                                        var s = e.aiDisplayMaster[i],
                                            s = me(e, s)[t],
                                            s = s && "object" == typeof s && s.nodeType ? s.innerHTML : s + "";
                                        s = s.replace(/id=".*?"/g, "").replace(/name=".*?"/g, ""), (a = I(s).replace(/&nbsp;/g, " ")).length > o && (r = s, o = a.length)
                                    }
                                    n.maxLenString = r
                                }
                                return n.maxLenString
                            }(t, p),
                            g = C.type.className[a.sType],
                            m = p + a.sContentPadding,
                            p = -1 === p.indexOf("<") ? _.createTextNode(m) : m;
                        B("<td/>").addClass(g).addClass(a.sClass).append(p).appendTo(h)
                    }
                    B("[name]", f).removeAttr("name");
                    var v = B("<div/>").css(s || l ? {
                            position: "absolute",
                            top: 0,
                            left: 0,
                            height: 1,
                            right: 0,
                            overflow: "hidden"
                        } : {}).append(f).appendTo(d),
                        b = (s && i ? f.width(i) : s ? (f.css("width", "auto"), f.removeAttr("width"), f.width() < d.clientWidth && c && f.width(d.clientWidth)) : l ? f.width(d.clientWidth) : c && f.width(c), 0),
                        y = f.find("tbody tr").eq(0).children();
                    for (n = 0; n < u.length; n++) {
                        var D = y[n].getBoundingClientRect().width;
                        b += D, o[u[n]].sWidth = A(D)
                    }
                    r.style.width = A(b), v.remove(), c && (r.style.width = A(c)), !c && !s || t._reszEvt || (B(q).on("resize.DT-" + t.sInstance, $.util.throttle(function() {
                        t.bDestroying || E(t)
                    })), t._reszEvt = !0)
                }
                for (var x = e, S = x.aoColumns, T = 0; T < S.length; T++) {
                    var w = ie(x, [T], !1, !1);
                    S[T].colEl.css("width", w)
                }
                i = e.oScroll;
                "" === i.sY && "" === i.sX || We(e), ee(e, null, "column-sizing", [e])
            }

            function M(e, t) {
                e = W(e, "bVisible");
                return "number" == typeof e[t] ? e[t] : null
            }

            function T(e, t) {
                e = W(e, "bVisible").indexOf(t);
                return -1 !== e ? e : null
            }

            function H(e) {
                var t = e.aoHeader,
                    n = e.aoColumns,
                    a = 0;
                if (t.length)
                    for (var r = 0, o = t[0].length; r < o; r++) n[r].bVisible && "none" !== B(t[0][r].cell).css("display") && a++;
                return a
            }

            function W(e, n) {
                var a = [];
                return e.aoColumns.map(function(e, t) {
                    e[n] && a.push(t)
                }), a
            }

            function X(e) {
                for (var t, n, a, r, o, i, l, s = e.aoColumns, u = e.aoData, c = $.ext.type.detect, d = 0, f = s.length; d < f; d++) {
                    if (l = [], !(o = s[d]).sType && o._sManualType) o.sType = o._sManualType;
                    else if (!o.sType) {
                        for (t = 0, n = c.length; t < n; t++) {
                            for (a = 0, r = u.length; a < r; a++)
                                if (u[a]) {
                                    if (void 0 === l[a] && (l[a] = G(e, a, d, "type")), !(i = c[t](l[a], e)) && t !== c.length - 2) break;
                                    if ("html" === i && !y(l[a])) break
                                }
                            if (i) {
                                o.sType = i;
                                break
                            }
                        }
                        o.sType || (o.sType = "string")
                    }
                    var h = C.type.className[o.sType],
                        h = (h && (V(e.aoHeader, d, h), V(e.aoFooter, d, h)), C.type.render[o.sType]);
                    if (h && !o._render) {
                        o._render = $.util.get(h), p = b = v = m = g = void 0;
                        for (var p, g = e, m = d, v = g.aoData, b = 0; b < v.length; b++) v[b].nTr && (p = G(g, b, m, "display"), v[b].displayData[m] = p, ue(v[b].anCells[m], p))
                    }
                }
            }

            function V(e, t, n) {
                e.forEach(function(e) {
                    e[t] && e[t].unique && D(e[t].cell, n)
                })
            }

            function ie(e, t, n, a) {
                Array.isArray(t) || (t = le(t));
                for (var r, o = 0, i = e.aoColumns, l = 0, s = t.length; l < s; l++) {
                    var u = i[t[l]],
                        c = n ? u.sWidthOrig : u.sWidth;
                    if (a || !1 !== u.bVisible) {
                        if (null == c) return null;
                        "number" == typeof c ? (r = "px", o += c) : (u = c.match(/([\d\.]+)([^\d]*)/)) && (o += +u[1], r = 3 === u.length ? u[2] : "px")
                    }
                }
                return o + r
            }

            function le(e) {
                e = B(e).closest("[data-dt-column]").attr("data-dt-column");
                return e ? e.split(",").map(function(e) {
                    return +e
                }) : []
            }

            function Y(e, t, n, a) {
                for (var r = e.aoData.length, o = B.extend(!0, {}, $.models.oRow, {
                        src: n ? "dom" : "data",
                        idx: r
                    }), i = (o._aData = t, e.aoData.push(o), e.aoColumns), l = 0, s = i.length; l < s; l++) i[l].sType = null;
                e.aiDisplayMaster.push(r);
                t = e.rowIdFn(t);
                return void 0 !== t && (e.aIds[t] = o), !n && e.oFeatures.bDeferRender || ve(e, r, n, a), r
            }

            function se(n, e) {
                var a;
                return (e = e instanceof B ? e : B(e)).map(function(e, t) {
                    return a = ge(n, t), Y(n, a.data, t, a.cells)
                })
            }

            function G(e, t, n, a) {
                "search" === a ? a = "filter" : "order" === a && (a = "sort");
                var r = e.iDraw,
                    o = e.aoColumns[n],
                    i = e.aoData[t]._aData,
                    l = o.sDefaultContent,
                    s = o.fnGetData(i, a, {
                        settings: e,
                        row: t,
                        col: n
                    });
                if (void 0 === (s = "display" !== a && s && "object" == typeof s && s.nodeName ? s.innerHTML : s)) return e.iDrawError != r && null === l && (Z(e, 0, "Requested unknown parameter " + ("function" == typeof o.mData ? "{function}" : "'" + o.mData + "'") + " for row " + t + ", column " + n, 4), e.iDrawError = r), l;
                if (s !== i && null !== s || null === l || void 0 === a) {
                    if ("function" == typeof s) return s.call(i)
                } else s = l;
                return null === s && "display" === a ? "" : "filter" === a && (t = $.ext.type.search)[o.sType] ? t[o.sType](s) : s
            }

            function ue(e, t) {
                t && "object" == typeof t && t.nodeName ? B(e).empty().append(t) : e.innerHTML = t
            }
            var ce = /\[.*?\]$/,
                p = /\(\)$/;

            function de(e) {
                return (e.match(/(\\.|[^.])+/g) || [""]).map(function(e) {
                    return e.replace(/\\\./g, ".")
                })
            }
            var J = $.util.get,
                m = $.util.set;

            function fe(e) {
                return f(e.aoData, "_aData")
            }

            function he(e) {
                e.aoData.length = 0, e.aiDisplayMaster.length = 0, e.aiDisplay.length = 0, e.aIds = {}
            }

            function pe(e, t, n, a) {
                var r, o, i = e.aoData[t];
                if (i._aSortData = null, i._aFilterData = null, i.displayData = null, "dom" !== n && (n && "auto" !== n || "dom" !== i.src)) {
                    var l = i.anCells,
                        s = me(e, t);
                    if (l)
                        if (void 0 !== a) ue(l[a], s[a]);
                        else
                            for (r = 0, o = l.length; r < o; r++) ue(l[r], s[r])
                } else i._aData = ge(e, i, a, void 0 === a ? void 0 : i._aData).data;
                var u = e.aoColumns;
                if (void 0 !== a) u[a].sType = null, u[a].maxLenString = null;
                else {
                    for (r = 0, o = u.length; r < o; r++) u[r].sType = null, u[r].maxLenString = null;
                    be(e, i)
                }
            }

            function ge(e, t, n, a) {
                function r(e, t) {
                    var n;
                    "string" == typeof e && -1 !== (n = e.indexOf("@")) && (n = e.substring(n + 1), m(e)(a, t.getAttribute(n)))
                }

                function o(e) {
                    void 0 !== n && n !== d || (l = f[d], s = e.innerHTML.trim(), l && l._bAttrSrc ? (m(l.mData._)(a, s), r(l.mData.sort, e), r(l.mData.type, e), r(l.mData.filter, e)) : h ? (l._setter || (l._setter = m(l.mData)), l._setter(a, s)) : a[d] = s), d++
                }
                var i, l, s, u = [],
                    c = t.firstChild,
                    d = 0,
                    f = e.aoColumns,
                    h = e._rowReadObject;
                a = void 0 !== a ? a : h ? {} : [];
                if (c)
                    for (; c;) "TD" != (i = c.nodeName.toUpperCase()) && "TH" != i || (o(c), u.push(c)), c = c.nextSibling;
                else
                    for (var p = 0, g = (u = t.anCells).length; p < g; p++) o(u[p]);
                var t = t.firstChild ? t : t.nTr;
                return t && (t = t.getAttribute("id")) && m(e.rowId)(a, t), {
                    data: a,
                    cells: u
                }
            }

            function me(e, t) {
                var n = e.aoData[t],
                    a = e.aoColumns;
                if (!n.displayData) {
                    n.displayData = [];
                    for (var r = 0, o = a.length; r < o; r++) n.displayData.push(G(e, t, r, "display"))
                }
                return n.displayData
            }

            function ve(e, t, n, a) {
                var r, o, i, l, s, u, c = e.aoData[t],
                    d = c._aData,
                    f = [],
                    h = e.oClasses.tbody.row;
                if (null === c.nTr) {
                    for (r = n || _.createElement("tr"), c.nTr = r, c.anCells = f, D(r, h), r._DT_RowIndex = t, be(e, c), l = 0, s = e.aoColumns.length; l < s; l++) {
                        i = e.aoColumns[l], (o = (u = !n || !a[l]) ? _.createElement(i.sCellType) : a[l]) || Z(e, 0, "Incorrect column count", 18), o._DT_CellIndex = {
                            row: t,
                            column: l
                        }, f.push(o);
                        var p = me(e, t);
                        !u && (!i.mRender && i.mData === l || B.isPlainObject(i.mData) && i.mData._ === l + ".display") || ue(o, p[l]), i.bVisible && u ? r.appendChild(o) : i.bVisible || u || o.parentNode.removeChild(o), i.fnCreatedCell && i.fnCreatedCell.call(e.oInstance, o, G(e, t, l), d, t, l)
                    }
                    ee(e, "aoRowCreatedCallback", "row-created", [r, d, t, f])
                } else D(c.nTr, h)
            }

            function be(e, t) {
                var n = t.nTr,
                    a = t._aData;
                n && ((e = e.rowIdFn(a)) && (n.id = e), a.DT_RowClass && (e = a.DT_RowClass.split(" "), t.__rowc = t.__rowc ? x(t.__rowc.concat(e)) : e, B(n).removeClass(t.__rowc.join(" ")).addClass(a.DT_RowClass)), a.DT_RowAttr && B(n).attr(a.DT_RowAttr), a.DT_RowData) && B(n).data(a.DT_RowData)
            }

            function ye(e, t) {
                var n, a = e.oClasses,
                    r = e.aoColumns,
                    o = "header" === t ? e.nTHead : e.nTFoot,
                    i = "header" === t ? "sTitle" : t;
                if (o) {
                    if (("header" === t || f(e.aoColumns, i).join("")) && 1 === (n = (n = B("tr", o)).length ? n : B("<tr/>").appendTo(o)).length)
                        for (var l = B("td, th", n).length, s = r.length; l < s; l++) B("<th/>").html(r[l][i] || "").appendTo(n);
                    var u = Ce(e, o, !0);
                    "header" === t ? e.aoHeader = u : e.aoFooter = u, B(o).children("tr").attr("role", "row"), B(o).children("tr").children("th, td").each(function() {
                        Qe(e, t)(e, B(this), a)
                    })
                }
            }

            function De(e, t, n) {
                var a, r, o, i, l, s = [],
                    u = [],
                    c = e.aoColumns,
                    e = c.length;
                if (t) {
                    for (n = n || h(e).filter(function(e) {
                            return c[e].bVisible
                        }), a = 0; a < t.length; a++) s[a] = t[a].slice().filter(function(e, t) {
                        return n.includes(t)
                    }), u.push([]);
                    for (a = 0; a < s.length; a++)
                        for (r = 0; r < s[a].length; r++)
                            if (l = i = 1, void 0 === u[a][r]) {
                                for (o = s[a][r].cell; void 0 !== s[a + i] && s[a][r].cell == s[a + i][r].cell;) u[a + i][r] = null, i++;
                                for (; void 0 !== s[a][r + l] && s[a][r].cell == s[a][r + l].cell;) {
                                    for (var d = 0; d < i; d++) u[a + d][r + l] = null;
                                    l++
                                }
                                var f = B("span.dt-column-title", o);
                                u[a][r] = {
                                    cell: o,
                                    colspan: l,
                                    rowspan: i,
                                    title: (f.length ? f : B(o)).html()
                                }
                            }
                    return u
                }
            }

            function xe(e, t) {
                for (var n, a, r = De(e, t), o = 0; o < t.length; o++) {
                    if (n = t[o].row)
                        for (; a = n.firstChild;) n.removeChild(a);
                    for (var i = 0; i < r[o].length; i++) {
                        var l = r[o][i];
                        l && B(l.cell).appendTo(n).attr("rowspan", l.rowspan).attr("colspan", l.colspan)
                    }
                }
            }

            function S(e, t) {
                if (r = "ssp" == te(s = e), void 0 !== (i = s.iInitDisplayStart) && -1 !== i && (s._iDisplayStart = !r && i >= s.fnRecordsDisplay() ? 0 : i, s.iInitDisplayStart = -1), -1 !== ee(e, "aoPreDrawCallback", "preDraw", [e]).indexOf(!1)) w(e, !1);
                else {
                    var l, n = [],
                        a = 0,
                        r = "ssp" == te(e),
                        o = e.aiDisplay,
                        i = e._iDisplayStart,
                        s = e.fnDisplayEnd(),
                        u = e.aoColumns,
                        c = B(e.nTBody);
                    if (e.bDrawing = !0, r) {
                        if (!e.bDestroying && !t) return 0 === e.iDraw && c.empty().append(Se(e)), (l = e).iDraw++, w(l, !0), void Ie(l, function(t) {
                            function n(e, t) {
                                return "function" == typeof a[e][t] ? "function" : a[e][t]
                            }
                            var a = t.aoColumns,
                                e = t.oFeatures,
                                r = t.oPreviousSearch,
                                o = t.aoPreSearchCols;
                            return {
                                draw: t.iDraw,
                                columns: a.map(function(t, e) {
                                    return {
                                        data: n(e, "mData"),
                                        name: t.sName,
                                        searchable: t.bSearchable,
                                        orderable: t.bSortable,
                                        search: {
                                            value: o[e].search,
                                            regex: o[e].regex,
                                            fixed: Object.keys(t.searchFixed).map(function(e) {
                                                return {
                                                    name: e,
                                                    term: t.searchFixed[e].toString()
                                                }
                                            })
                                        }
                                    }
                                }),
                                order: qe(t).map(function(e) {
                                    return {
                                        column: e.col,
                                        dir: e.dir,
                                        name: n(e.col, "sName")
                                    }
                                }),
                                start: t._iDisplayStart,
                                length: e.bPaginate ? t._iDisplayLength : -1,
                                search: {
                                    value: r.search,
                                    regex: r.regex,
                                    fixed: Object.keys(t.searchFixed).map(function(e) {
                                        return {
                                            name: e,
                                            term: t.searchFixed[e].toString()
                                        }
                                    })
                                }
                            }
                        }(l), function(e) {
                            var t = l,
                                n = Ae(t, e = e),
                                a = Fe(t, "draw", e),
                                r = Fe(t, "recordsTotal", e),
                                e = Fe(t, "recordsFiltered", e);
                            if (void 0 !== a) {
                                if (+a < t.iDraw) return;
                                t.iDraw = +a
                            }
                            n = n || [], he(t), t._iRecordsTotal = parseInt(r, 10), t._iRecordsDisplay = parseInt(e, 10);
                            for (var o = 0, i = n.length; o < i; o++) Y(t, n[o]);
                            t.aiDisplay = t.aiDisplayMaster.slice(), S(t, !0), ke(t), w(t, !1)
                        })
                    } else e.iDraw++;
                    if (0 !== o.length)
                        for (var d = r ? e.aoData.length : s, f = r ? 0 : i; f < d; f++) {
                            for (var h = o[f], p = e.aoData[h], g = (null === p.nTr && ve(e, h), p.nTr), m = 0; m < u.length; m++) {
                                var v = u[m],
                                    b = p.anCells[m];
                                D(b, C.type.className[v.sType]), D(b, v.sClass), D(b, e.oClasses.tbody.cell)
                            }
                            ee(e, "aoRowCallback", null, [g, p._aData, a, f, h]), n.push(g), a++
                        } else n[0] = Se(e);
                    ee(e, "aoHeaderCallback", "header", [B(e.nTHead).children("tr")[0], fe(e), i, s, o]), ee(e, "aoFooterCallback", "footer", [B(e.nTFoot).children("tr")[0], fe(e), i, s, o]), c.children().detach(), c.append(B(n)), B(e.nTableWrapper).toggleClass("dt-empty-footer", 0 === B("tr", e.nTFoot).length), ee(e, "aoDrawCallback", "draw", [e], !0), e.bSorted = !1, e.bFiltered = !1, e.bDrawing = !1
                }
            }

            function s(e, t, n) {
                var a = e.oFeatures,
                    r = a.bSort,
                    a = a.bFilter;
                void 0 !== n && !0 !== n || (r && Ue(e), a ? Le(e, e.oPreviousSearch) : e.aiDisplay = e.aiDisplayMaster.slice()), !0 !== t && (e._iDisplayStart = 0), e._drawHold = t, S(e), e._drawHold = !1
            }

            function Se(e) {
                var t = e.oLanguage,
                    n = t.sZeroRecords,
                    a = te(e);
                return e.iDraw < 1 && "ssp" === a || e.iDraw <= 1 && "ajax" === a ? n = t.sLoadingRecords : t.sEmptyTable && 0 === e.fnRecordsTotal() && (n = t.sEmptyTable), B("<tr/>").append(B("<td />", {
                    colSpan: H(e),
                    class: e.oClasses.empty.row
                }).html(n))[0]
            }

            function Te(e, t, n) {
                for (var i = {}, a = (B.each(t, function(e, t) {
                        if (null !== t) {
                            var e = e.replace(/([A-Z])/g, " $1").split(" "),
                                n = (i[e[0]] || (i[e[0]] = {}), 1 === e.length ? "full" : e[1].toLowerCase()),
                                a = i[e[0]],
                                r = function(t, n) {
                                    B.isPlainObject(n) ? Object.keys(n).map(function(e) {
                                        t.push({
                                            feature: e,
                                            opts: n[e]
                                        })
                                    }) : t.push(n)
                                };
                            if (a[n] && a[n].contents || (a[n] = {
                                    contents: []
                                }), Array.isArray(t))
                                for (var o = 0; o < t.length; o++) r(a[n].contents, t[o]);
                            else r(a[n].contents, t);
                            Array.isArray(a[n].contents) || (a[n].contents = [a[n].contents])
                        }
                    }), Object.keys(i).map(function(e) {
                        return 0 !== e.indexOf(n) ? null : {
                            name: e,
                            val: i[e]
                        }
                    }).filter(function(e) {
                        return null !== e
                    })), r = (a.sort(function(e, t) {
                        e = +e.name.replace(/[^0-9]/g, "");
                        return +t.name.replace(/[^0-9]/g, "") - e
                    }), "bottom" === n && a.reverse(), []), o = 0, l = a.length; o < l; o++) a[o].val.full && (r.push({
                    full: a[o].val.full
                }), we(e, r[r.length - 1]), delete a[o].val.full), Object.keys(a[o].val).length && (r.push(a[o].val), we(e, r[r.length - 1]));
                return r
            }

            function we(o, i) {
                function l(e, t) {
                    return C.features[e] || Z(o, 0, "Unknown feature: " + e), C.features[e].apply(this, [o, t])
                }
                B.each(i, function(e) {
                    for (var t, n = i[e].contents, a = 0, r = n.length; a < r; a++) n[a] && ("string" == typeof n[a] ? n[a] = l(n[a], null) : B.isPlainObject(n[a]) ? n[a] = l(n[a].feature, n[a].opts) : "function" == typeof n[a].node ? n[a] = n[a].node(o) : "function" == typeof n[a] && (t = n[a](o), n[a] = "function" == typeof t.node ? t.node() : t))
                })
            }

            function _e(t) {
                var a, e = t.oClasses,
                    n = B(t.nTable),
                    r = B("<div/>").attr({
                        id: t.sTableId + "_wrapper",
                        class: e.container
                    }).insertBefore(n),
                    e = (t.nTableWrapper = r[0], Te(t, t.layout, "top")),
                    n = Te(t, t.layout, "bottom"),
                    o = Qe(t, "layout");
                if (t.sDom)
                    for (var i, l, s, u, c, d, f = t, h = t.sDom, p = r, g = h.match(/(".*?")|('.*?')|./g), m = 0; m < g.length; m++) i = null, "<" == (l = g[m]) ? (s = B("<div/>"), "'" != (u = g[m + 1])[0] && '"' != u[0] || (u = u.replace(/['"]/g, ""), c = "", -1 != u.indexOf(".") ? (d = u.split("."), c = d[0], d = d[1]) : "#" == u[0] ? c = u : d = u, s.attr("id", c.substring(1)).addClass(d), m++), p.append(s), p = s) : ">" == l ? p = p.parent() : "t" == l ? i = He(f) : $.ext.feature.forEach(function(e) {
                        l == e.cFeature && (i = e.fnInit(f))
                    }), i && p.append(i);
                else e.forEach(function(e) {
                    o(t, r, e)
                }), o(t, r, {
                    full: {
                        table: !0,
                        contents: [He(t)]
                    }
                }), n.forEach(function(e) {
                    o(t, r, e)
                });
                h = t, e = h.nTable;
                h.oFeatures.bProcessing && (a = B("<div/>", {
                    id: h.sTableId + "_processing",
                    class: h.oClasses.processing.container,
                    role: "status"
                }).html(h.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(e), B(e).on("processing.dt.DT", function(e, t, n) {
                    a.css("display", n ? "block" : "none")
                }))
            }

            function Ce(e, t, n) {
                for (var a, r, o, i, l, s, u = e.aoColumns, c = B(t).children("tr"), d = t && "thead" === t.nodeName.toLowerCase(), f = [], h = 0, p = c.length; h < p; h++) f.push([]);
                for (h = 0, p = c.length; h < p; h++)
                    for (r = (a = c[h]).firstChild; r;) {
                        if ("TD" == r.nodeName.toUpperCase() || "TH" == r.nodeName.toUpperCase()) {
                            var g, m, v, b, y, D = [];
                            for (b = (b = +r.getAttribute("colspan")) && 0 != b && 1 != b ? b : 1, y = (y = +r.getAttribute("rowspan")) && 0 != y && 1 != y ? y : 1, l = function(e, t, n) {
                                    for (var a = e[t]; a[n];) n++;
                                    return n
                                }(f, h, 0), s = 1 == b, n && (s && (oe(e, l, B(r).data()), g = u[l], m = r.getAttribute("width") || null, (v = r.style.width.match(/width:\s*(\d+[pxem%]+)/)) && (m = v[1]), g.sWidthOrig = g.sWidth || m, d ? (null === g.sTitle || g.autoTitle || (r.innerHTML = g.sTitle), !g.sTitle && s && (g.sTitle = r.innerHTML.replace(/<.*?>/g, ""), g.autoTitle = !0)) : g.footer && (r.innerHTML = g.footer), g.ariaTitle || (g.ariaTitle = B(r).attr("aria-label") || g.sTitle), g.className) && B(r).addClass(g.className), 0 === B("span.dt-column-title", r).length && B("<span>").addClass("dt-column-title").append(r.childNodes).appendTo(r), d) && 0 === B("span.dt-column-order", r).length && B("<span>").addClass("dt-column-order").appendTo(r), i = 0; i < b; i++) {
                                for (o = 0; o < y; o++) f[h + o][l + i] = {
                                    cell: r,
                                    unique: s
                                }, f[h + o].row = a;
                                D.push(l + i)
                            }
                            r.setAttribute("data-dt-column", x(D).join(","))
                        }
                        r = r.nextSibling
                    }
                return f
            }

            function Ie(n, e, a) {
                function t(e) {
                    var t = n.jqXHR ? n.jqXHR.status : null;
                    (null === e || "number" == typeof t && 204 == t) && Ae(n, e = {}, []), (t = e.error || e.sError) && Z(n, 0, t), n.json = e, ee(n, null, "xhr", [n, e, n.jqXHR], !0), a(e)
                }
                var r, o = n.ajax,
                    i = n.oInstance,
                    l = (B.isPlainObject(o) && o.data && (l = "function" == typeof(r = o.data) ? r(e, n) : r, e = "function" == typeof r && l ? l : B.extend(!0, e, l), delete o.data), {
                        url: "string" == typeof o ? o : "",
                        data: e,
                        success: t,
                        dataType: "json",
                        cache: !1,
                        type: n.sServerMethod,
                        error: function(e, t) {
                            -1 === ee(n, null, "xhr", [n, null, n.jqXHR], !0).indexOf(!0) && ("parsererror" == t ? Z(n, 0, "Invalid JSON response", 1) : 4 === e.readyState && Z(n, 0, "Ajax error", 7)), w(n, !1)
                        }
                    });
                B.isPlainObject(o) && B.extend(l, o), n.oAjaxData = e, ee(n, null, "preXhr", [n, e, l], !0), "function" == typeof o ? n.jqXHR = o.call(i, e, t, n) : "" === o.url ? (i = {}, $.util.set(o.dataSrc)(i, []), t(i)) : (n.jqXHR = B.ajax(l), r && (o.data = r))
            }

            function Ae(e, t, n) {
                var a = "data";
                if (B.isPlainObject(e.ajax) && void 0 !== e.ajax.dataSrc && ("string" == typeof(e = e.ajax.dataSrc) || "function" == typeof e ? a = e : void 0 !== e.data && (a = e.data)), !n) return "data" === a ? t.aaData || t[a] : "" !== a ? J(a)(t) : t;
                m(a)(t, n)
            }

            function Fe(e, t, n) {
                var e = B.isPlainObject(e.ajax) ? e.ajax.dataSrc : null;
                return e && e[t] ? J(e[t])(n) : (e = "", "draw" === t ? e = "sEcho" : "recordsTotal" === t ? e = "iTotalRecords" : "recordsFiltered" === t && (e = "iTotalDisplayRecords"), void 0 !== n[e] ? n[e] : n[t])
            }

            function Le(n, e) {
                var t = n.aoPreSearchCols;
                if (X(n), "ssp" != te(n)) {
                    for (var a, r, o, i, l, s = n, u = s.aoColumns, c = s.aoData, d = 0; d < c.length; d++)
                        if (c[d] && !(l = c[d])._aFilterData) {
                            for (o = [], a = 0, r = u.length; a < r; a++) u[a].bSearchable ? "string" != typeof(i = null === (i = G(s, d, a, "filter")) ? "" : i) && i.toString && (i = i.toString()) : i = "", i.indexOf && -1 !== i.indexOf("&") && (Pe.innerHTML = i, i = Re ? Pe.textContent : Pe.innerText), i.replace && (i = i.replace(/[\r\n\u2028]/g, "")), o.push(i);
                            l._aFilterData = o, l._sFilterRow = o.join(" "), 0
                        }
                    n.aiDisplay = n.aiDisplayMaster.slice(), Ne(n.aiDisplay, n, e.search, e), B.each(n.searchFixed, function(e, t) {
                        Ne(n.aiDisplay, n, t, {})
                    });
                    for (var f = 0; f < t.length; f++) {
                        var h = t[f];
                        Ne(n.aiDisplay, n, h.search, h, f), B.each(n.aoColumns[f].searchFixed, function(e, t) {
                            Ne(n.aiDisplay, n, t, {}, f)
                        })
                    }
                    for (var p, g, m = n, v = $.ext.search, b = m.aiDisplay, y = 0, D = v.length; y < D; y++) {
                        for (var x = [], S = 0, T = b.length; S < T; S++) g = b[S], p = m.aoData[g], v[y](m, p._aFilterData, g, p._aData, S) && x.push(g);
                        b.length = 0, b.push.apply(b, x)
                    }
                }
                n.bFiltered = !0, ee(n, null, "search", [n])
            }

            function Ne(e, t, n, a, r) {
                if ("" !== n)
                    for (var o = 0, i = "function" == typeof n ? n : null, l = n instanceof RegExp ? n : i ? null : function(e, t) {
                            var a = [],
                                t = B.extend({}, {
                                    boundary: !1,
                                    caseInsensitive: !0,
                                    exact: !1,
                                    regex: !1,
                                    smart: !0
                                }, t);
                            "string" != typeof e && (e = e.toString());
                            if (e = R(e), t.exact) return new RegExp("^" + je(e) + "$", t.caseInsensitive ? "i" : ""); {
                                var n, r, o;
                                e = t.regex ? e : je(e), t.smart && (n = (e.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""]).map(function(e) {
                                    var t, n = !1;
                                    return "!" === e.charAt(0) && (n = !0, e = e.substring(1)), '"' === e.charAt(0) ? e = (t = e.match(/^"(.*)"$/)) ? t[1] : e : "" === e.charAt(0) && (e = (t = e.match(/^\u201C(.*)\u201D$/)) ? t[1] : e), n && (1 < e.length && a.push("(?!" + e + ")"), e = ""), e.replace('"', "")
                                }), r = a.length ? a.join("") : "", o = t.boundary ? "\\b" : "", e = "^(?=.*?" + o + n.join(")(?=.*?" + o) + ")(" + r + ".)*$")
                            }
                            return new RegExp(e, t.caseInsensitive ? "i" : "")
                        }(n, a); o < e.length;) {
                        var s = t.aoData[e[o]],
                            u = void 0 === r ? s._sFilterRow : s._aFilterData[r];
                        (i && !i(u, s._aData, e[o], r) || l && !l.test(u)) && (e.splice(o, 1), o--), o++
                    }
            }
            var je = $.util.escapeRegex,
                Pe = B("<div>")[0],
                Re = void 0 !== Pe.textContent;

            function Oe(n) {
                var a, e, t, r, o, i, l = n.iInitDisplayStart;
                n.bInitialised ? (ye(n, "header"), ye(n, "footer"), xe(n, n.aoHeader), xe(n, n.aoFooter), _e(n), t = (e = n).nTHead, i = t.querySelectorAll("tr"), r = e.bSortCellsTop, o = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])', !0 === r ? t = i[0] : !1 === r && (t = i[i.length - 1]), Ve(e, t, t === e.nTHead ? "tr" + o + " th" + o + ", tr" + o + " td" + o : "th" + o + ", td" + o), Be(e, r = [], e.aaSorting), e.aaSorting = r, Xe(n), w(n, !0), ee(n, null, "preInit", [n], !0), s(n), "ssp" != (i = te(n)) && ("ajax" == i ? Ie(n, {}, function(e) {
                    var t = Ae(n, e);
                    for (a = 0; a < t.length; a++) Y(n, t[a]);
                    n.iInitDisplayStart = l, s(n), w(n, !1), ke(n)
                }) : (ke(n), w(n, !1)))) : setTimeout(function() {
                    Oe(n)
                }, 200)
            }

            function ke(e) {
                var t;
                e._bInitComplete || (t = [e, e.json], e._bInitComplete = !0, E(e), ee(e, null, "plugin-init", t, !0), ee(e, "aoInitComplete", "init", t, !0))
            }

            function Ee(e, t) {
                t = parseInt(t, 10);
                e._iDisplayLength = t, Ze(e), ee(e, null, "length", [e, t])
            }

            function Me(e, t, n) {
                var a = e._iDisplayStart,
                    r = e._iDisplayLength,
                    o = e.fnRecordsDisplay();
                if (0 === o || -1 === r) a = 0;
                else if ("number" == typeof t) o < (a = t * r) && (a = 0);
                else if ("first" == t) a = 0;
                else if ("previous" == t)(a = 0 <= r ? a - r : 0) < 0 && (a = 0);
                else if ("next" == t) a + r < o && (a += r);
                else if ("last" == t) a = Math.floor((o - 1) / r) * r;
                else {
                    if ("ellipsis" === t) return;
                    Z(e, 0, "Unknown paging action: " + t, 5)
                }
                o = e._iDisplayStart !== a;
                e._iDisplayStart = a, ee(e, null, o ? "page" : "page-nc", [e]), o && n && S(e)
            }

            function w(e, t) {
                ee(e, null, "processing", [e, t])
            }

            function He(e) {
                var t, n, a, r, o, i, l, s, u, c, d, f, h, p = B(e.nTable),
                    g = e.oScroll;
                return "" === g.sX && "" === g.sY ? e.nTable : (t = g.sX, n = g.sY, a = e.oClasses.scrolling, o = (r = e.captionNode) ? r._captionSide : null, u = B(p[0].cloneNode(!1)), i = B(p[0].cloneNode(!1)), c = function(e) {
                    return e ? A(e) : null
                }, (l = p.children("tfoot")).length || (l = null), u = B(s = "<div/>", {
                    class: a.container
                }).append(B(s, {
                    class: a.header.self
                }).css({
                    overflow: "hidden",
                    position: "relative",
                    border: 0,
                    width: t ? c(t) : "100%"
                }).append(B(s, {
                    class: a.header.inner
                }).css({
                    "box-sizing": "content-box",
                    width: g.sXInner || "100%"
                }).append(u.removeAttr("id").css("margin-left", 0).append("top" === o ? r : null).append(p.children("thead"))))).append(B(s, {
                    class: a.body
                }).css({
                    position: "relative",
                    overflow: "auto",
                    width: c(t)
                }).append(p)), l && u.append(B(s, {
                    class: a.footer.self
                }).css({
                    overflow: "hidden",
                    border: 0,
                    width: t ? c(t) : "100%"
                }).append(B(s, {
                    class: a.footer.inner
                }).append(i.removeAttr("id").css("margin-left", 0).append("bottom" === o ? r : null).append(p.children("tfoot"))))), c = u.children(), d = c[0], f = c[1], h = l ? c[2] : null, B(f).on("scroll.DT", function() {
                    var e = this.scrollLeft;
                    d.scrollLeft = e, l && (h.scrollLeft = e)
                }), B("th, td", d).on("focus", function() {
                    var e = d.scrollLeft;
                    f.scrollLeft = e, l && (f.scrollLeft = e)
                }), B(f).css("max-height", n), g.bCollapse || B(f).css("height", n), e.nScrollHead = d, e.nScrollBody = f, e.nScrollFoot = h, e.aoDrawCallback.push(We), u[0])
            }

            function We(e) {
                var t, n, a = e.oScroll.iBarWidth,
                    r = B(e.nScrollHead).children("div"),
                    o = r.children("table"),
                    i = e.nScrollBody,
                    l = B(i),
                    s = B(e.nScrollFoot).children("div"),
                    u = s.children("table"),
                    c = B(e.nTHead),
                    d = B(e.nTable),
                    f = e.nTFoot && B("th, td", e.nTFoot).length ? B(e.nTFoot) : null,
                    h = e.oBrowser,
                    p = i.scrollHeight > i.clientHeight;
                e.scrollBarVis !== p && void 0 !== e.scrollBarVis ? (e.scrollBarVis = p, E(e)) : (e.scrollBarVis = p, d.children("thead, tfoot").remove(), (p = c.clone().prependTo(d)).find("th, td").removeAttr("tabindex"), p.find("[id]").removeAttr("id"), f && (n = f.clone().prependTo(d)).find("[id]").removeAttr("id"), e.aiDisplay.length && (t = d.find("tbody tr").eq(0).find("th, td").map(function() {
                    return B(this).outerWidth()
                }), B("col", e.colgroup).each(function(e) {
                    this.style.width.replace("px", "") !== t[e] && (this.style.width = t[e] + "px")
                })), o.find("colgroup").remove(), o.append(e.colgroup.clone()), f && (u.find("colgroup").remove(), u.append(e.colgroup.clone())), B("th, td", p).each(function() {
                    B(this.childNodes).wrapAll('<div class="dt-scroll-sizing">')
                }), f && B("th, td", n).each(function() {
                    B(this.childNodes).wrapAll('<div class="dt-scroll-sizing">')
                }), c = Math.floor(d.height()) > i.clientHeight || "scroll" == l.css("overflow-y"), p = "padding" + (h.bScrollbarLeft ? "Left" : "Right"), n = d.outerWidth(), o.css("width", A(n)), r.css("width", A(n)).css(p, c ? a + "px" : "0px"), f && (u.css("width", A(n)), s.css("width", A(n)).css(p, c ? a + "px" : "0px")), d.children("colgroup").prependTo(d), l.trigger("scroll"), !e.bSorted && !e.bFiltered || e._drawHold || (i.scrollTop = 0))
            }

            function A(e) {
                return null === e ? "0px" : "number" == typeof e ? e < 0 ? "0px" : e + "px" : e.match(/\d$/) ? e + "px" : e
            }

            function Xe(e) {
                var t = e.aoColumns;
                for (e.colgroup.empty(), a = 0; a < t.length; a++) t[a].bVisible && e.colgroup.append(t[a].colEl)
            }

            function Ve(i, e, t, o, l) {
                Je(e, t, function(e) {
                    var t = !1,
                        n = void 0 === o ? le(e.target) : [o];
                    if (n.length) {
                        for (var a = 0, r = n.length; a < r; a++)
                            if (!1 !== function(e, t, n, a) {
                                    function r(e, t) {
                                        var n = e._idx;
                                        return (n = void 0 === n ? s.indexOf(e[1]) : n) + 1 < s.length ? n + 1 : t ? null : 0
                                    }
                                    var o, i = e.aoColumns[t],
                                        l = e.aaSorting,
                                        s = i.asSorting;
                                    if (!i.bSortable) return !1;
                                    "number" == typeof l[0] && (l = e.aaSorting = [l]);
                                    (a || n) && e.oFeatures.bSortMulti ? -1 !== (i = f(l, "0").indexOf(t)) ? null === (o = null === (o = r(l[i], !0)) && 1 === l.length ? 0 : o) ? l.splice(i, 1) : (l[i][1] = s[o], l[i]._idx = o) : (a ? l.push([t, s[0], 0]) : l.push([t, l[0][1], 0]), l[l.length - 1]._idx = 0) : l.length && l[0][0] == t ? (o = r(l[0]), l.length = 1, l[0][1] = s[o], l[0]._idx = o) : (l.length = 0, l.push([t, s[0]]), l[0]._idx = 0)
                                }(i, n[a], a, e.shiftKey) && (t = !0), 1 === i.aaSorting.length && "" === i.aaSorting[0][1]) break;
                        t && (w(i, !0), setTimeout(function() {
                            Ue(i);
                            var e, t = i,
                                n = t.aiDisplay,
                                a = t.aiDisplayMaster,
                                r = {},
                                o = {};
                            for (e = 0; e < a.length; e++) r[a[e]] = e;
                            for (e = 0; e < n.length; e++) o[n[e]] = r[n[e]];
                            n.sort(function(e, t) {
                                return o[e] - o[t]
                            }), s(i, !1, !1), w(i, !1), l && l()
                        }, 0))
                    }
                })
            }

            function Be(n, a, e) {
                function t(e) {
                    var t;
                    B.isPlainObject(e) ? void 0 !== e.idx ? a.push([e.idx, e.dir]) : e.name && -1 !== (t = f(n.aoColumns, "sName").indexOf(e.name)) && a.push([t, e.dir]) : a.push(e)
                }
                if (B.isPlainObject(e)) t(e);
                else if (e.length && "number" == typeof e[0]) t(e);
                else if (e.length)
                    for (var r = 0; r < e.length; r++) t(e[r])
            }

            function qe(e) {
                var t, n, a, r, o, i, l, s = [],
                    u = $.ext.type.order,
                    c = e.aoColumns,
                    d = e.aaSortingFixed,
                    f = B.isPlainObject(d),
                    h = [];
                if (e.oFeatures.bSort)
                    for (Array.isArray(d) && Be(e, h, d), f && d.pre && Be(e, h, d.pre), Be(e, h, e.aaSorting), f && d.post && Be(e, h, d.post), t = 0; t < h.length; t++)
                        if (c[l = h[t][0]])
                            for (n = 0, a = (r = c[l].aDataSort).length; n < a; n++) i = c[o = r[n]].sType || "string", void 0 === h[t]._idx && (h[t]._idx = c[o].asSorting.indexOf(h[t][1])), h[t][1] && s.push({
                                src: l,
                                col: o,
                                dir: h[t][1],
                                index: h[t]._idx,
                                type: i,
                                formatter: u[i + "-pre"],
                                sorter: u[i + "-" + h[t][1]]
                            });
                return s
            }

            function Ue(e, t, n) {
                var a, r, o, i, l, c, d = [],
                    s = $.ext.type.order,
                    f = e.aoData,
                    u = e.aiDisplayMaster;
                for (X(e), void 0 !== t ? (l = e.aoColumns[t], c = [{
                        src: t,
                        col: t,
                        dir: n,
                        index: 0,
                        type: l.sType,
                        formatter: s[l.sType + "-pre"],
                        sorter: s[l.sType + "-" + n]
                    }], u = u.slice()) : c = qe(e), a = 0, r = c.length; a < r; a++) {
                    i = c[a], S = x = D = g = p = h = y = b = v = m = void 0;
                    var h, p, g, m = e,
                        v = i.col,
                        b = m.aoColumns[v],
                        y = $.ext.order[b.sSortDataType];
                    y && (h = y.call(m.oInstance, m, v, T(m, v)));
                    for (var D = $.ext.type.order[b.sType + "-pre"], x = m.aoData, S = 0; S < x.length; S++) x[S] && ((p = x[S])._aSortData || (p._aSortData = []), p._aSortData[v] && !y || (g = y ? h[S] : G(m, S, v, "sort"), p._aSortData[v] = D ? D(g, m) : g))
                }
                if ("ssp" != te(e) && 0 !== c.length) {
                    for (a = 0, o = u.length; a < o; a++) d[a] = a;
                    c.length && "desc" === c[0].dir && d.reverse(), u.sort(function(e, t) {
                        for (var n, a, r, o, i = c.length, l = f[e]._aSortData, s = f[t]._aSortData, u = 0; u < i; u++)
                            if (n = l[(o = c[u]).col], a = s[o.col], o.sorter) {
                                if (0 !== (r = o.sorter(n, a))) return r
                            } else if (0 !== (r = n < a ? -1 : a < n ? 1 : 0)) return "asc" === o.dir ? r : -r;
                        return (n = d[e]) < (a = d[t]) ? -1 : a < n ? 1 : 0
                    })
                } else 0 === c.length && u.sort(function(e, t) {
                    return e < t ? -1 : t < e ? 1 : 0
                });
                return void 0 === t && (e.bSorted = !0, ee(e, null, "order", [e, c])), u
            }

            function $e(e) {
                var t, n, a, r = e.aLastSort,
                    o = e.oClasses.order.position,
                    i = qe(e),
                    l = e.oFeatures;
                if (l.bSort && l.bSortClasses) {
                    for (t = 0, n = r.length; t < n; t++) a = r[t].src, B(f(e.aoData, "anCells", a)).removeClass(o + (t < 2 ? t + 1 : 3));
                    for (t = 0, n = i.length; t < n; t++) a = i[t].src, B(f(e.aoData, "anCells", a)).addClass(o + (t < 2 ? t + 1 : 3))
                }
                e.aLastSort = i
            }

            function ze(n) {
                var e;
                n._bLoadingState || (e = {
                    time: +new Date,
                    start: n._iDisplayStart,
                    length: n._iDisplayLength,
                    order: B.extend(!0, [], n.aaSorting),
                    search: B.extend({}, n.oPreviousSearch),
                    columns: n.aoColumns.map(function(e, t) {
                        return {
                            visible: e.bVisible,
                            search: B.extend({}, n.aoPreSearchCols[t])
                        }
                    })
                }, n.oSavedState = e, ee(n, "aoStateSaveParams", "stateSaveParams", [n, e]), n.oFeatures.bStateSave && !n.bDestroying && n.fnStateSaveCallback.call(n.oInstance, n, e))
            }

            function Ye(n, e, t) {
                var a, r, o = n.aoColumns,
                    i = (n._bLoadingState = !0, n._bInitComplete ? new $.Api(n) : null);
                if (e && e.time) {
                    var l = n.iStateDuration;
                    if (0 < l && e.time < +new Date - 1e3 * l) n._bLoadingState = !1;
                    else if (-1 !== ee(n, "aoStateLoadParams", "stateLoadParams", [n, e]).indexOf(!1)) n._bLoadingState = !1;
                    else if (e.columns && o.length !== e.columns.length) n._bLoadingState = !1;
                    else {
                        if (n.oLoadedState = B.extend(!0, {}, e), ee(n, null, "stateLoadInit", [n, e], !0), void 0 !== e.length && (i ? i.page.len(e.length) : n._iDisplayLength = e.length), void 0 !== e.start && (null === i ? (n._iDisplayStart = e.start, n.iInitDisplayStart = e.start) : Me(n, e.start / n._iDisplayLength)), void 0 !== e.order && (n.aaSorting = [], B.each(e.order, function(e, t) {
                                n.aaSorting.push(t[0] >= o.length ? [0, t[1]] : t)
                            })), void 0 !== e.search && B.extend(n.oPreviousSearch, e.search), e.columns) {
                            for (a = 0, r = e.columns.length; a < r; a++) {
                                var s = e.columns[a];
                                void 0 !== s.visible && (i ? i.column(a).visible(s.visible, !1) : o[a].bVisible = s.visible), void 0 !== s.search && B.extend(n.aoPreSearchCols[a], s.search)
                            }
                            i && i.columns.adjust()
                        }
                        n._bLoadingState = !1, ee(n, "aoStateLoaded", "stateLoaded", [n, e])
                    }
                } else n._bLoadingState = !1;
                t()
            }

            function Z(e, t, n, a) {
                if (n = "DataTables warning: " + (e ? "table id=" + e.sTableId + " - " : "") + n, a && (n += ". For more information about this error, please see https://datatables.net/tn/" + a), t) q.console && console.log && console.log(n);
                else {
                    t = $.ext, t = t.sErrMode || t.errMode;
                    if (e && ee(e, null, "dt-error", [e, a, n], !0), "alert" == t) alert(n);
                    else {
                        if ("throw" == t) throw new Error(n);
                        "function" == typeof t && t(e, a, n)
                    }
                }
            }

            function Q(n, a, e, t) {
                Array.isArray(e) ? B.each(e, function(e, t) {
                    Array.isArray(t) ? Q(n, a, t[0], t[1]) : Q(n, a, t)
                }) : (void 0 === t && (t = e), void 0 !== a[e] && (n[t] = a[e]))
            }

            function Ge(e, t, n) {
                var a, r;
                for (r in t) Object.prototype.hasOwnProperty.call(t, r) && (a = t[r], B.isPlainObject(a) ? (B.isPlainObject(e[r]) || (e[r] = {}), B.extend(!0, e[r], a)) : n && "data" !== r && "aaData" !== r && Array.isArray(a) ? e[r] = a.slice() : e[r] = a);
                return e
            }

            function Je(e, t, n) {
                B(e).on("click.DT", t, function(e) {
                    n(e)
                }).on("keypress.DT", t, function(e) {
                    13 === e.which && (e.preventDefault(), n(e))
                }).on("selectstart.DT", t, function() {
                    return !1
                })
            }

            function K(e, t, n) {
                n && e[t].push(n)
            }

            function ee(t, e, n, a, r) {
                var o = [];
                return e && (o = t[e].slice().reverse().map(function(e) {
                    return e.apply(t.oInstance, a)
                })), null !== n && (e = B.Event(n + ".dt"), n = B(t.nTable), e.dt = t.api, n[r ? "trigger" : "triggerHandler"](e, a), r && 0 === n.parents("body").length && B("body").trigger(e, a), o.push(e.result)), o
            }

            function Ze(e) {
                var t = e._iDisplayStart,
                    n = e.fnDisplayEnd(),
                    a = e._iDisplayLength;
                n <= t && (t = n - a), t -= t % a, e._iDisplayStart = t = -1 === a || t < 0 ? 0 : t
            }

            function Qe(e, t) {
                var e = e.renderer,
                    n = $.ext.renderer[t];
                return B.isPlainObject(e) && e[t] ? n[e[t]] || n._ : "string" == typeof e && n[e] || n._
            }

            function te(e) {
                return e.oFeatures.bServerSide ? "ssp" : e.ajax ? "ajax" : "dom"
            }

            function Ke(e, t, n) {
                var a = e.fnFormatNumber,
                    r = e._iDisplayStart + 1,
                    o = e._iDisplayLength,
                    i = e.fnRecordsDisplay(),
                    l = e.fnRecordsTotal(),
                    s = -1 === o;
                return t.replace(/_START_/g, a.call(e, r)).replace(/_END_/g, a.call(e, e.fnDisplayEnd())).replace(/_MAX_/g, a.call(e, l)).replace(/_TOTAL_/g, a.call(e, i)).replace(/_PAGE_/g, a.call(e, s ? 1 : Math.ceil(r / o))).replace(/_PAGES_/g, a.call(e, s ? 1 : Math.ceil(i / o))).replace(/_ENTRIES_/g, e.api.i18n("entries", "", n)).replace(/_ENTRIES-MAX_/g, e.api.i18n("entries", "", l)).replace(/_ENTRIES-TOTAL_/g, e.api.i18n("entries", "", i))
            }
            var et = [],
                n = Array.prototype;
            U = function(e, t) {
                if (!(this instanceof U)) return new U(e, t);

                function n(e) {
                    e = e, t = $.settings, a = f(t, "nTable");
                    var n, t, a, r = e ? e.nTable && e.oFeatures ? [e] : e.nodeName && "table" === e.nodeName.toLowerCase() ? -1 !== (r = a.indexOf(e)) ? [t[r]] : null : e && "function" == typeof e.settings ? e.settings().toArray() : ("string" == typeof e ? n = B(e).get() : e instanceof B && (n = e.get()), n ? t.filter(function(e, t) {
                        return n.includes(a[t])
                    }) : void 0) : [];
                    r && o.push.apply(o, r)
                }
                var o = [];
                if (Array.isArray(e))
                    for (var a = 0, r = e.length; a < r; a++) n(e[a]);
                else n(e);
                this.context = 1 < o.length ? x(o) : o, t && this.push.apply(this, t), this.selector = {
                    rows: null,
                    cols: null,
                    opts: null
                }, U.extend(this, this, et)
            }, $.Api = U, B.extend(U.prototype, {
                any: function() {
                    return 0 !== this.count()
                },
                context: [],
                count: function() {
                    return this.flatten().length
                },
                each: function(e) {
                    for (var t = 0, n = this.length; t < n; t++) e.call(this, this[t], t, this);
                    return this
                },
                eq: function(e) {
                    var t = this.context;
                    return t.length > e ? new U(t[e], this[e]) : null
                },
                filter: function(e) {
                    e = n.filter.call(this, e, this);
                    return new U(this.context, e)
                },
                flatten: function() {
                    var e = [];
                    return new U(this.context, e.concat.apply(e, this.toArray()))
                },
                get: function(e) {
                    return this[e]
                },
                join: n.join,
                includes: function(e) {
                    return -1 !== this.indexOf(e)
                },
                indexOf: n.indexOf,
                iterator: function(e, t, n, a) {
                    var r, o, i, l, s, u, c, d, f = [],
                        h = this.context,
                        p = this.selector;
                    for ("string" == typeof e && (a = n, n = t, t = e, e = !1), o = 0, i = h.length; o < i; o++) {
                        var g = new U(h[o]);
                        if ("table" === t) void 0 !== (r = n.call(g, h[o], o)) && f.push(r);
                        else if ("columns" === t || "rows" === t) void 0 !== (r = n.call(g, h[o], this[o], o)) && f.push(r);
                        else if ("every" === t || "column" === t || "column-rows" === t || "row" === t || "cell" === t)
                            for (c = this[o], "column-rows" === t && (u = ct(h[o], p.opts)), l = 0, s = c.length; l < s; l++) d = c[l], void 0 !== (r = "cell" === t ? n.call(g, h[o], d.row, d.column, o, l) : n.call(g, h[o], d, o, l, u)) && f.push(r)
                    }
                    return f.length || a ? ((e = (a = new U(h, e ? f.concat.apply([], f) : f)).selector).rows = p.rows, e.cols = p.cols, e.opts = p.opts, a) : this
                },
                lastIndexOf: n.lastIndexOf,
                length: 0,
                map: function(e) {
                    e = n.map.call(this, e, this);
                    return new U(this.context, e)
                },
                pluck: function(e) {
                    var t = $.util.get(e);
                    return this.map(function(e) {
                        return t(e)
                    })
                },
                pop: n.pop,
                push: n.push,
                reduce: n.reduce,
                reduceRight: n.reduceRight,
                reverse: n.reverse,
                selector: null,
                shift: n.shift,
                slice: function() {
                    return new U(this.context, this)
                },
                sort: n.sort,
                splice: n.splice,
                toArray: function() {
                    return n.slice.call(this)
                },
                to$: function() {
                    return B(this)
                },
                toJQuery: function() {
                    return B(this)
                },
                unique: function() {
                    return new U(this.context, x(this.toArray()))
                },
                unshift: n.unshift
            }), q.__apiStruct = et, U.extend = function(e, t, n) {
                if (n.length && t && (t instanceof U || t.__dt_wrapper))
                    for (var a, r = 0, o = n.length; r < o; r++) t[(a = n[r]).name] = "function" === a.type ? function(t, n, a) {
                        return function() {
                            var e = n.apply(t || this, arguments);
                            return U.extend(e, e, a.methodExt), e
                        }
                    }(e, a.val, a) : "object" === a.type ? {} : a.val, t[a.name].__dt_wrapper = !0, U.extend(e, t[a.name], a.propExt)
            }, U.register = t = function(e, t) {
                if (Array.isArray(e))
                    for (var n = 0, a = e.length; n < a; n++) U.register(e[n], t);
                else
                    for (var r = e.split("."), o = et, i = 0, l = r.length; i < l; i++) {
                        var s, u, c = function(e, t) {
                            for (var n = 0, a = e.length; n < a; n++)
                                if (e[n].name === t) return e[n];
                            return null
                        }(o, u = (s = -1 !== r[i].indexOf("()")) ? r[i].replace("()", "") : r[i]);
                        c || o.push(c = {
                            name: u,
                            val: {},
                            methodExt: [],
                            propExt: [],
                            type: "object"
                        }), i === l - 1 ? (c.val = t, c.type = "function" == typeof t ? "function" : B.isPlainObject(t) ? "object" : "other") : o = s ? c.methodExt : c.propExt
                    }
            }, U.registerPlural = e = function(e, t, n) {
                U.register(e, n), U.register(t, function() {
                    var e = n.apply(this, arguments);
                    return e === this ? this : e instanceof U ? e.length ? Array.isArray(e[0]) ? new U(e.context, e[0]) : e[0] : void 0 : e
                })
            };

            function tt(e, t) {
                var n, a;
                return Array.isArray(e) ? (n = [], e.forEach(function(e) {
                    e = tt(e, t);
                    n.push.apply(n, e)
                }), n.filter(function(e) {
                    return e
                })) : "number" == typeof e ? [t[e]] : (a = t.map(function(e) {
                    return e.nTable
                }), B(a).filter(e).map(function() {
                    var e = a.indexOf(this);
                    return t[e]
                }).toArray())
            }

            function nt(r, o, e) {
                var t, n;
                e && (t = new U(r)).one("draw", function() {
                    e(t.ajax.json())
                }), "ssp" == te(r) ? s(r, o) : (w(r, !0), (n = r.jqXHR) && 4 !== n.readyState && n.abort(), Ie(r, {}, function(e) {
                    he(r);
                    for (var t = Ae(r, e), n = 0, a = t.length; n < a; n++) Y(r, t[n]);
                    s(r, o), ke(r), w(r, !1)
                }))
            }

            function at(e, t, n, a, r) {
                for (var o, i, l, s, u = [], c = typeof t, d = 0, f = (t = t && "string" != c && "function" != c && void 0 !== t.length ? t : [t]).length; d < f; d++)
                    for (l = 0, s = (i = t[d] && t[d].split && !t[d].match(/[[(:]/) ? t[d].split(",") : [t[d]]).length; l < s; l++)(o = (o = n("string" == typeof i[l] ? i[l].trim() : i[l])).filter(function(e) {
                        return null != e
                    })) && o.length && (u = u.concat(o));
                var h = C.selector[e];
                if (h.length)
                    for (d = 0, f = h.length; d < f; d++) u = h[d](a, r, u);
                return x(u)
            }

            function rt(e) {
                return (e = e || {}).filter && void 0 === e.search && (e.search = e.filter), B.extend({
                    search: "none",
                    order: "current",
                    page: "all"
                }, e)
            }

            function ot(e) {
                var t = new U(e.context[0]);
                return e.length && t.push(e[0]), t.selector = e.selector, t.length && 1 < t[0].length && t[0].splice(1), t
            }
            t("tables()", function(e) {
                return null != e ? new U(tt(e, this.context)) : this
            }), t("table()", function(e) {
                var e = this.tables(e),
                    t = e.context;
                return t.length ? new U(t[0]) : e
            }), [
                ["nodes", "node", "nTable"],
                ["body", "body", "nTBody"],
                ["header", "header", "nTHead"],
                ["footer", "footer", "nTFoot"]
            ].forEach(function(t) {
                e("tables()." + t[0] + "()", "table()." + t[1] + "()", function() {
                    return this.iterator("table", function(e) {
                        return e[t[2]]
                    }, 1)
                })
            }), [
                ["header", "aoHeader"],
                ["footer", "aoFooter"]
            ].forEach(function(n) {
                t("table()." + n[0] + ".structure()", function(e) {
                    var e = this.columns(e).indexes().flatten(),
                        t = this.context[0];
                    return De(t, t[n[1]], e)
                })
            }), e("tables().containers()", "table().container()", function() {
                return this.iterator("table", function(e) {
                    return e.nTableWrapper
                }, 1)
            }), t("tables().every()", function(n) {
                var a = this;
                return this.iterator("table", function(e, t) {
                    n.call(a.table(t), t)
                })
            }), t("caption()", function(r, o) {
                var e, t = this.context;
                return void 0 === r ? (e = t[0].captionNode) && t.length ? e.innerHTML : null : this.iterator("table", function(e) {
                    var t = B(e.nTable),
                        n = B(e.captionNode),
                        a = B(e.nTableWrapper);
                    n.length || (n = B("<caption/>").html(r), e.captionNode = n[0], o) || (t.prepend(n), o = n.css("caption-side")), n.html(r), o && (n.css("caption-side", o), n[0]._captionSide = o), (a.find("div.dataTables_scroll").length ? (e = "top" === o ? "Head" : "Foot", a.find("div.dataTables_scroll" + e + " table")) : t).prepend(n)
                }, 1)
            }), t("caption.node()", function() {
                var e = this.context;
                return e.length ? e[0].captionNode : null
            }), t("draw()", function(t) {
                return this.iterator("table", function(e) {
                    "page" === t ? S(e) : s(e, !1 === (t = "string" == typeof t ? "full-hold" !== t : t))
                })
            }), t("page()", function(t) {
                return void 0 === t ? this.page.info().page : this.iterator("table", function(e) {
                    Me(e, t)
                })
            }), t("page.info()", function() {
                var e, t, n, a, r;
                if (0 !== this.context.length) return t = (e = this.context[0])._iDisplayStart, n = e.oFeatures.bPaginate ? e._iDisplayLength : -1, a = e.fnRecordsDisplay(), {
                    page: (r = -1 === n) ? 0 : Math.floor(t / n),
                    pages: r ? 1 : Math.ceil(a / n),
                    start: t,
                    end: e.fnDisplayEnd(),
                    length: n,
                    recordsTotal: e.fnRecordsTotal(),
                    recordsDisplay: a,
                    serverSide: "ssp" === te(e)
                }
            }), t("page.len()", function(t) {
                return void 0 === t ? 0 !== this.context.length ? this.context[0]._iDisplayLength : void 0 : this.iterator("table", function(e) {
                    Ee(e, t)
                })
            }), t("ajax.json()", function() {
                var e = this.context;
                if (0 < e.length) return e[0].json
            }), t("ajax.params()", function() {
                var e = this.context;
                if (0 < e.length) return e[0].oAjaxData
            }), t("ajax.reload()", function(t, n) {
                return this.iterator("table", function(e) {
                    nt(e, !1 === n, t)
                })
            }), t("ajax.url()", function(t) {
                var e = this.context;
                return void 0 === t ? 0 === e.length ? void 0 : (e = e[0], B.isPlainObject(e.ajax) ? e.ajax.url : e.ajax) : this.iterator("table", function(e) {
                    B.isPlainObject(e.ajax) ? e.ajax.url = t : e.ajax = t
                })
            }), t("ajax.url().load()", function(t, n) {
                return this.iterator("table", function(e) {
                    nt(e, !1 === n, t)
                })
            });

            function it(o, i, e, t) {
                function l(e, t) {
                    var n;
                    if (Array.isArray(e) || e instanceof B)
                        for (var a = 0, r = e.length; a < r; a++) l(e[a], t);
                    else e.nodeName && "tr" === e.nodeName.toLowerCase() ? (e.setAttribute("data-dt-row", i.idx), s.push(e)) : (n = B("<tr><td></td></tr>").attr("data-dt-row", i.idx).addClass(t), B("td", n).addClass(t).html(e)[0].colSpan = H(o), s.push(n[0]))
                }
                var s = [];
                l(e, t), i._details && i._details.detach(), i._details = B(s), i._detailsShow && i._details.insertAfter(i.nTr)
            }

            function lt(e, t) {
                var n = e.context;
                if (n.length && e.length) {
                    var a = n[0].aoData[e[0]];
                    if (a._details) {
                        (a._detailsShow = t) ? (a._details.insertAfter(a.nTr), B(a.nTr).addClass("dt-hasChild")) : (a._details.detach(), B(a.nTr).removeClass("dt-hasChild")), ee(n[0], null, "childRow", [t, e.row(e[0])]);
                        var i = n[0],
                            r = new U(i),
                            a = ".dt.DT_details",
                            t = "draw" + a,
                            e = "column-sizing" + a,
                            a = "destroy" + a,
                            l = i.aoData;
                        if (r.off(t + " " + e + " " + a), f(l, "_details").length > 0) {
                            r.on(t, function(e, t) {
                                if (i !== t) return;
                                r.rows({
                                    page: "current"
                                }).eq(0).each(function(e) {
                                    var t = l[e];
                                    if (t._detailsShow) t._details.insertAfter(t.nTr)
                                })
                            });
                            r.on(e, function(e, t) {
                                if (i !== t) return;
                                var n, a = H(t);
                                for (var r = 0, o = l.length; r < o; r++) {
                                    n = l[r];
                                    if (n && n._details) n._details.each(function() {
                                        var e = B(this).children("td");
                                        if (e.length == 1) e.attr("colspan", a)
                                    })
                                }
                            });
                            r.on(a, function(e, t) {
                                if (i !== t) return;
                                for (var n = 0, a = l.length; n < a; n++)
                                    if (l[n] && l[n]._details) ht(r, n)
                            })
                        }
                        ft(n)
                    }
                }
            }

            function st(e, t, n, a, r, o) {
                for (var i = [], l = 0, s = r.length; l < s; l++) i.push(G(e, r[l], t, o));
                return i
            }

            function ut(t, n) {
                return function(e) {
                    return y(e) || "string" != typeof e || (e = e.replace(d, " "), t && (e = I(e)), n && (e = R(e, !1))), e
                }
            }
            var ct = function(e, t) {
                    var n, a = [],
                        r = e.aiDisplay,
                        o = e.aiDisplayMaster,
                        i = t.search,
                        l = t.order,
                        t = t.page;
                    if ("ssp" == te(e)) return "removed" === i ? [] : h(0, o.length);
                    if ("current" == t)
                        for (u = e._iDisplayStart, c = e.fnDisplayEnd(); u < c; u++) a.push(r[u]);
                    else if ("current" == l || "applied" == l) {
                        if ("none" == i) a = o.slice();
                        else if ("applied" == i) a = r.slice();
                        else if ("removed" == i) {
                            for (var s = {}, u = 0, c = r.length; u < c; u++) s[r[u]] = null;
                            o.forEach(function(e) {
                                Object.prototype.hasOwnProperty.call(s, e) || a.push(e)
                            })
                        }
                    } else if ("index" == l || "original" == l)
                        for (u = 0, c = e.aoData.length; u < c; u++) e.aoData[u] && ("none" == i || -1 === (n = r.indexOf(u)) && "removed" == i || 0 <= n && "applied" == i) && a.push(u);
                    else if ("number" == typeof l) {
                        var d = Ue(e, l, "asc");
                        if ("none" === i) a = d;
                        else
                            for (u = 0; u < d.length; u++)(-1 === (n = r.indexOf(d[u])) && "removed" == i || 0 <= n && "applied" == i) && a.push(d[u])
                    }
                    return a
                },
                dt = (t("rows()", function(a, l) {
                    void 0 === a ? a = "" : B.isPlainObject(a) && (l = a, a = ""), l = rt(l);
                    var e = this.iterator("table", function(e) {
                        return t = at("row", t = a, function(n) {
                            var e = g(n),
                                a = r.aoData;
                            if (null !== e && !o) return [e];
                            if (i = i || ct(r, o), null !== e && -1 !== i.indexOf(e)) return [e];
                            if (null == n || "" === n) return i;
                            if ("function" == typeof n) return i.map(function(e) {
                                var t = a[e];
                                return n(e, t._aData, t.nTr) ? e : null
                            });
                            if (n.nodeName) return e = n._DT_RowIndex, t = n._DT_CellIndex, void 0 !== e ? a[e] && a[e].nTr === n ? [e] : [] : t ? a[t.row] && a[t.row].nTr === n.parentNode ? [t.row] : [] : (e = B(n).closest("*[data-dt-row]")).length ? [e.data("dt-row")] : [];
                            if ("string" == typeof n && "#" === n.charAt(0)) {
                                var t = r.aIds[n.replace(/^#/, "")];
                                if (void 0 !== t) return [t.idx]
                            }
                            e = b(v(r.aoData, i, "nTr"));
                            return B(e).filter(n).map(function() {
                                return this._DT_RowIndex
                            }).toArray()
                        }, r = e, o = l), "current" !== o.order && "applied" !== o.order || (n = r.aiDisplayMaster, t.sort(function(e, t) {
                            return n.indexOf(e) - n.indexOf(t)
                        })), t;
                        var r, t, o, i, n
                    }, 1);
                    return e.selector.rows = a, e.selector.opts = l, e
                }), t("rows().nodes()", function() {
                    return this.iterator("row", function(e, t) {
                        return e.aoData[t].nTr || void 0
                    }, 1)
                }), t("rows().data()", function() {
                    return this.iterator(!0, "rows", function(e, t) {
                        return v(e.aoData, t, "_aData")
                    }, 1)
                }), e("rows().cache()", "row().cache()", function(n) {
                    return this.iterator("row", function(e, t) {
                        e = e.aoData[t];
                        return "search" === n ? e._aFilterData : e._aSortData
                    }, 1)
                }), e("rows().invalidate()", "row().invalidate()", function(n) {
                    return this.iterator("row", function(e, t) {
                        pe(e, t, n)
                    })
                }), e("rows().indexes()", "row().index()", function() {
                    return this.iterator("row", function(e, t) {
                        return t
                    }, 1)
                }), e("rows().ids()", "row().id()", function(e) {
                    for (var t = [], n = this.context, a = 0, r = n.length; a < r; a++)
                        for (var o = 0, i = this[a].length; o < i; o++) {
                            var l = n[a].rowIdFn(n[a].aoData[this[a][o]]._aData);
                            t.push((!0 === e ? "#" : "") + l)
                        }
                    return new U(n, t)
                }), e("rows().remove()", "row().remove()", function() {
                    return this.iterator("row", function(e, t) {
                        var n = e.aoData,
                            a = n[t],
                            r = e.aiDisplayMaster.indexOf(t),
                            r = (-1 !== r && e.aiDisplayMaster.splice(r, 1), -1 !== (r = e.aiDisplay.indexOf(t)) && e.aiDisplay.splice(r, 1), 0 < e._iRecordsDisplay && e._iRecordsDisplay--, Ze(e), e.rowIdFn(a._aData));
                        void 0 !== r && delete e.aIds[r], n[t] = null
                    }), this
                }), t("rows.add()", function(o) {
                    var e = this.iterator("table", function(e) {
                            for (var t, n = [], a = 0, r = o.length; a < r; a++)(t = o[a]).nodeName && "TR" === t.nodeName.toUpperCase() ? n.push(se(e, t)[0]) : n.push(Y(e, t));
                            return n
                        }, 1),
                        t = this.rows(-1);
                    return t.pop(), t.push.apply(t, e), t
                }), t("row()", function(e, t) {
                    return ot(this.rows(e, t))
                }), t("row().data()", function(e) {
                    var t, n = this.context;
                    return void 0 === e ? n.length && this.length && this[0].length ? n[0].aoData[this[0]]._aData : void 0 : ((t = n[0].aoData[this[0]])._aData = e, Array.isArray(e) && t.nTr && t.nTr.id && m(n[0].rowId)(e, t.nTr.id), pe(n[0], this[0], "data"), this)
                }), t("row().node()", function() {
                    var e = this.context;
                    return e.length && this.length && this[0].length && e[0].aoData[this[0]].nTr || null
                }), t("row.add()", function(t) {
                    t instanceof B && t.length && (t = t[0]);
                    var e = this.iterator("table", function(e) {
                        return t.nodeName && "TR" === t.nodeName.toUpperCase() ? se(e, t)[0] : Y(e, t)
                    });
                    return this.row(e[0])
                }), B(_).on("plugin-init.dt", function(e, t) {
                    var a = new U(t);
                    a.on("stateSaveParams.DT", function(e, t, n) {
                        for (var a = t.rowIdFn, r = t.aiDisplayMaster, o = [], i = 0; i < r.length; i++) {
                            var l = r[i],
                                l = t.aoData[l];
                            l._detailsShow && o.push("#" + a(l._aData))
                        }
                        n.childRows = o
                    }), a.on("stateLoaded.DT", function(e, t, n) {
                        dt(a, n)
                    }), dt(a, a.state.loaded())
                }), function(e, t) {
                    t && t.childRows && e.rows(t.childRows.map(function(e) {
                        return e.replace(/:/g, "\\:")
                    })).every(function() {
                        ee(e.settings()[0], null, "requestChild", [this])
                    })
                }),
                ft = $.util.throttle(function(e) {
                    ze(e[0])
                }, 500),
                ht = function(e, t) {
                    var n = e.context;
                    n.length && (t = n[0].aoData[void 0 !== t ? t : e[0]]) && t._details && (t._details.remove(), t._detailsShow = void 0, t._details = void 0, B(t.nTr).removeClass("dt-hasChild"), ft(n))
                },
                pt = "row().child",
                gt = pt + "()",
                mt = (t(gt, function(e, t) {
                    var n = this.context;
                    return void 0 === e ? n.length && this.length && n[0].aoData[this[0]] ? n[0].aoData[this[0]]._details : void 0 : (!0 === e ? this.child.show() : !1 === e ? ht(this) : n.length && this.length && it(n[0], n[0].aoData[this[0]], e, t), this)
                }), t([pt + ".show()", gt + ".show()"], function() {
                    return lt(this, !0), this
                }), t([pt + ".hide()", gt + ".hide()"], function() {
                    return lt(this, !1), this
                }), t([pt + ".remove()", gt + ".remove()"], function() {
                    return ht(this), this
                }), t(pt + ".isShown()", function() {
                    var e = this.context;
                    return e.length && this.length && e[0].aoData[this[0]]._detailsShow || !1
                }), /^([^:]+):(name|title|visIdx|visible)$/),
                gt = (t("columns()", function(n, a) {
                    void 0 === n ? n = "" : B.isPlainObject(n) && (a = n, n = ""), a = rt(a);
                    var e = this.iterator("table", function(e) {
                        return t = n, l = a, s = (i = e).aoColumns, u = f(s, "sName"), c = f(s, "sTitle"), e = $.util.get("[].[].cell")(i.aoHeader), d = x(O([], e)), at("column", t, function(n) {
                            var a, e = g(n);
                            if ("" === n) return h(s.length);
                            if (null !== e) return [0 <= e ? e : s.length + e];
                            if ("function" == typeof n) return a = ct(i, l), s.map(function(e, t) {
                                return n(t, st(i, t, 0, 0, a)) ? t : null
                            });
                            var r = "string" == typeof n ? n.match(mt) : "";
                            if (r) switch (r[2]) {
                                case "visIdx":
                                case "visible":
                                    var t, o = parseInt(r[1], 10);
                                    return o < 0 ? [(t = s.map(function(e, t) {
                                        return e.bVisible ? t : null
                                    }))[t.length + o]] : [M(i, o)];
                                case "name":
                                    return u.map(function(e, t) {
                                        return e === r[1] ? t : null
                                    });
                                case "title":
                                    return c.map(function(e, t) {
                                        return e === r[1] ? t : null
                                    });
                                default:
                                    return []
                            }
                            return n.nodeName && n._DT_CellIndex ? [n._DT_CellIndex.column] : (e = B(d).filter(n).map(function() {
                                return le(this)
                            }).toArray()).length || !n.nodeName ? e : (e = B(n).closest("*[data-dt-column]")).length ? [e.data("dt-column")] : []
                        }, i, l);
                        var i, t, l, s, u, c, d
                    }, 1);
                    return e.selector.cols = n, e.selector.opts = a, e
                }), e("columns().header()", "column().header()", function(a) {
                    return this.iterator("column", function(e, t) {
                        var n = e.aoHeader;
                        return n[void 0 !== a ? a : e.bSortCellsTop ? 0 : n.length - 1][t].cell
                    }, 1)
                }), e("columns().footer()", "column().footer()", function(n) {
                    return this.iterator("column", function(e, t) {
                        return e.aoFooter.length ? e.aoFooter[void 0 !== n ? n : 0][t].cell : null
                    }, 1)
                }), e("columns().data()", "column().data()", function() {
                    return this.iterator("column-rows", st, 1)
                }), e("columns().render()", "column().render()", function(o) {
                    return this.iterator("column-rows", function(e, t, n, a, r) {
                        return st(e, t, 0, 0, r, o)
                    }, 1)
                }), e("columns().dataSrc()", "column().dataSrc()", function() {
                    return this.iterator("column", function(e, t) {
                        return e.aoColumns[t].mData
                    }, 1)
                }), e("columns().cache()", "column().cache()", function(o) {
                    return this.iterator("column-rows", function(e, t, n, a, r) {
                        return v(e.aoData, r, "search" === o ? "_aFilterData" : "_aSortData", t)
                    }, 1)
                }), e("columns().init()", "column().init()", function() {
                    return this.iterator("column", function(e, t) {
                        return e.aoColumns[t]
                    }, 1)
                }), e("columns().nodes()", "column().nodes()", function() {
                    return this.iterator("column-rows", function(e, t, n, a, r) {
                        return v(e.aoData, r, "anCells", t)
                    }, 1)
                }), e("columns().titles()", "column().title()", function(n, a) {
                    return this.iterator("column", function(e, t) {
                        "number" == typeof n && (a = n, n = void 0);
                        t = B("span.dt-column-title", this.column(t).header(a));
                        return void 0 !== n ? (t.html(n), this) : t.html()
                    }, 1)
                }), e("columns().types()", "column().type()", function() {
                    return this.iterator("column", function(e, t) {
                        t = e.aoColumns[t].sType;
                        return t || X(e), t
                    }, 1)
                }), e("columns().visible()", "column().visible()", function(n, a) {
                    var t = this,
                        r = [],
                        e = this.iterator("column", function(e, t) {
                            if (void 0 === n) return e.aoColumns[t].bVisible;
                            ! function(e, t, n) {
                                var a, r, o = e.aoColumns,
                                    i = o[t],
                                    l = e.aoData;
                                if (void 0 === n) return i.bVisible;
                                if (i.bVisible === n) return !1;
                                if (n)
                                    for (var s = f(o, "bVisible").indexOf(!0, t + 1), u = 0, c = l.length; u < c; u++) l[u] && (r = l[u].nTr, a = l[u].anCells, r) && r.insertBefore(a[t], a[s] || null);
                                else B(f(e.aoData, "anCells", t)).detach();
                                return i.bVisible = n, Xe(e), !0
                            }(e, t, n) || r.push(t)
                        });
                    return void 0 !== n && this.iterator("table", function(e) {
                        xe(e, e.aoHeader), xe(e, e.aoFooter), e.aiDisplay.length || B(e.nTBody).find("td[colspan]").attr("colspan", H(e)), ze(e), t.iterator("column", function(e, t) {
                            r.includes(t) && ee(e, null, "column-visibility", [e, t, n, a])
                        }), r.length && (void 0 === a || a) && t.columns.adjust()
                    }), e
                }), e("columns().widths()", "column().width()", function() {
                    var e = this.columns(":visible").count(),
                        e = B("<tr>").html("<td>" + Array(e).join("</td><td>") + "</td>"),
                        n = (B(this.table().body()).append(e), e.children().map(function() {
                            return B(this).outerWidth()
                        }));
                    return e.remove(), this.iterator("column", function(e, t) {
                        e = T(e, t);
                        return null !== e ? n[e] : 0
                    }, 1)
                }), e("columns().indexes()", "column().index()", function(n) {
                    return this.iterator("column", function(e, t) {
                        return "visible" === n ? T(e, t) : t
                    }, 1)
                }), t("columns.adjust()", function() {
                    return this.iterator("table", function(e) {
                        E(e)
                    }, 1)
                }), t("column.index()", function(e, t) {
                    var n;
                    if (0 !== this.context.length) return n = this.context[0], "fromVisible" === e || "toData" === e ? M(n, t) : "fromData" === e || "toVisible" === e ? T(n, t) : void 0
                }), t("column()", function(e, t) {
                    return ot(this.columns(e, t))
                }), t("cells()", function(g, e, m) {
                    var a, r, o, i, l, s, t;
                    return B.isPlainObject(g) && (void 0 === g.row ? (m = g, g = null) : (m = e, e = null)), B.isPlainObject(e) && (m = e, e = null), null == e ? this.iterator("table", function(e) {
                        return a = e, e = g, t = rt(m), d = a.aoData, f = ct(a, t), n = b(v(d, f, "anCells")), h = B(O([], n)), p = a.aoColumns.length, at("cell", e, function(e) {
                            var t, n = "function" == typeof e;
                            if (null == e || n) {
                                for (o = [], i = 0, l = f.length; i < l; i++)
                                    for (r = f[i], s = 0; s < p; s++) u = {
                                        row: r,
                                        column: s
                                    }, (!n || (c = d[r], e(u, G(a, r, s), c.anCells ? c.anCells[s] : null))) && o.push(u);
                                return o
                            }
                            return B.isPlainObject(e) ? void 0 !== e.column && void 0 !== e.row && -1 !== f.indexOf(e.row) ? [e] : [] : (t = h.filter(e).map(function(e, t) {
                                return {
                                    row: t._DT_CellIndex.row,
                                    column: t._DT_CellIndex.column
                                }
                            }).toArray()).length || !e.nodeName ? t : (c = B(e).closest("*[data-dt-row]")).length ? [{
                                row: c.data("dt-row"),
                                column: c.data("dt-column")
                            }] : []
                        }, a, t);
                        var a, t, r, o, i, l, s, u, c, d, f, n, h, p
                    }) : (t = m ? {
                        page: m.page,
                        order: m.order,
                        search: m.search
                    } : {}, a = this.columns(e, t), r = this.rows(g, t), t = this.iterator("table", function(e, t) {
                        var n = [];
                        for (o = 0, i = r[t].length; o < i; o++)
                            for (l = 0, s = a[t].length; l < s; l++) n.push({
                                row: r[t][o],
                                column: a[t][l]
                            });
                        return n
                    }, 1), t = m && m.selected ? this.cells(t, m) : t, B.extend(t.selector, {
                        cols: e,
                        rows: g,
                        opts: m
                    }), t)
                }), e("cells().nodes()", "cell().node()", function() {
                    return this.iterator("cell", function(e, t, n) {
                        e = e.aoData[t];
                        return e && e.anCells ? e.anCells[n] : void 0
                    }, 1)
                }), t("cells().data()", function() {
                    return this.iterator("cell", function(e, t, n) {
                        return G(e, t, n)
                    }, 1)
                }), e("cells().cache()", "cell().cache()", function(a) {
                    return a = "search" === a ? "_aFilterData" : "_aSortData", this.iterator("cell", function(e, t, n) {
                        return e.aoData[t][a][n]
                    }, 1)
                }), e("cells().render()", "cell().render()", function(a) {
                    return this.iterator("cell", function(e, t, n) {
                        return G(e, t, n, a)
                    }, 1)
                }), e("cells().indexes()", "cell().index()", function() {
                    return this.iterator("cell", function(e, t, n) {
                        return {
                            row: t,
                            column: n,
                            columnVisible: T(e, n)
                        }
                    }, 1)
                }), e("cells().invalidate()", "cell().invalidate()", function(a) {
                    return this.iterator("cell", function(e, t, n) {
                        pe(e, t, a, n)
                    })
                }), t("cell()", function(e, t, n) {
                    return ot(this.cells(e, t, n))
                }), t("cell().data()", function(e) {
                    var t, n, a, r, o, i = this.context,
                        l = this[0];
                    return void 0 === e ? i.length && l.length ? G(i[0], l[0].row, l[0].column) : void 0 : (t = i[0], n = l[0].row, a = l[0].column, r = t.aoColumns[a], o = t.aoData[n]._aData, r.fnSetData(o, e, {
                        settings: t,
                        row: n,
                        col: a
                    }), pe(i[0], l[0].row, "data", l[0].column), this)
                }), t("order()", function(t, e) {
                    var n = this.context,
                        a = Array.prototype.slice.call(arguments);
                    return void 0 === t ? 0 !== n.length ? n[0].aaSorting : void 0 : ("number" == typeof t ? t = [
                        [t, e]
                    ] : 1 < a.length && (t = a), this.iterator("table", function(e) {
                        e.aaSorting = Array.isArray(t) ? t.slice() : t
                    }))
                }), t("order.listener()", function(t, n, a) {
                    return this.iterator("table", function(e) {
                        Ve(e, t, {}, n, a)
                    })
                }), t("order.fixed()", function(t) {
                    var e;
                    return t ? this.iterator("table", function(e) {
                        e.aaSortingFixed = B.extend(!0, {}, t)
                    }) : (e = (e = this.context).length ? e[0].aaSortingFixed : void 0, Array.isArray(e) ? {
                        pre: e
                    } : e)
                }), t(["columns().order()", "column().order()"], function(n) {
                    var a = this;
                    return n ? this.iterator("table", function(e, t) {
                        e.aaSorting = a[t].map(function(e) {
                            return [e, n]
                        })
                    }) : this.iterator("column", function(e, t) {
                        for (var n = qe(e), a = 0, r = n.length; a < r; a++)
                            if (n[a].col === t) return n[a].dir;
                        return null
                    }, 1)
                }), e("columns().orderable()", "column().orderable()", function(n) {
                    return this.iterator("column", function(e, t) {
                        e = e.aoColumns[t];
                        return n ? e.asSorting : e.bSortable
                    }, 1)
                }), t("processing()", function(t) {
                    return this.iterator("table", function(e) {
                        w(e, t)
                    })
                }), t("search()", function(t, n, a, r) {
                    var e = this.context;
                    return void 0 === t ? 0 !== e.length ? e[0].oPreviousSearch.search : void 0 : this.iterator("table", function(e) {
                        e.oFeatures.bFilter && Le(e, "object" == typeof n ? B.extend(e.oPreviousSearch, n, {
                            search: t
                        }) : B.extend(e.oPreviousSearch, {
                            search: t,
                            regex: null !== n && n,
                            smart: null === a || a,
                            caseInsensitive: null === r || r
                        }))
                    })
                }), t("search.fixed()", function(t, n) {
                    var e = this.iterator(!0, "table", function(e) {
                        e = e.searchFixed;
                        return t ? void 0 === n ? e[t] : (null === n ? delete e[t] : e[t] = n, this) : Object.keys(e)
                    });
                    return void 0 !== t && void 0 === n ? e[0] : e
                }), e("columns().search()", "column().search()", function(a, r, o, i) {
                    return this.iterator("column", function(e, t) {
                        var n = e.aoPreSearchCols;
                        if (void 0 === a) return n[t].search;
                        e.oFeatures.bFilter && ("object" == typeof r ? B.extend(n[t], r, {
                            search: a
                        }) : B.extend(n[t], {
                            search: a,
                            regex: null !== r && r,
                            smart: null === o || o,
                            caseInsensitive: null === i || i
                        }), Le(e, e.oPreviousSearch))
                    })
                }), t(["columns().search.fixed()", "column().search.fixed()"], function(n, a) {
                    var e = this.iterator(!0, "column", function(e, t) {
                        e = e.aoColumns[t].searchFixed;
                        return n ? void 0 === a ? e[n] : (null === a ? delete e[n] : e[n] = a, this) : Object.keys(e)
                    });
                    return void 0 !== n && void 0 === a ? e[0] : e
                }), t("state()", function(e, t) {
                    var n;
                    return e ? (n = B.extend(!0, {}, e), this.iterator("table", function(e) {
                        !1 !== t && (n.time = +new Date + 100), Ye(e, n, function() {})
                    })) : this.context.length ? this.context[0].oSavedState : null
                }), t("state.clear()", function() {
                    return this.iterator("table", function(e) {
                        e.fnStateSaveCallback.call(e.oInstance, e, {})
                    })
                }), t("state.loaded()", function() {
                    return this.context.length ? this.context[0].oLoadedState : null
                }), t("state.save()", function() {
                    return this.iterator("table", function(e) {
                        ze(e)
                    })
                }), $.use = function(e, t) {
                    "lib" === t || e.fn ? B = e : "win" == t || e.document ? _ = (q = e).document : "datetime" !== t && "DateTime" !== e.type || ($.DateTime = e)
                }, $.factory = function(e, t) {
                    var n = !1;
                    return e && e.document && (_ = (q = e).document), t && t.fn && t.fn.jquery && (B = t, n = !0), n
                }, $.versionCheck = function(e, t) {
                    for (var n, a, r = (t || $.version).split("."), o = e.split("."), i = 0, l = o.length; i < l; i++)
                        if ((n = parseInt(r[i], 10) || 0) !== (a = parseInt(o[i], 10) || 0)) return a < n;
                    return !0
                }, $.isDataTable = function(e) {
                    var r = B(e).get(0),
                        o = !1;
                    return e instanceof $.Api || (B.each($.settings, function(e, t) {
                        var n = t.nScrollHead ? B("table", t.nScrollHead)[0] : null,
                            a = t.nScrollFoot ? B("table", t.nScrollFoot)[0] : null;
                        t.nTable !== r && n !== r && a !== r || (o = !0)
                    }), o)
                }, $.tables = function(t) {
                    var e = !1,
                        n = (B.isPlainObject(t) && (e = t.api, t = t.visible), $.settings.filter(function(e) {
                            return !(t && !B(e.nTable).is(":visible"))
                        }).map(function(e) {
                            return e.nTable
                        }));
                    return e ? new U(n) : n
                }, $.camelToHungarian = z, t("$()", function(e, t) {
                    t = this.rows(t).nodes(), t = B(t);
                    return B([].concat(t.filter(e).toArray(), t.find(e).toArray()))
                }), B.each(["on", "one", "off"], function(e, n) {
                    t(n + "()", function() {
                        var e = Array.prototype.slice.call(arguments),
                            t = (e[0] = e[0].split(/\s/).map(function(e) {
                                return e.match(/\.dt\b/) ? e : e + ".dt"
                            }).join(" "), B(this.tables().nodes()));
                        return t[n].apply(t, e), this
                    })
                }), t("clear()", function() {
                    return this.iterator("table", function(e) {
                        he(e)
                    })
                }), t("error()", function(t) {
                    return this.iterator("table", function(e) {
                        Z(e, 0, t)
                    })
                }), t("settings()", function() {
                    return new U(this.context, this.context)
                }), t("init()", function() {
                    var e = this.context;
                    return e.length ? e[0].oInit : null
                }), t("data()", function() {
                    return this.iterator("table", function(e) {
                        return f(e.aoData, "_aData")
                    }).flatten()
                }), t("trigger()", function(t, n, a) {
                    return this.iterator("table", function(e) {
                        return ee(e, null, t, n, a)
                    }).flatten()
                }), t("ready()", function(e) {
                    var t = this.context;
                    return e ? this.tables().every(function() {
                        this.context[0]._bInitComplete ? e.call(this) : this.on("init", function() {
                            e.call(this)
                        })
                    }) : t.length ? t[0]._bInitComplete || !1 : null
                }), t("destroy()", function(c) {
                    return c = c || !1, this.iterator("table", function(e) {
                        var t = e.oClasses,
                            n = e.nTable,
                            a = e.nTBody,
                            r = e.nTHead,
                            o = e.nTFoot,
                            i = B(n),
                            a = B(a),
                            l = B(e.nTableWrapper),
                            s = e.aoData.map(function(e) {
                                return e ? e.nTr : null
                            }),
                            u = t.order,
                            o = (e.bDestroying = !0, ee(e, "aoDestroyCallback", "destroy", [e], !0), c || new U(e).columns().visible(!0), l.off(".DT").find(":not(tbody *)").off(".DT"), B(q).off(".DT-" + e.sInstance), n != r.parentNode && (i.children("thead").detach(), i.append(r)), o && n != o.parentNode && (i.children("tfoot").detach(), i.append(o)), e.colgroup.remove(), e.aaSorting = [], e.aaSortingFixed = [], $e(e), B("th, td", r).removeClass(u.canAsc + " " + u.canDesc + " " + u.isAsc + " " + u.isDesc).css("width", ""), a.children().detach(), a.append(s), e.nTableWrapper.parentNode),
                            r = e.nTableWrapper.nextSibling,
                            u = c ? "remove" : "detach",
                            a = (i[u](), l[u](), !c && o && (o.insertBefore(n, r), i.css("width", e.sDestroyWidth).removeClass(t.table)), $.settings.indexOf(e)); - 1 !== a && $.settings.splice(a, 1)
                    })
                }), B.each(["column", "row", "cell"], function(e, s) {
                    t(s + "s().every()", function(a) {
                        var r, o = this.selector.opts,
                            i = this,
                            l = 0;
                        return this.iterator("every", function(e, t, n) {
                            r = i[s](t, o), "cell" === s ? a.call(r, r[0][0].row, r[0][0].column, n, l) : a.call(r, t, n, l), l++
                        })
                    })
                }), t("i18n()", function(e, t, n) {
                    var a = this.context[0],
                        e = J(e)(a.oLanguage);
                    return "string" == typeof(e = B.isPlainObject(e = void 0 === e ? t : e) ? void 0 !== n && void 0 !== e[n] ? e[n] : e._ : e) ? e.replace("%d", n) : e
                }), $.version = "2.0.2", $.settings = [], $.models = {}, $.models.oSearch = {
                    caseInsensitive: !0,
                    search: "",
                    regex: !1,
                    smart: !0,
                    return: !1
                }, $.models.oRow = {
                    nTr: null,
                    anCells: null,
                    _aData: [],
                    _aSortData: null,
                    _aFilterData: null,
                    _sFilterRow: null,
                    src: null,
                    idx: -1,
                    displayData: null
                }, $.models.oColumn = {
                    idx: null,
                    aDataSort: null,
                    asSorting: null,
                    bSearchable: null,
                    bSortable: null,
                    bVisible: null,
                    _sManualType: null,
                    _bAttrSrc: !1,
                    fnCreatedCell: null,
                    fnGetData: null,
                    fnSetData: null,
                    mData: null,
                    mRender: null,
                    sClass: null,
                    sContentPadding: null,
                    sDefaultContent: null,
                    sName: null,
                    sSortDataType: "std",
                    sSortingClass: null,
                    sTitle: null,
                    sType: null,
                    sWidth: null,
                    sWidthOrig: null,
                    maxLenString: null,
                    searchFixed: null
                }, $.defaults = {
                    aaData: null,
                    aaSorting: [
                        [0, "asc"]
                    ],
                    aaSortingFixed: [],
                    ajax: null,
                    aLengthMenu: [10, 25, 50, 100],
                    aoColumns: null,
                    aoColumnDefs: null,
                    aoSearchCols: [],
                    bAutoWidth: !0,
                    bDeferRender: !0,
                    bDestroy: !1,
                    bFilter: !0,
                    bInfo: !0,
                    bLengthChange: !0,
                    bPaginate: !0,
                    bProcessing: !1,
                    bRetrieve: !1,
                    bScrollCollapse: !1,
                    bServerSide: !1,
                    bSort: !0,
                    bSortMulti: !0,
                    bSortCellsTop: null,
                    bSortClasses: !0,
                    bStateSave: !1,
                    fnCreatedRow: null,
                    fnDrawCallback: null,
                    fnFooterCallback: null,
                    fnFormatNumber: function(e) {
                        return e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands)
                    },
                    fnHeaderCallback: null,
                    fnInfoCallback: null,
                    fnInitComplete: null,
                    fnPreDrawCallback: null,
                    fnRowCallback: null,
                    fnStateLoadCallback: function(e) {
                        try {
                            return JSON.parse((-1 === e.iStateDuration ? sessionStorage : localStorage).getItem("DataTables_" + e.sInstance + "_" + location.pathname))
                        } catch (e) {
                            return {}
                        }
                    },
                    fnStateLoadParams: null,
                    fnStateLoaded: null,
                    fnStateSaveCallback: function(e, t) {
                        try {
                            (-1 === e.iStateDuration ? sessionStorage : localStorage).setItem("DataTables_" + e.sInstance + "_" + location.pathname, JSON.stringify(t))
                        } catch (e) {}
                    },
                    fnStateSaveParams: null,
                    iStateDuration: 7200,
                    iDisplayLength: 10,
                    iDisplayStart: 0,
                    iTabIndex: 0,
                    oClasses: {},
                    oLanguage: {
                        oAria: {
                            orderable: ": Activate to sort",
                            orderableReverse: ": Activate to invert sorting",
                            orderableRemove: ": Activate to remove sorting",
                            paginate: {
                                first: "First",
                                last: "Last",
                                next: "Next",
                                previous: "Previous"
                            }
                        },
                        oPaginate: {
                            sFirst: "",
                            sLast: "",
                            sNext: "",
                            sPrevious: ""
                        },
                        entries: {
                            _: "entries",
                            1: "entry"
                        },
                        sEmptyTable: "No data available in table",
                        sInfo: "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
                        sInfoEmpty: "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
                        sInfoFiltered: "(filtered from _MAX_ total _ENTRIES-MAX_)",
                        sInfoPostFix: "",
                        sDecimal: "",
                        sThousands: ",",
                        sLengthMenu: "_MENU_ _ENTRIES_ per page",
                        sLoadingRecords: "Loading...",
                        sProcessing: "",
                        sSearch: "Search:",
                        sSearchPlaceholder: "",
                        sUrl: "",
                        sZeroRecords: "No matching records found"
                    },
                    oSearch: B.extend({}, $.models.oSearch),
                    layout: {
                        topStart: "pageLength",
                        topEnd: "search",
                        bottomStart: "info",
                        bottomEnd: "paging"
                    },
                    sDom: null,
                    searchDelay: null,
                    sPaginationType: "full_numbers",
                    sScrollX: "",
                    sScrollXInner: "",
                    sScrollY: "",
                    sServerMethod: "GET",
                    renderer: null,
                    rowId: "DT_RowId",
                    caption: null
                }, k($.defaults), $.defaults.column = {
                    aDataSort: null,
                    iDataSort: -1,
                    ariaTitle: "",
                    asSorting: ["asc", "desc", ""],
                    bSearchable: !0,
                    bSortable: !0,
                    bVisible: !0,
                    fnCreatedCell: null,
                    mData: null,
                    mRender: null,
                    sCellType: "td",
                    sClass: "",
                    sContentPadding: "",
                    sDefaultContent: null,
                    sName: "",
                    sSortDataType: "std",
                    sTitle: null,
                    sType: null,
                    sWidth: null
                }, k($.defaults.column), $.models.oSettings = {
                    oFeatures: {
                        bAutoWidth: null,
                        bDeferRender: null,
                        bFilter: null,
                        bInfo: !0,
                        bLengthChange: !0,
                        bPaginate: null,
                        bProcessing: null,
                        bServerSide: null,
                        bSort: null,
                        bSortMulti: null,
                        bSortClasses: null,
                        bStateSave: null
                    },
                    oScroll: {
                        bCollapse: null,
                        iBarWidth: 0,
                        sX: null,
                        sXInner: null,
                        sY: null
                    },
                    oLanguage: {
                        fnInfoCallback: null
                    },
                    oBrowser: {
                        bScrollbarLeft: !1,
                        barWidth: 0
                    },
                    ajax: null,
                    aanFeatures: [],
                    aoData: [],
                    aiDisplay: [],
                    aiDisplayMaster: [],
                    aIds: {},
                    aoColumns: [],
                    aoHeader: [],
                    aoFooter: [],
                    oPreviousSearch: {},
                    searchFixed: {},
                    aoPreSearchCols: [],
                    aaSorting: null,
                    aaSortingFixed: [],
                    sDestroyWidth: 0,
                    aoRowCallback: [],
                    aoHeaderCallback: [],
                    aoFooterCallback: [],
                    aoDrawCallback: [],
                    aoRowCreatedCallback: [],
                    aoPreDrawCallback: [],
                    aoInitComplete: [],
                    aoStateSaveParams: [],
                    aoStateLoadParams: [],
                    aoStateLoaded: [],
                    sTableId: "",
                    nTable: null,
                    nTHead: null,
                    nTFoot: null,
                    nTBody: null,
                    nTableWrapper: null,
                    bInitialised: !1,
                    aoOpenRows: [],
                    sDom: null,
                    searchDelay: null,
                    sPaginationType: "two_button",
                    pagingControls: 0,
                    iStateDuration: 0,
                    aoStateSave: [],
                    aoStateLoad: [],
                    oSavedState: null,
                    oLoadedState: null,
                    bAjaxDataGet: !0,
                    jqXHR: null,
                    json: void 0,
                    oAjaxData: void 0,
                    sServerMethod: null,
                    fnFormatNumber: null,
                    aLengthMenu: null,
                    iDraw: 0,
                    bDrawing: !1,
                    iDrawError: -1,
                    _iDisplayLength: 10,
                    _iDisplayStart: 0,
                    _iRecordsTotal: 0,
                    _iRecordsDisplay: 0,
                    oClasses: {},
                    bFiltered: !1,
                    bSorted: !1,
                    bSortCellsTop: null,
                    oInit: null,
                    aoDestroyCallback: [],
                    fnRecordsTotal: function() {
                        return "ssp" == te(this) ? +this._iRecordsTotal : this.aiDisplayMaster.length
                    },
                    fnRecordsDisplay: function() {
                        return "ssp" == te(this) ? +this._iRecordsDisplay : this.aiDisplay.length
                    },
                    fnDisplayEnd: function() {
                        var e = this._iDisplayLength,
                            t = this._iDisplayStart,
                            n = t + e,
                            a = this.aiDisplay.length,
                            r = this.oFeatures,
                            o = r.bPaginate;
                        return r.bServerSide ? !1 === o || -1 === e ? t + a : Math.min(t + e, this._iRecordsDisplay) : !o || a < n || -1 === e ? a : n
                    },
                    oInstance: null,
                    sInstance: null,
                    iTabIndex: 0,
                    nScrollHead: null,
                    nScrollFoot: null,
                    aLastSort: [],
                    oPlugins: {},
                    rowIdFn: null,
                    rowId: null,
                    caption: "",
                    captionNode: null,
                    colgroup: null
                }, $.ext = C = {
                    buttons: {},
                    classes: {},
                    builder: "ju/dt-2.0.2",
                    errMode: "alert",
                    feature: [],
                    features: {},
                    search: [],
                    selector: {
                        cell: [],
                        column: [],
                        row: []
                    },
                    legacy: {
                        ajax: null
                    },
                    pager: {},
                    renderer: {
                        pageButton: {},
                        header: {}
                    },
                    order: {},
                    type: {
                        className: {},
                        detect: [],
                        render: {},
                        search: {},
                        order: {}
                    },
                    _unique: 0,
                    fnVersionCheck: $.fnVersionCheck,
                    iApiIndex: 0,
                    sVersion: $.version
                }, B.extend(C, {
                    afnFiltering: C.search,
                    aTypes: C.type.detect,
                    ofnSearch: C.type.search,
                    oSort: C.type.order,
                    afnSortData: C.order,
                    aoFeatures: C.feature,
                    oStdClasses: C.classes,
                    oPagination: C.pager
                }), B.extend($.ext.classes, {
                    container: "dt-container",
                    empty: {
                        row: "dt-empty"
                    },
                    info: {
                        container: "dt-info"
                    },
                    length: {
                        container: "dt-length",
                        select: "dt-input"
                    },
                    order: {
                        canAsc: "dt-orderable-asc",
                        canDesc: "dt-orderable-desc",
                        isAsc: "dt-ordering-asc",
                        isDesc: "dt-ordering-desc",
                        none: "dt-orderable-none",
                        position: "sorting_"
                    },
                    processing: {
                        container: "dt-processing"
                    },
                    scrolling: {
                        body: "dt-scroll-body",
                        container: "dt-scroll",
                        footer: {
                            self: "dt-scroll-foot",
                            inner: "dt-scroll-footInner"
                        },
                        header: {
                            self: "dt-scroll-head",
                            inner: "dt-scroll-headInner"
                        }
                    },
                    search: {
                        container: "dt-search",
                        input: "dt-input"
                    },
                    table: "dataTable",
                    tbody: {
                        cell: "",
                        row: ""
                    },
                    thead: {
                        cell: "",
                        row: ""
                    },
                    tfoot: {
                        cell: "",
                        row: ""
                    },
                    paging: {
                        active: "current",
                        button: "dt-paging-button",
                        container: "dt-paging",
                        disabled: "disabled"
                    }
                }), $.ext.pager);
            B.extend(gt, {
                simple: function() {
                    return ["previous", "next"]
                },
                full: function() {
                    return ["first", "previous", "next", "last"]
                },
                numbers: function() {
                    return ["numbers"]
                },
                simple_numbers: function() {
                    return ["previous", "numbers", "next"]
                },
                full_numbers: function() {
                    return ["first", "previous", "numbers", "next", "last"]
                },
                first_last: function() {
                    return ["first", "last"]
                },
                first_last_numbers: function() {
                    return ["first", "numbers", "last"]
                },
                _numbers: At,
                numbers_length: 7
            }), B.extend(!0, $.ext.renderer, {
                pagingButton: {
                    _: function(e, t, n, a, r) {
                        var e = e.oClasses.paging,
                            o = [e.button];
                        return a && o.push(e.active), r && o.push(e.disabled), {
                            display: a = "ellipsis" === t ? B('<span class="ellipsis"></span>').html(n)[0] : B("<button>", {
                                class: o.join(" "),
                                role: "link",
                                type: "button"
                            }).html(n),
                            clicker: a
                        }
                    }
                },
                pagingContainer: {
                    _: function(e, t) {
                        return t
                    }
                }
            });

            function vt(e) {
                return e.replace(/[\W]/g, "_")
            }

            function bt(e, t, n, a, r) {
                return q.moment ? e[t](r) : q.luxon ? e[n](r) : a ? e[a](r) : e
            }
            var yt = !1;

            function Dt(e, t, n) {
                var a;
                if (q.moment) {
                    if (!(a = q.moment.utc(e, t, n, !0)).isValid()) return null
                } else if (q.luxon) {
                    if (!(a = t && "string" == typeof e ? q.luxon.DateTime.fromFormat(e, t) : q.luxon.DateTime.fromISO(e)).isValid) return null;
                    a.setLocale(n)
                } else t ? (yt || alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17"), yt = !0) : a = new Date(e);
                return a
            }

            function xt(s) {
                return function(a, r, o, i) {
                    0 === arguments.length ? (o = "en", a = r = null) : 1 === arguments.length ? (o = "en", r = a, a = null) : 2 === arguments.length && (o = r, r = a, a = null);
                    var l = "datetime" + (r ? "-" + vt(r) : "");
                    return $.ext.type.order[l] || $.type(l, {
                            detect: function(e) {
                                return e === l && l
                            },
                            order: {
                                pre: function(e) {
                                    return e.valueOf()
                                }
                            },
                            className: "dt-right"
                        }),
                        function(e, t) {
                            var n;
                            return null == e && (e = "--now" === i ? (n = new Date, new Date(Date.UTC(n.getFullYear(), n.getMonth(), n.getDate(), n.getHours(), n.getMinutes(), n.getSeconds()))) : ""), "type" === t ? l : "" === e ? "sort" !== t ? "" : Dt("0000-01-01 00:00:00", null, o) : !(null === r || a !== r || "sort" === t || "type" === t || e instanceof Date) || null === (n = Dt(e, a, o)) ? e : "sort" === t ? n : (e = null === r ? bt(n, "toDate", "toJSDate", "")[s]() : bt(n, "format", "toFormat", "toISOString", r), "display" === t ? u(e) : e)
                        }
                }
            }
            var St = ",",
                Tt = ".";
            if (void 0 !== q.Intl) try {
                for (var wt = (new Intl.NumberFormat).formatToParts(100000.1), a = 0; a < wt.length; a++) "group" === wt[a].type ? St = wt[a].value : "decimal" === wt[a].type && (Tt = wt[a].value)
            } catch (e) {}
            $.datetime = function(n, a) {
                var r = "datetime-detect-" + vt(n);
                a = a || "en", $.ext.type.order[r] || $.type(r, {
                    detect: function(e) {
                        var t = Dt(e, n, a);
                        return !("" !== e && !t) && r
                    },
                    order: {
                        pre: function(e) {
                            return Dt(e, n, a) || 0
                        }
                    },
                    className: "dt-right"
                })
            }, $.render = {
                date: xt("toLocaleDateString"),
                datetime: xt("toLocaleString"),
                time: xt("toLocaleTimeString"),
                number: function(r, o, i, l, s) {
                    return null == r && (r = St), null == o && (o = Tt), {
                        display: function(e) {
                            if ("number" != typeof e && "string" != typeof e) return e;
                            if ("" === e || null === e) return e;
                            var t = e < 0 ? "-" : "",
                                n = parseFloat(e),
                                a = Math.abs(n);
                            if (1e11 <= a || a < 1e-4 && 0 !== a) return (a = n.toExponential(i).split(/e\+?/))[0] + " x 10<sup>" + a[1] + "</sup>";
                            if (isNaN(n)) return u(e);
                            n = n.toFixed(i), e = Math.abs(n);
                            a = parseInt(e, 10), n = i ? o + (e - a).toFixed(i).substring(2) : "";
                            return (t = 0 === a && 0 === parseFloat(n) ? "" : t) + (l || "") + a.toString().replace(/\B(?=(\d{3})+(?!\d))/g, r) + n + (s || "")
                        }
                    }
                },
                text: function() {
                    return {
                        display: u,
                        filter: u
                    }
                }
            };
            var i = $.ext.type,
                _t = ($.type = function(a, e, t) {
                    if (!e) return {
                        className: i.className[a],
                        detect: i.detect.find(function(e) {
                            return e.name === a
                        }),
                        order: {
                            pre: i.order[a + "-pre"],
                            asc: i.order[a + "-asc"],
                            desc: i.order[a + "-desc"]
                        },
                        render: i.render[a],
                        search: i.search[a]
                    };

                    function n(e, t) {
                        i[e][a] = t
                    }

                    function r(n) {
                        function e(e, t) {
                            return !0 === (e = n(e, t)) ? a : e
                        }
                        Object.defineProperty(e, "name", {
                            value: a
                        });
                        var t = i.detect.findIndex(function(e) {
                            return e.name === a
                        }); - 1 === t ? i.detect.unshift(e) : i.detect.splice(t, 1, e)
                    }

                    function o(e) {
                        i.order[a + "-pre"] = e.pre, i.order[a + "-asc"] = e.asc, i.order[a + "-desc"] = e.desc
                    }
                    void 0 === t && (t = e, e = null), "className" === e ? n("className", t) : "detect" === e ? r(t) : "order" === e ? o(t) : "render" === e ? n("render", t) : "search" === e ? n("search", t) : e || (t.className && n("className", t.className), void 0 !== t.detect && r(t.detect), t.order && o(t.order), void 0 !== t.render && n("render", t.render), void 0 !== t.search && n("search", t.search))
                }, $.types = function() {
                    return i.detect.map(function(e) {
                        return e.name
                    })
                }, $.type("string", {
                    detect: function() {
                        return "string"
                    },
                    order: {
                        pre: function(e) {
                            return y(e) ? "" : "string" == typeof e ? e.toLowerCase() : e.toString ? e.toString() : ""
                        }
                    },
                    search: ut(!1, !0)
                }), $.type("html", {
                    detect: function(e) {
                        return y(e) || "string" == typeof e && -1 !== e.indexOf("<") ? "html" : null
                    },
                    order: {
                        pre: function(e) {
                            return y(e) ? "" : e.replace ? I(e).trim().toLowerCase() : e + ""
                        }
                    },
                    search: ut(!0, !0)
                }), $.type("date", {
                    className: "dt-type-date",
                    detect: function(e) {
                        var t;
                        return (!e || e instanceof Date || L.test(e)) && (null !== (t = Date.parse(e)) && !isNaN(t) || y(e)) ? "date" : null
                    },
                    order: {
                        pre: function(e) {
                            e = Date.parse(e);
                            return isNaN(e) ? -1 / 0 : e
                        }
                    }
                }), $.type("html-num-fmt", {
                    className: "dt-type-numeric",
                    detect: function(e, t) {
                        t = t.oLanguage.sDecimal;
                        return l(e, t, !0) ? "html-num-fmt" : null
                    },
                    order: {
                        pre: function(e, t) {
                            t = t.oLanguage.sDecimal;
                            return _t(e, t, F, j)
                        }
                    },
                    search: ut(!0, !0)
                }), $.type("html-num", {
                    className: "dt-type-numeric",
                    detect: function(e, t) {
                        t = t.oLanguage.sDecimal;
                        return l(e, t) ? "html-num" : null
                    },
                    order: {
                        pre: function(e, t) {
                            t = t.oLanguage.sDecimal;
                            return _t(e, t, F)
                        }
                    },
                    search: ut(!0, !0)
                }), $.type("num-fmt", {
                    className: "dt-type-numeric",
                    detect: function(e, t) {
                        t = t.oLanguage.sDecimal;
                        return o(e, t, !0) ? "num-fmt" : null
                    },
                    order: {
                        pre: function(e, t) {
                            t = t.oLanguage.sDecimal;
                            return _t(e, t, j)
                        }
                    }
                }), $.type("num", {
                    className: "dt-type-numeric",
                    detect: function(e, t) {
                        t = t.oLanguage.sDecimal;
                        return o(e, t) ? "num" : null
                    },
                    order: {
                        pre: function(e, t) {
                            t = t.oLanguage.sDecimal;
                            return _t(e, t)
                        }
                    }
                }), function(e, t, n, a) {
                    var r;
                    return 0 === e || e && "-" !== e ? "number" == (r = typeof e) || "bigint" == r ? e : +(e = (e = t ? P(e, t) : e).replace && (n && (e = e.replace(n, "")), a) ? e.replace(a, "") : e) : -1 / 0
                });
            B.extend(!0, $.ext.renderer, {
                footer: {
                    _: function(e, t, n) {
                        t.addClass(n.tfoot.cell)
                    }
                },
                header: {
                    _: function(d, f, h) {
                        f.addClass(h.thead.cell), d.oFeatures.bSort || f.addClass(h.order.none);
                        var e = d.bSortCellsTop,
                            t = f.closest("thead").find("tr"),
                            n = f.parent().index();
                        "disable" === f.attr("data-dt-order") || "disable" === f.parent().attr("data-dt-order") || !0 === e && 0 !== n || !1 === e && n !== t.length - 1 || B(d.nTable).on("order.dt.DT", function(e, t, n) {
                            var a, r, o, i, l, s, u, c;
                            d === t && (c = h.order, u = t.api.columns(f), a = d.aoColumns[u.flatten()[0]], r = u.orderable().includes(!0), o = "", i = u.indexes(), s = u.orderable(!0).flatten(), l = n.map(function(e) {
                                return e.col
                            }).join(","), f.removeClass(c.isAsc + " " + c.isDesc).toggleClass(c.none, !r).toggleClass(c.canAsc, r && s.includes("asc")).toggleClass(c.canDesc, r && s.includes("desc")), -1 !== (s = l.indexOf(i.toArray().join(","))) && (u = u.order(), f.addClass(u.includes("asc") ? c.isAsc : "" + u.includes("desc") ? c.isDesc : "")), 0 === s && l.length === i.count() ? (u = n[0], c = a.asSorting, f.attr("aria-sort", "asc" === u.dir ? "ascending" : "descending"), o = c[u.index + 1] ? "Reverse" : "Remove") : f.removeAttr("aria-sort"), f.attr("aria-label", r ? a.ariaTitle + t.api.i18n("oAria.orderable" + o) : a.ariaTitle), r) && (f.find(".dt-column-title").attr("role", "button"), f.attr("tabindex", 0))
                        })
                    }
                },
                layout: {
                    _: function(e, t, n) {
                        var a = B("<div/>").addClass("dt-layout-row").appendTo(t);
                        B.each(n, function(e, t) {
                            e = t.table ? "" : "dt-" + e + " ";
                            t.table && a.addClass("dt-layout-table"), B("<div/>").attr({
                                id: t.id || null,
                                class: "dt-layout-cell " + e + (t.className || "")
                            }).append(t.contents).appendTo(a)
                        })
                    }
                }
            }), $.feature = {}, $.feature.register = function(e, t, n) {
                $.ext.features[e] = t, n && C.feature.push({
                    cFeature: n,
                    fnInit: t
                })
            }, $.feature.register("info", function(e, s) {
                var t, n, u;
                return e.oFeatures.bInfo ? (t = e.oLanguage, n = e.sTableId, u = B("<div/>", {
                    class: e.oClasses.info.container
                }), s = B.extend({
                    callback: t.fnInfoCallback,
                    empty: t.sInfoEmpty,
                    postfix: t.sInfoPostFix,
                    search: t.sInfoFiltered,
                    text: t.sInfo
                }, s), e.aoDrawCallback.push(function(e) {
                    var t = s,
                        n = u,
                        a = e._iDisplayStart + 1,
                        r = e.fnDisplayEnd(),
                        o = e.fnRecordsTotal(),
                        i = e.fnRecordsDisplay(),
                        l = i ? t.text : t.empty;
                    i !== o && (l += " " + t.search), l += t.postfix, l = Ke(e, l), t.callback && (l = t.callback.call(e.oInstance, e, a, r, o, i, l)), n.html(l), ee(e, null, "info", [e, n[0], l])
                }), B("#" + n + "_info", e.nWrapper).length || (u.attr({
                    "aria-live": "polite",
                    id: n + "_info",
                    role: "status"
                }), B(e.nTable).attr("aria-describedby", n + "_info")), u) : null
            }, "i");
            var Ct = 0;

            function It(e, t, n, a) {
                var r = e.oLanguage.oPaginate,
                    o = {
                        display: "",
                        active: !1,
                        disabled: !1
                    };
                switch (t) {
                    case "ellipsis":
                        o.display = "&#x2026;", o.disabled = !0;
                        break;
                    case "first":
                        o.display = r.sFirst, 0 === n && (o.disabled = !0);
                        break;
                    case "previous":
                        o.display = r.sPrevious, 0 === n && (o.disabled = !0);
                        break;
                    case "next":
                        o.display = r.sNext, 0 !== a && n !== a - 1 || (o.disabled = !0);
                        break;
                    case "last":
                        o.display = r.sLast, 0 !== a && n !== a - 1 || (o.disabled = !0);
                        break;
                    default:
                        "number" == typeof t && (o.display = e.fnFormatNumber(t + 1), n === t) && (o.active = !0)
                }
                return o
            }

            function At(e, t, n) {
                var a = [],
                    r = Math.floor(n / 2);
                return t <= n ? a = h(0, t) : 1 === n ? a = [e] : 3 === n ? e <= 1 ? a = [0, 1, "ellipsis"] : t - 2 <= e ? (a = h(t - 2, t)).unshift("ellipsis") : a = ["ellipsis", e, "ellipsis"] : e <= r ? (a = h(0, n - 2)).push("ellipsis", t - 1) : (t - 1 - r <= e ? a = h(t - (n - 2), t) : ((a = h(e - r + 2, e + r - 1)).push("ellipsis", t - 1), a)).unshift(0, "ellipsis"), a
            }
            $.feature.register("search", function(n, e) {
                var t, a, r, o, i, l, s, u, c, d;
                return n.oFeatures.bFilter ? (t = n.oClasses.search, a = n.sTableId, c = n.oLanguage, r = n.oPreviousSearch, o = '<input type="search" class="' + t.input + '"/>', -1 === (e = B.extend({
                    placeholder: c.sSearchPlaceholder,
                    text: c.sSearch
                }, e)).text.indexOf("_INPUT_") && (e.text += "_INPUT_"), e.text = Ke(n, e.text), c = e.text.match(/_INPUT_$/), s = e.text.match(/^_INPUT_/), i = e.text.replace(/_INPUT_/, ""), l = "<label>" + e.text + "</label>", s ? l = "_INPUT_<label>" + i + "</label>" : c && (l = "<label>" + i + "</label>_INPUT_"), (s = B("<div>").addClass(t.container).append(l.replace(/_INPUT_/, o))).find("label").attr("for", "dt-search-" + Ct), s.find("input").attr("id", "dt-search-" + Ct), Ct++, u = function(e) {
                    var t = this.value;
                    r.return && "Enter" !== e.key || t != r.search && (r.search = t, Le(n, r), n._iDisplayStart = 0, S(n))
                }, c = null !== n.searchDelay ? n.searchDelay : 0, d = B("input", s).val(r.search).attr("placeholder", e.placeholder).on("keyup.DT search.DT input.DT paste.DT cut.DT", c ? $.util.debounce(u, c) : u).on("mouseup.DT", function(e) {
                    setTimeout(function() {
                        u.call(d[0], e)
                    }, 10)
                }).on("keypress.DT", function(e) {
                    if (13 == e.keyCode) return !1
                }).attr("aria-controls", a), B(n.nTable).on("search.dt.DT", function(e, t) {
                    n === t && d[0] !== _.activeElement && d.val("function" != typeof r.search ? r.search : "")
                }), s) : null
            }, "f"), $.feature.register("paging", function(e, t) {
                if (!e.oFeatures.bPaginate) return null;
                t = B.extend({
                    numbers: $.ext.pager.numbers_length,
                    type: e.sPaginationType
                }, t);

                function n() {
                    ! function e(t, n, a) {
                        if (!t._bInitComplete) return;
                        var r = $.ext.pager[a.type],
                            o = t.oLanguage.oAria.paginate || {},
                            i = t._iDisplayStart,
                            l = t._iDisplayLength,
                            s = t.fnRecordsDisplay(),
                            u = -1 === l,
                            c = u ? 0 : Math.ceil(i / l),
                            d = u ? 1 : Math.ceil(s / l),
                            f = r().map(function(e) {
                                return "numbers" === e ? At(c, d, a.numbers) : e
                            }).flat();
                        var h = [];
                        for (var p = 0; p < f.length; p++) {
                            var g = f[p],
                                m = It(t, g, c, d),
                                v = Qe(t, "pagingButton")(t, g, m.display, m.active, m.disabled);
                            B(v.clicker).attr({
                                "aria-controls": t.sTableId,
                                "aria-disabled": m.disabled ? "true" : null,
                                "aria-current": m.active ? "page" : null,
                                "aria-label": o[g],
                                "data-dt-idx": g,
                                tabIndex: m.disabled ? -1 : t.iTabIndex
                            }), "number" != typeof g && B(v.clicker).addClass(g), Je(v.clicker, {
                                action: g
                            }, function(e) {
                                e.preventDefault(), Me(t, e.data.action, !0)
                            }), h.push(v.display)
                        }
                        i = Qe(t, "pagingContainer")(t, h);
                        u = n.find(_.activeElement).data("dt-idx");
                        n.empty().append(i);
                        void 0 !== u && n.find("[data-dt-idx=" + u + "]").trigger("focus");
                        h.length && 1 < a.numbers && B(n).height() >= 2 * B(h[0]).outerHeight() - 10 && e(t, n, B.extend({}, a, {
                            numbers: a.numbers - 2
                        }))
                    }(e, a, t)
                }
                var a = B("<div/>").addClass(e.oClasses.paging.container + " paging_" + t.type);
                return e.aoDrawCallback.push(n), B(e.nTable).on("column-sizing.dt.DT", n), a
            }, "p");
            var Ft = 0;
            return $.feature.register("pageLength", function(a, e) {
                var t = a.oFeatures;
                if (!t.bPaginate || !t.bLengthChange) return null;
                e = B.extend({
                    menu: a.aLengthMenu,
                    text: a.oLanguage.sLengthMenu
                }, e);
                var t = a.oClasses.length,
                    n = a.sTableId,
                    r = e.menu,
                    o = [],
                    i = [];
                if (Array.isArray(r[0])) o = r[0], i = r[1];
                else
                    for (p = 0; p < r.length; p++) B.isPlainObject(r[p]) ? (o.push(r[p].value), i.push(r[p].label)) : (o.push(r[p]), i.push(r[p]));
                for (var l = e.text.match(/_MENU_$/), s = e.text.match(/^_MENU_/), u = e.text.replace(/_MENU_/, ""), e = "<label>" + e.text + "</label>", c = (s ? e = "_MENU_<label>" + u + "</label>" : l && (e = "<label>" + u + "</label>_MENU_"), B("<div/>").addClass(t.container).append(e.replace("_MENU_", "<span></span>"))), d = [], f = (c.find("label")[0].childNodes.forEach(function(e) {
                        e.nodeType === Node.TEXT_NODE && d.push({
                            el: e,
                            text: e.textContent
                        })
                    }), function(t) {
                        d.forEach(function(e) {
                            e.el.textContent = Ke(a, e.text, t)
                        })
                    }), h = B("<select/>", {
                        name: n + "_length",
                        "aria-controls": n,
                        class: t.select
                    }), p = 0; p < o.length; p++) h[0][p] = new Option("number" == typeof i[p] ? a.fnFormatNumber(i[p]) : i[p], o[p]);
                return c.find("label").attr("for", "dt-length-" + Ft), h.attr("id", "dt-length-" + Ft), Ft++, c.find("span").replaceWith(h), B("select", c).val(a._iDisplayLength).on("change.DT", function() {
                    Ee(a, B(this).val()), S(a)
                }), B(a.nTable).on("length.dt.DT", function(e, t, n) {
                    a === t && (B("select", c).val(n), f(n))
                }), f(a._iDisplayLength), c
            }, "l"), ((B.fn.dataTable = $).$ = B).fn.dataTableSettings = $.settings, B.fn.dataTableExt = $.ext, B.fn.DataTable = function(e) {
                return B(this).dataTable(e).api()
            }, B.each($, function(e, t) {
                B.fn.DataTable[e] = t
            }), $
        }); /*! DataTables jQuery UI integration * 2011-2014 SpryMedia Ltd - datatables.net/license */
        ! function(n) {
            var a, d;
            "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function(t) {
                return n(t, window, document)
            }) : "object" == typeof exports ? (a = require("jquery"), d = function(t, e) {
                e.fn.dataTable || require("datatables.net")(t, e)
            }, "undefined" == typeof window ? module.exports = function(t, e) {
                return t = t || window, e = e || a(t), d(t, e), n(e, 0, t.document)
            } : (d(window, a), module.exports = n(a, window, window.document))) : n(jQuery, window, document)
        }(function(u, t, e) {
            "use strict";
            var n = u.fn.dataTable;
            return u.extend(!0, n.ext.classes, {
                container: "dt-container dt-jqueryui",
                paging: {
                    active: "ui-state-disabled",
                    button: "fg-button ui-button ui-state-default",
                    container: "dt-paging fg-buttonset ui-buttonset fg-buttonset-multi ui-buttonset-multi",
                    disabled: "ui-state-disabled"
                },
                thead: {
                    cell: "ui-state-default"
                },
                tfoot: {
                    cell: "ui-state-default"
                }
            }), n.ext.renderer.layout.jqueryui = function(t, e, n) {
                var a = !1,
                    d = u("<div/>", {
                        class: "dt-layout-row ui-helper-clearfix"
                    }).appendTo(e);
                u.each(n, function(t, e) {
                    t = u("<div/>", {
                        id: e.id || null,
                        class: "dt-layout-cell dt-" + t + " " + (e.className || "")
                    }).append(e.contents).appendTo(d);
                    u(e.contents).hasClass("dataTable") && (a = !0, t.addClass("table"))
                }), a || d.addClass("fg-toolbar ui-toolbar ui-widget-header")
            }, n
        });
    </script>
    <!-- json-formatter.js -->
    <script>
        ! function(t, e) {
            "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).JSONFormatter = e()
        }(this, (function() {
            "use strict";

            function t(t) {
                return null === t ? "null" : typeof t
            }

            function e(t) {
                return !!t && "object" == typeof t
            }

            function r(t) {
                if (void 0 === t) return "";
                if (null === t) return "Object";
                if ("object" == typeof t && !t.constructor) return "Object";
                var e = /function ([^(]*)/.exec(t.constructor.toString());
                return e && e.length > 1 ? e[1] : ""
            }

            function n(t, e, r) {
                return "null" === t || "undefined" === t ? t : ("string" !== t && "stringifiable" !== t || (r = '"' + (r.replace(/"/g, '\\"') + '"')), "function" === t ? e.toString().replace(/[\r\n]/g, "").replace(/\{.*\}/, "") + "{}" : r)
            }

            function o(o) {
                var i = "";
                return e(o) ? (i = r(o), Array.isArray(o) && (i += "[" + o.length + "]")) : i = n(t(o), o, o), i
            }

            function i(t) {
                return "json-formatter-" + t
            }

            function s(t, e, r) {
                var n = document.createElement(t);
                return e && n.classList.add(i(e)), void 0 !== r && (r instanceof Node ? n.appendChild(r) : n.appendChild(document.createTextNode(String(r)))), n
            }! function(t) {
                if (t && "undefined" != typeof window) {
                    var e = document.createElement("style");
                    e.setAttribute("media", "screen"), e.innerHTML = t, document.head.appendChild(e)
                }
            }('.json-formatter-row {\n  font-family: monospace;\n}\n.json-formatter-row,\n.json-formatter-row a,\n.json-formatter-row a:hover {\n  color: black;\n  text-decoration: none;\n}\n.json-formatter-row .json-formatter-row {\n  margin-left: 1rem;\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty {\n  opacity: 0.5;\n  margin-left: 1rem;\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty:after {\n  display: none;\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-object:after {\n  content: "No properties";\n}\n.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-array:after {\n  content: "[]";\n}\n.json-formatter-row .json-formatter-string,\n.json-formatter-row .json-formatter-stringifiable {\n  color: green;\n  white-space: pre;\n  word-wrap: break-word;\n}\n.json-formatter-row .json-formatter-number {\n  color: blue;\n}\n.json-formatter-row .json-formatter-boolean {\n  color: red;\n}\n.json-formatter-row .json-formatter-null {\n  color: #855A00;\n}\n.json-formatter-row .json-formatter-undefined {\n  color: #ca0b69;\n}\n.json-formatter-row .json-formatter-function {\n  color: #FF20ED;\n}\n.json-formatter-row .json-formatter-date {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n.json-formatter-row .json-formatter-url {\n  text-decoration: underline;\n  color: blue;\n  cursor: pointer;\n}\n.json-formatter-row .json-formatter-bracket {\n  color: blue;\n}\n.json-formatter-row .json-formatter-key {\n  color: #00008B;\n  padding-right: 0.2rem;\n}\n.json-formatter-row .json-formatter-toggler-link {\n  cursor: pointer;\n}\n.json-formatter-row .json-formatter-toggler {\n  line-height: 1.2rem;\n  font-size: 0.7rem;\n  vertical-align: middle;\n  opacity: 0.6;\n  cursor: pointer;\n  padding-right: 0.2rem;\n}\n.json-formatter-row .json-formatter-toggler:after {\n  display: inline-block;\n  transition: transform 100ms ease-in;\n  content: "";\n}\n.json-formatter-row > a > .json-formatter-preview-text {\n  opacity: 0;\n  transition: opacity 0.15s ease-in;\n  font-style: italic;\n}\n.json-formatter-row:hover > a > .json-formatter-preview-text {\n  opacity: 0.6;\n}\n.json-formatter-row.json-formatter-open > .json-formatter-toggler-link .json-formatter-toggler:after {\n  transform: rotate(90deg);\n}\n.json-formatter-row.json-formatter-open > .json-formatter-children:after {\n  display: inline-block;\n}\n.json-formatter-row.json-formatter-open > a > .json-formatter-preview-text {\n  display: none;\n}\n.json-formatter-row.json-formatter-open.json-formatter-empty:after {\n  display: block;\n}\n.json-formatter-dark.json-formatter-row {\n  font-family: monospace;\n}\n.json-formatter-dark.json-formatter-row,\n.json-formatter-dark.json-formatter-row a,\n.json-formatter-dark.json-formatter-row a:hover {\n  color: white;\n  text-decoration: none;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-row {\n  margin-left: 1rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty {\n  opacity: 0.5;\n  margin-left: 1rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty:after {\n  display: none;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-object:after {\n  content: "No properties";\n}\n.json-formatter-dark.json-formatter-row .json-formatter-children.json-formatter-empty.json-formatter-array:after {\n  content: "[]";\n}\n.json-formatter-dark.json-formatter-row .json-formatter-string,\n.json-formatter-dark.json-formatter-row .json-formatter-stringifiable {\n  color: #31F031;\n  white-space: pre;\n  word-wrap: break-word;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-number {\n  color: #66C2FF;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-boolean {\n  color: #EC4242;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-null {\n  color: #EEC97D;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-undefined {\n  color: #ef8fbe;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-function {\n  color: #FD48CB;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-date {\n  background-color: rgba(255, 255, 255, 0.05);\n}\n.json-formatter-dark.json-formatter-row .json-formatter-url {\n  text-decoration: underline;\n  color: #027BFF;\n  cursor: pointer;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-bracket {\n  color: #9494FF;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-key {\n  color: #23A0DB;\n  padding-right: 0.2rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-toggler-link {\n  cursor: pointer;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-toggler {\n  line-height: 1.2rem;\n  font-size: 0.7rem;\n  vertical-align: middle;\n  opacity: 0.6;\n  cursor: pointer;\n  padding-right: 0.2rem;\n}\n.json-formatter-dark.json-formatter-row .json-formatter-toggler:after {\n  display: inline-block;\n  transition: transform 100ms ease-in;\n  content: "";\n}\n.json-formatter-dark.json-formatter-row > a > .json-formatter-preview-text {\n  opacity: 0;\n  transition: opacity 0.15s ease-in;\n  font-style: italic;\n}\n.json-formatter-dark.json-formatter-row:hover > a > .json-formatter-preview-text {\n  opacity: 0.6;\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open > .json-formatter-toggler-link .json-formatter-toggler:after {\n  transform: rotate(90deg);\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open > .json-formatter-children:after {\n  display: inline-block;\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open > a > .json-formatter-preview-text {\n  display: none;\n}\n.json-formatter-dark.json-formatter-row.json-formatter-open.json-formatter-empty:after {\n  display: block;\n}\n');
            var a = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/,
                f = /\d{2}:\d{2}:\d{2} GMT-\d{4}/,
                m = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/,
                l = window.requestAnimationFrame || function(t) {
                    return t(), 0
                },
                c = {
                    hoverPreviewEnabled: !1,
                    hoverPreviewArrayCount: 100,
                    hoverPreviewFieldCount: 5,
                    animateOpen: !0,
                    animateClose: !0,
                    theme: null,
                    useToJSON: !0,
                    sortPropertiesBy: null,
                    maxArrayItems: 100,
                    exposePath: !1
                };
            return function() {
                function d(t, e, r, n, o, i, s) {
                    void 0 === e && (e = 1), void 0 === r && (r = c), void 0 === i && (i = []), this.json = t, this.open = e, this.config = r, this.key = n, this.displayKey = o, this.path = i, this.arrayRange = s, this._isOpen = null, void 0 === this.config.hoverPreviewEnabled && (this.config.hoverPreviewEnabled = c.hoverPreviewEnabled), void 0 === this.config.hoverPreviewArrayCount && (this.config.hoverPreviewArrayCount = c.hoverPreviewArrayCount), void 0 === this.config.hoverPreviewFieldCount && (this.config.hoverPreviewFieldCount = c.hoverPreviewFieldCount), void 0 === this.config.useToJSON && (this.config.useToJSON = c.useToJSON), void 0 === this.config.maxArrayItems && (this.config.maxArrayItems = c.maxArrayItems), "" === this.key && (this.key = '""'), void 0 === this.displayKey && (this.displayKey = this.key)
                }
                return Object.defineProperty(d.prototype, "isOpen", {
                    get: function() {
                        return null !== this._isOpen ? this._isOpen : this.open > 0
                    },
                    set: function(t) {
                        this._isOpen = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isDate", {
                    get: function() {
                        return this.json instanceof Date || "string" === this.type && (a.test(this.json) || m.test(this.json) || f.test(this.json))
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isUrl", {
                    get: function() {
                        return "string" === this.type && 0 === this.json.indexOf("http")
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isArray", {
                    get: function() {
                        return Array.isArray(this.json)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isLargeArray", {
                    get: function() {
                        return this.isArray && this.json.length > this.config.maxArrayItems
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isArrayRange", {
                    get: function() {
                        return this.isArray && void 0 !== this.arrayRange && 2 == this.arrayRange.length
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isObject", {
                    get: function() {
                        return e(this.json)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isEmptyObject", {
                    get: function() {
                        return !this.keys.length && !this.isArray
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "isEmpty", {
                    get: function() {
                        return this.isEmptyObject || this.keys && !this.keys.length && this.isArray
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "useToJSON", {
                    get: function() {
                        return this.config.useToJSON && "stringifiable" === this.type
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "hasKey", {
                    get: function() {
                        return void 0 !== this.key
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "constructorName", {
                    get: function() {
                        return r(this.json)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "type", {
                    get: function() {
                        return this.config.useToJSON && this.json && this.json.toJSON ? "stringifiable" : t(this.json)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(d.prototype, "keys", {
                    get: function() {
                        if (this.isObject) {
                            var t = Object.keys(this.json);
                            if (this.isLargeArray) {
                                var e = Math.ceil(this.json.length / this.config.maxArrayItems);
                                t = [];
                                for (var r = 0; r < e; r++) {
                                    var n = r * this.config.maxArrayItems,
                                        o = Math.min(this.json.length - 1, n + (this.config.maxArrayItems - 1));
                                    t.push(n + "  " + o)
                                }
                            }
                            return !this.isArray && this.config.sortPropertiesBy ? t.sort(this.config.sortPropertiesBy) : t
                        }
                        return []
                    },
                    enumerable: !1,
                    configurable: !0
                }), d.prototype.toggleOpen = function() {
                    this.isOpen = !this.isOpen, this.element && (this.isOpen ? this.appendChildren(this.config.animateOpen) : this.removeChildren(this.config.animateClose), this.element.classList.toggle(i("open")))
                }, d.prototype.openAtDepth = function(t) {
                    void 0 === t && (t = 1), t < 0 || (this.open = t, this.isOpen = 0 !== t, this.element && (this.removeChildren(!1), 0 === t ? this.element.classList.remove(i("open")) : (this.appendChildren(this.config.animateOpen), this.element.classList.add(i("open")))))
                }, d.prototype.getInlinepreview = function() {
                    var t = this;
                    if (this.isArray) return this.json.length > this.config.hoverPreviewArrayCount ? "Array[" + this.json.length + "]" : "[" + this.json.map(o).join(", ") + "]";
                    var e = this.keys,
                        r = e.slice(0, this.config.hoverPreviewFieldCount).map((function(e) {
                            return e + ":" + o(t.json[e])
                        })),
                        n = e.length >= this.config.hoverPreviewFieldCount ? "" : "";
                    return "{" + r.join(", ") + n + "}"
                }, d.prototype.render = function() {
                    this.element = s("div", "row");
                    var t = this.isObject ? s("a", "toggler-link") : s("span");
                    if (this.isObject && !this.useToJSON && t.appendChild(s("span", "toggler")), this.isArrayRange ? t.appendChild(s("span", "range", "[" + this.displayKey + "]")) : this.hasKey && (t.appendChild(s("span", "key", this.displayKey + ":")), this.config.exposePath && (this.element.dataset.path = JSON.stringify(this.path))), this.isObject && !this.useToJSON) {
                        var e = s("span", "value"),
                            r = s("span");
                        if (!this.isArrayRange) {
                            var o = s("span", "constructor-name", this.constructorName);
                            r.appendChild(o)
                        }
                        if (this.isArray && !this.isArrayRange) {
                            var a = s("span");
                            a.appendChild(s("span", "bracket", "[")), a.appendChild(s("span", "number", this.json.length)), a.appendChild(s("span", "bracket", "]")), r.appendChild(a)
                        }
                        e.appendChild(r), t.appendChild(e)
                    } else {
                        (e = this.isUrl ? s("a") : s("span")).classList.add(i(this.type)), this.isDate && e.classList.add(i("date")), this.isUrl && (e.classList.add(i("url")), e.setAttribute("href", this.json));
                        var f = n(this.type, this.json, this.useToJSON ? this.json.toJSON() : this.json);
                        e.appendChild(document.createTextNode(f)), t.appendChild(e)
                    }
                    if (this.isObject && this.config.hoverPreviewEnabled) {
                        var m = s("span", "preview-text");
                        m.appendChild(document.createTextNode(this.getInlinepreview())), t.appendChild(m)
                    }
                    var l = s("div", "children");
                    return this.isObject && l.classList.add(i("object")), this.isArray && l.classList.add(i("array")), this.isEmpty && l.classList.add(i("empty")), this.config && this.config.theme && this.element.classList.add(i(this.config.theme)), this.isOpen && this.element.classList.add(i("open")), this.element.appendChild(t), this.element.appendChild(l), this.isObject && this.isOpen && this.appendChildren(), this.isObject && !this.useToJSON && t.addEventListener("click", this.toggleOpen.bind(this)), this.element
                }, d.prototype.appendChildren = function(t) {
                    var e = this;
                    void 0 === t && (t = !1);
                    var r = this.element.querySelector("div." + i("children"));
                    if (r && !this.isEmpty) {
                        var n = function(t, n) {
                            var o = e.isLargeArray ? [n * e.config.maxArrayItems, Math.min(e.json.length - 1, n * e.config.maxArrayItems + (e.config.maxArrayItems - 1))] : void 0,
                                i = e.isArrayRange ? (e.arrayRange[0] + n).toString() : t,
                                s = new d(o ? e.json.slice(o[0], o[1] + 1) : e.json[t], e.open - 1, e.config, t, i, o ? e.path : e.path.concat(i), o);
                            r.appendChild(s.render())
                        };
                        if (t) {
                            var o = 0,
                                s = function() {
                                    var t = e.keys[o];
                                    n(t, o), (o += 1) < e.keys.length && (o > 10 ? s() : l(s))
                                };
                            l(s)
                        } else this.keys.forEach((function(t, e) {
                            return n(t, e)
                        }))
                    }
                }, d.prototype.removeChildren = function(t) {
                    void 0 === t && (t = !1);
                    var e = this.element.querySelector("div." + i("children"));
                    if (t) {
                        var r = 0,
                            n = function() {
                                e && e.children.length && (e.removeChild(e.children[0]), (r += 1) > 10 ? n() : l(n))
                            };
                        l(n)
                    } else e && (e.innerHTML = "")
                }, d
            }()
        }));
    </script>

    <style>
        body {
            margin: 0 auto;
        }
        
        .sw-bg {
            display: none !important;
        }
        
        #flex-layout {
            width: 100%;
            height: 100%;
        }
        
        #l-nav {
            color: white;
            z-index: 1;
            background-color: #181B20;
            position: fixed;
            width: 50px;
            height: 100%;
            font-size: 16px;
            line-height: 40px;
            text-align: center;
            font-weight: bold;
            transition-property: width;
            transition-duration: .6s;
            transition-timing-function: cubic-bezier(0.18, 1.11, 0.58, 0.52);
        }
        
        #l-nav:hover {
            width: 376px;
        }
        
        #l-nav:hover #nav-group div {
            margin-left: 16px;
            width: calc(100% - 32px);
        }
        
        #l-nav span {
            display: none;
        }
        
        #l-nav:hover span {
            display: block;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }
        
        #l-nav #nav-group img {
            display: block;
        }
        
        #l-nav:hover #nav-group img {
            display: none;
        }
        
        #brand div {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            height: 64px;
        }
        
        #nav-group div {
            margin-left: 4px;
            background-color: #1F2329;
            width: calc(100% - 8px);
            height: 40px;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            cursor: pointer;
        }
        
        #nav-group div:hover {
            background-color: #2A2F37;
        }
        
        #nav-group div.cur-nav {
            background-color: #0077FF;
        }
        
        #r-content {
            margin-left: 50px;
            width: calc(100% - 50px);
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #inner-content {
            width: calc(100% - 20px);
            margin-top: 10px;
            height: 100%;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        #jft {
            width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #181B20;
        }
        
        #jft>div>a {
            visibility: hidden;
        }
        
        #jft .json-formatter-row {}
        
        #jft>div>div>div>div>div>a>span.json-formatter-key {
            color: green;
            text-decoration: underline;
        }
        
        #jft>div>div>div>div>div.json-formatter-row.json-formatter-open>div>div>a {
            user-select: none;
            pointer-events: none;
        }
        
        #jft>div>div>div>div>div.json-formatter-row.json-formatter-open>div>div>a>span.json-formatter-toggler {
            visibility: hidden;
        }
        
        .json-formatter-value {
            color: grey;
        }
        
        #json-charts {
            display: flex;
            flex-direction: row-reverse;
        }
        
        #chart-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            margin-right: 10px;
            flex: 1;
            border: 1px solid black;
        }
        
        canvas {
            width: 100% !important;
            height: 80vh;
        }
    </style>
</head>

<body>
    <div id="flex-layout">
        <div id="l-nav">
            <div id="brand">
                <div>
                    <img width="40px" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMzhweCIgaGVpZ2h0PSIzOHB4IiB2aWV3Qm94PSIwIDAgMzggMzgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8dGl0bGU+57yW57uEPC90aXRsZT4KICAgIDxkZWZzPgogICAgICAgIDxwb2x5Z29uIGlkPSJwYXRoLTEiIHBvaW50cz0iMCAwIDYuMDY5NjkwNzcgMCA2LjA2OTY5MDc3IDEwLjIxNzYxOTIgMCAxMC4yMTc2MTkyIj48L3BvbHlnb24+CiAgICA8L2RlZnM+CiAgICA8ZyBpZD0iU3ltYm9scyIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9Ik5hdmlnYXRpb24vdG9wL0xldmVsLTIvYWxsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNjEuMDAwMDAwLCAtNDkuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIGlkPSLnvJbnu4QiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYzLjAwMDAwMCwgNDkuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8cG9seWdvbiBpZD0iRmlsbC0xIiBmaWxsPSIjQzcwMDBCIiBwb2ludHM9IjcuMjg1NDU2NzEgMTMuMTk5OTQ2OCA1Ljk3MDYzNDIyIDE2LjkxODU0NzYgMCAxNS44OTY1ODYyIDcuMDM3NDMwODggMjAuOTYzMzk1OSAzMi42MDA1Njc5IDAiPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDxwb2x5Z29uIGlkPSJGaWxsLTIiIGZpbGw9IiNEQkRBREEiIHBvaW50cz0iOC4xMjYwODYzNCAyMS43NDYyMzQ3IDIzLjcyMDI5ODUgMzMgMTcuMTE0MTExOSAyMi4yMzU4Mjc2IDMwLjc3OTI1ODcgMi45OTAxMDciPjwvcG9seWdvbj4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"
                    />
                    <span>Kunpeng DevKit</span>
                </div>
            </div>
            <div id="nav-group">
                <div id="nav-report" onclick="navigation('report')">
                    <img style="scale: 1.1;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcxLjgsMjVoLTJhLjk0Ljk0LDAsMCwwLTEsMXY0YTgsOCwwLDAsMS03LjkzLDhIMzkuMWE4LDgsMCwwLDEtNy45My04VjI2YS45NC45NCwwLDAsMC0xLTFoLTJhNiw2LDAsMCwwLTUuOTUsNlY3NGE2LDYsMCwwLDAsNS45NSw2SDcxLjhhNiw2LDAsMCwwLDUuOTUtNlYzMUE2LDYsMCwwLDAsNzEuOCwyNVpNNDMuMDYsNjZhMiwyLDAsMCwxLTIsMmgtMmEyLDIsMCwwLDEtMi0yVjU2YTIsMiwwLDAsMSwyLTJoMmEyLDIsMCwwLDEsMiwyWk01Myw2NmEyLDIsMCwwLDEtMiwySDQ5YTIsMiwwLDAsMS0yLTJWNDdhMiwyLDAsMCwxLDItMmgyYTIsMiwwLDAsMSwyLDJabTkuOTEsMGEyLDIsMCwwLDEtMiwyaC0yYTIsMiwwLDAsMS0yLTJWNTFhMiwyLDAsMCwxLDItMmgyYTIsMiwwLDAsMSwyLDJaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48cGF0aCBkPSJNMzkuMSwzMkg2MC45YTIsMiwwLDAsMCwyLTJWMjZhNiw2LDAsMCwwLTUuOTUtNkg0My4wNmE2LDYsMCwwLDAtNS45NSw2djRBMiwyLDAsMCwwLDM5LjEsMzJaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4="
                    />
                    <span></span>
                </div>
                <div id="nav-trend" onclick="navigation('trend')">
                    <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIEdlbmVyYXRvcjogU1ZHIFJlcG8gTWl4ZXIgVG9vbHMgLS0+DQo8c3ZnIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iMCAwIDI0IDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPg0KICAgIDx0aXRsZT5wZXJmb3JtYW5jZV9saW5lPC90aXRsZT4NCiAgICA8ZyBpZD0i6aG16Z2iLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPg0KICAgICAgICA8ZyBpZD0iRGV2ZWxvcG1lbnQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04NjQuMDAwMDAwLCAwLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyI+DQogICAgICAgICAgICA8ZyBpZD0icGVyZm9ybWFuY2VfbGluZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODY0LjAwMDAwMCwgMC4wMDAwMDApIj4NCiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMjQsMCBMMjQsMjQgTDAsMjQgTDAsMCBMMjQsMCBaIE0xMi41OTM0OTAxLDIzLjI1Nzg0MSBMMTIuNTgxOTQwMiwyMy4yNTk1MTMxIEwxMi41MTA4Nzc3LDIzLjI5NTA0MzkgTDEyLjQ5MTg3OTEsMjMuMjk4NzQ2OSBMMTIuNDkxODc5MSwyMy4yOTg3NDY5IEwxMi40NzY3MTUyLDIzLjI5NTA0MzkgTDEyLjQwNTY1NDgsMjMuMjU5NTEzMSBDMTIuMzk1ODIyOSwyMy4yNTYzNjYyIDEyLjM4NzA0OTMsMjMuMjU5MDIzNSAxMi4zODIxNDIxLDIzLjI2NDkwNzQgTDEyLjM3ODAzMjMsMjMuMjc1ODMxIEwxMi4zNjA5NDEsMjMuNzAzMTA5NyBMMTIuMzY1ODk0NywyMy43MjM0OTk0IEwxMi4zNzY5MDQ4LDIzLjczNTcxMzkgTDEyLjQ4MDQ3NzcsMjMuODA5NjkzMSBMMTIuNDk1MzQ5MSwyMy44MTM2MTM0IEwxMi40OTUzNDkxLDIzLjgxMzYxMzQgTDEyLjUwNzExNTIsMjMuODA5NjkzMSBMMTIuNjEwNjkwMiwyMy43MzU3MTM5IEwxMi42MjMyOTM4LDIzLjcxOTY3MzMgTDEyLjYyMzI5MzgsMjMuNzE5NjczMyBMMTIuNjI2NjUyNywyMy43MDMxMDk3IEwxMi42MDk1NjEsMjMuMjc1ODMxIEMxMi42MDc1NzI0LDIzLjI2NTcwMTMgMTIuNjAxMDExMiwyMy4yNTkyOTkzIDEyLjU5MzQ5MDEsMjMuMjU3ODQxIEwxMi41OTM0OTAxLDIzLjI1Nzg0MSBaIE0xMi44NTgzOTA2LDIzLjE0NTI4NjIgTDEyLjg0NDU0ODUsMjMuMTQ3MzA3MiBMMTIuNjU5ODQ0MywyMy4yMzk2NTk3IEwxMi42NDk4ODIyLDIzLjI0OTkwNTIgTDEyLjY0OTg4MjIsMjMuMjQ5OTA1MiBMMTIuNjQ3MTk0MywyMy4yNjExMTE0IEwxMi42NjUwOTQzLDIzLjY5MDYzODkgTDEyLjY2OTkzNDksMjMuNzAzNDE3OCBMMTIuNjY5OTM0OSwyMy43MDM0MTc4IEwxMi42NzgzODYsMjMuNzEwNDkzMSBMMTIuODc5MzQwMiwyMy44MDMyMzg5IEMxMi44OTE0Mjg1LDIzLjgwNjg5OTkgMTIuOTAyMjMzMywyMy44MDI5ODc1IDEyLjkwNzgyODYsMjMuNzk1MjI2NCBMMTIuOTExODIzNSwyMy43ODExNjM5IEwxMi44Nzc2Nzc3LDIzLjE2NjUzMzEgQzEyLjg3NTI4ODIsMjMuMTU0NTg5NyAxMi44Njc0MTAyLDIzLjE0NzAwMTYgMTIuODU4MzkwNiwyMy4xNDUyODYyIEwxMi44NTgzOTA2LDIzLjE0NTI4NjIgWiBNMTIuMTQzMDQ3MywyMy4xNDczMDcyIEMxMi4xMzMyMTc4LDIzLjE0MjM5MjUgMTIuMTIyMTc2MywyMy4xNDUyNjA2IDEyLjExNTYzNjUsMjMuMTUyNTk1NCBMMTIuMTA5OTE3MywyMy4xNjY1MzMxIEwxMi4wNzU3NzE0LDIzLjc4MTE2MzkgQzEyLjA3NTEzMjMsMjMuNzkyNjYzOSAxMi4wODI4MDk5LDIzLjgwMTg2MDIgMTIuMDkyNjQ4MSwyMy44MDQ1Njc2IEwxMi4xMDgyNTYsMjMuODAzMjM4OSBMMTIuMzA5MjEwNiwyMy43MTA0OTMxIEwxMi4zMTg2NDk3LDIzLjcwMjQzNDcgTDEyLjMxODY0OTcsMjMuNzAyNDM0NyBMMTIuMzIyNTA0MywyMy42OTA2Mzg5IEwxMi4zNDA0MDEsMjMuMjYxMTExNCBMMTIuMzM3MjQ1LDIzLjI0ODUxNzYgTDEyLjMzNzI0NSwyMy4yNDg1MTc2IEwxMi4zMjc3NTMxLDIzLjIzOTY1OTcgTDEyLjE0MzA0NzMsMjMuMTQ3MzA3MiBaIiBpZD0iTWluZ0N1dGUiIGZpbGwtcnVsZT0ibm9uemVybyI+DQoNCjwvcGF0aD4NCiAgICAgICAgICAgICAgICA8cGF0aCBkPSJNMTksMyBDMjAuMTA0NiwzIDIxLDMuODk1NDMgMjEsNSBMMjEsMTkgQzIxLDIwLjEwNDYgMjAuMTA0NiwyMSAxOSwyMSBMNSwyMSBDMy44OTU0MywyMSAzLDIwLjEwNDYgMywxOSBMMyw1IEMzLDMuODk1NDMgMy44OTU0MywzIDUsMyBMMTksMyBaIE0xOSw1IEw1LDUgTDUsMTkgTDE5LDE5IEwxOSw1IFogTTEyLjAzNzEsNy43Mjg1NSBDMTIuMzA4MjczOSw2Ljg2MDk3NTIyIDEzLjQ3NzcyOTksNi43NzgxMzkxOSAxMy44ODc4Mzg1LDcuNTQ0ODczMzMgTDEzLjkzODksNy42NTQ3IEwxNS42NzcsMTIgTDE3LDEyIEMxNy41NTIzLDEyIDE4LDEyLjQ0NzcgMTgsMTMgQzE4LDEzLjUxMjg1IDE3LjYxMzk3MywxMy45MzU1MDkyIDE3LjExNjYyMzksMTMuOTkzMjcyNSBMMTcsMTQgTDE1LjAwNjgsMTQgQzE0LjYzNTEsMTQgMTQuMjk3MDk2LDEzLjc5NjM2NiAxNC4xMjEzODM2LDEzLjQ3NjA2NzcgTDE0LjA2OSwxMy4zNjUxIEwxMy4xMTU4LDEwLjk4MjEgTDExLjQ2MTksMTYuMjc0NiBDMTEuMjAzMDI3MywxNy4xMDI3NjM2IDEwLjEwNzI1NjgsMTcuMjI3Nzg3NCA5LjY1NDYwOTE1LDE2LjUzMDI1NTkgTDkuNTk0NDgsMTYuNDI1IEw4LjM4MTk3LDE0IEw3LDE0IEM2LjQ0NzcyLDE0IDYsMTMuNTUyMyA2LDEzIEM2LDEyLjQ4NzE1IDYuMzg2MDQ0MjksMTIuMDY0NDkwOCA2Ljg4MzM3OTc1LDEyLjAwNjcyNzUgTDcsMTIgTDguOTkzODIsMTIgQzkuMzMzODgyMjIsMTIgOS42NDc5ODg4OSwxMi4xNzA3NDU3IDkuODMzNzQ3MDIsMTIuNDQ5MDI3MiBMOS44OTcxOSwxMi41NTgzIEwxMC4yODUzLDEzLjMzNDUgTDEyLjAzNzEsNy43Mjg1NSBaIiBpZD0i5b2i54q2IiBmaWxsPSIjRkZGRkZGIj4NCg0KPC9wYXRoPg0KICAgICAgICAgICAgPC9nPg0KICAgICAgICA8L2c+DQogICAgPC9nPg0KPC9zdmc+"
                    />
                    <span></span>
                </div>
                <div id="nav-git" onclick="navigation('git')">
                    <img style="scale: 0.9;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTMuNDE0MiAzLjgyODQzQzEyLjYzMzIgMy4wNDczOCAxMS4zNjY4IDMuMDQ3MzggMTAuNTg1OCAzLjgyODQzTDkuOTE0MjEgNC41TDExLjQ4MiA2LjA2Nzc0QzExLjY0NzIgNi4wMjM1NiAxMS44MjA4IDYgMTIgNkMxMy4xMDQ2IDYgMTQgNi44OTU0MyAxNCA4QzE0IDguMTc5MTYgMTMuOTc2NCA4LjM1MjgyIDEzLjkzMjMgOC41MTgwNEwxNS45ODIgMTAuNTY3N0MxNi4xNDcyIDEwLjUyMzYgMTYuMzIwOCAxMC41IDE2LjUgMTAuNUMxNy42MDQ2IDEwLjUgMTguNSAxMS4zOTU0IDE4LjUgMTIuNUMxOC41IDEzLjYwNDYgMTcuNjA0NiAxNC41IDE2LjUgMTQuNUMxNS4zOTU0IDE0LjUgMTQuNSAxMy42MDQ2IDE0LjUgMTIuNUMxNC41IDEyLjMyMDggMTQuNTIzNiAxMi4xNDcyIDE0LjU2NzcgMTEuOTgyTDEzIDEwLjQxNDJWMTUuMjY3NkMxMy41OTc4IDE1LjYxMzQgMTQgMTYuMjU5NyAxNCAxN0MxNCAxOC4xMDQ2IDEzLjEwNDYgMTkgMTIgMTlDMTAuODk1NCAxOSAxMCAxOC4xMDQ2IDEwIDE3QzEwIDE2LjI1OTcgMTAuNDAyMiAxNS42MTM0IDExIDE1LjI2NzZWOS43MzI0NEMxMC40MDIyIDkuMzg2NjMgMTAgOC43NDAyOCAxMCA4QzEwIDcuODIwODQgMTAuMDIzNiA3LjY0NzE4IDEwLjA2NzcgNy40ODE5Nkw4LjUgNS45MTQyMUwzLjgyODQzIDEwLjU4NThDMy4wNDczOCAxMS4zNjY4IDMuMDQ3MzggMTIuNjMzMiAzLjgyODQzIDEzLjQxNDJMMTAuNTg1OCAyMC4xNzE2QzExLjM2NjggMjAuOTUyNiAxMi42MzMyIDIwLjk1MjYgMTMuNDE0MiAyMC4xNzE2TDIwLjE3MTYgMTMuNDE0MkMyMC45NTI2IDEyLjYzMzIgMjAuOTUyNiAxMS4zNjY4IDIwLjE3MTYgMTAuNTg1OEwxMy40MTQyIDMuODI4NDNaTTkuMTcxNTcgMi40MTQyMUMxMC43MzM3IDAuODUyMTE1IDEzLjI2NjMgMC44NTIxMTkgMTQuODI4NCAyLjQxNDIyTDIxLjU4NTggOS4xNzE1N0MyMy4xNDc5IDEwLjczMzcgMjMuMTQ3OSAxMy4yNjYzIDIxLjU4NTggMTQuODI4NEwxNC44Mjg0IDIxLjU4NThDMTMuMjY2MyAyMy4xNDc5IDEwLjczMzcgMjMuMTQ3OSA5LjE3MTU3IDIxLjU4NThMMi40MTQyMSAxNC44Mjg0QzAuODUyMTE1IDEzLjI2NjMgMC44NTIxMTkgMTAuNzMzNyAyLjQxNDIyIDkuMTcxNTdMOS4xNzE1NyAyLjQxNDIxWiIgZmlsbD0iI0ZGRkZGRiIvPg0KPC9zdmc+"
                    />
                    <span>Git </span>
                </div>
                <div id="nav-chart" onclick="navigation('chart')">
                    <img style="scale: 0.9;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0yMSAyMUg3LjhDNi4xMTk4NCAyMSA1LjI3OTc2IDIxIDQuNjM4MDMgMjAuNjczQzQuMDczNTQgMjAuMzg1NCAzLjYxNDYgMTkuOTI2NSAzLjMyNjk4IDE5LjM2MkMzIDE4LjcyMDIgMyAxNy44ODAyIDMgMTYuMlYzTTYgMTVMMTAgMTFMMTQgMTVMMjAgOU0yMCA5VjEzTTIwIDlIMTYiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4NCjwvc3ZnPg=="
                    />
                    <span></span>
                </div>
            </div>
        </div>
        <div id="r-content">
            <div id="inner-content"></div>
        </div>
    </div>
</body>
<script>
    const navigation = (target) => {
        if (!$(`#nav-${target}`).hasClass('cur-nav')) {
            $('#nav-group div').removeClass('cur-nav');
            $(`#nav-${target}`).addClass('cur-nav');
            replaceInnerContent(callable[`${target}Html`]());
            callable[`${target}Script`](target);
        }
    };
    const replaceInnerContent = (htmlTpl) => {
        $('#inner-content').html(null);
        $('#inner-content').html(htmlTpl);
    };
    const reportHtml = () => {
        return `
<h1>DevKit Performance Test Info</h1>
<div id="tables">
  <table id="example" class="display"></table>
</div>
    `;
    };
    const trendHtml = () => {
        return `
<h1>
  DevKit Performance Summary
  <button onclick="switchContent('trend')" style="font-size: 20px;">Table/Chart</button>
</h1>
<div id="tables" class="sw-fc">
  <table id="example" class="display"></table>
</div>
<div id="json-charts" class="sw-bg">
  <div id="chart-container">
    <canvas id="cvs"></canvas>
  </div>
</div>
    `;
    };
    const gitHtml = () => {
        return `
<h1>Today's Git Log</h1>
<div id="tables">
  <table id="example" class="display"></table>
</div>
    `;
    };
    const chartHtml = () => {
        return `
<h1>Json & Chart</h1>
<div id="json-charts">
  <div id="jft"></div>
  <div id="chart-container">
    <canvas id="cvs"></canvas>
  </div>
</div>
    `;
    };
    const consumeTableData = (target, collect = false) => {
        const dataCopy = structuredClone(pipelineData[target] ? .[`${target}_tb_data`]);
        const colsCount = pipelineData[target] ? .[`${target}_tb_cols`];
        const originDataRef = pipelineData[target] ? .[`${target}_tb_data`];
        if (colsCount > 0 && originDataRef.length % colsCount === 0) {
            const columns = [];
            for (let i = 0; i < colsCount; ++i) {
                columns.push({
                    title: dataCopy.shift()
                });
            }
            const dataSet = [];
            for (let i = 0; i < originDataRef.length / colsCount - 1; ++i) {
                const row = [];
                for (let j = 0; j < colsCount; ++j) {
                    row.push(dataCopy.shift());
                }
                dataSet.push(row);
            }
            dataSet.forEach(r => {
                let div1 = document.createElement('div');
                div1.innerHTML = r[1];
                r[1] = div1;
                let div3 = document.createElement('div');
                div3.innerHTML = r[3];
                r[3] = div3;
            });
            new DataTable('#example', {
                columns,
                data: dataSet,
                searching: true,
                lengthChange: false,
                info: false,
                paging: true,
            });
            if (collect) {
                const labels = pipelineData[target] ? .[`${target}_chart_labels`];
                const chartData = {};
                for (const label of labels) {
                    const idx = originDataRef.indexOf(label);
                    const singleCol = [];
                    for (let i = idx + colsCount; i < originDataRef.length; i += colsCount) {
                        singleCol.push(Number(originDataRef[i]));
                    }
                    chartData[label] = singleCol;
                }
                return chartData;
            }
        }
    }
    const reportScript = (target) => {
        consumeTableData(target);
    }
    const trendScript = (target) => {
        const chartData = consumeTableData(target, true);
        const canvasContainer = document.getElementById('chart-container');
        const canvas = document.getElementById('cvs');
        canvasContainer.removeChild(canvas);
        const newCanvas = document.createElement('canvas');
        newCanvas.id = 'cvs';
        canvasContainer.appendChild(newCanvas);
        newCanvas.width = newCanvas.clientWidth * devicePixelRatio;
        newCanvas.height = newCanvas.clientHeight * devicePixelRatio;
        processData(chartData, pipelineData[target] ? .[`${target}_chart_labels`][0]);

    };
    const gitScript = (target) => {
        consumeTableData(target);
    };
    const chartScript = (target) => {
        const jsonData = pipelineData[target] ? .chart_json;
        const formatter = new JSONFormatter(jsonData, 2, {
            exposePath: true
        });
        const jft = document.getElementById('jft');
        jft.appendChild(formatter.render());
        let prevPath = '';
        jft.addEventListener('click', (e) => {
            const pathStr = e.target ? .parentNode ? .parentNode ? .dataset ? .path;
            if (pathStr && pathStr.length) {
                const pathArray = JSON.parse(pathStr);
                if (pathArray.length === 2 && prevPath !== pathStr) {
                    prevPath = pathStr;
                    let ptr = jsonData;
                    for (const path of pathArray) {
                        ptr = ptr[path];
                    }
                    const canvasContainer = document.getElementById('chart-container');
                    const canvas = document.getElementById('cvs');
                    canvasContainer.removeChild(canvas);
                    const newCanvas = document.createElement('canvas');
                    newCanvas.id = 'cvs';
                    canvasContainer.appendChild(newCanvas);
                    newCanvas.width = newCanvas.clientWidth * devicePixelRatio;
                    newCanvas.height = newCanvas.clientHeight * devicePixelRatio;
                    processData(ptr);
                }
            }
        });
    };
    const completeCallable = {
        reportHtml,
        trendHtml,
        gitHtml,
        chartHtml,
        reportScript,
        trendScript,
        gitScript,
        chartScript
    };
    const callable = {};
    for (const page of valid_pages) {
        if (full_pages.includes(page)) {
            callable[`${page}Html`] = completeCallable[`${page}Html`];
            callable[`${page}Script`] = completeCallable[`${page}Script`];
        }
    }
    for (const page of full_pages) {
        if (!valid_pages.includes(page)) {
            $(`#nav-${page}`).css('display', 'none');
        }
    }
    if (valid_pages ? .[0] && full_pages.includes(valid_pages[0])) {
        navigation(valid_pages[0]);
    }

    function switchContent(target) {
        const focused = $('.sw-fc');
        const backgrounded = $('.sw-bg');
        focused.removeClass('sw-fc');
        focused.addClass('sw-bg');
        backgrounded.removeClass('sw-bg');
        backgrounded.addClass('sw-fc');
    }

    function processData(jsonData, keyOfX = undefined) {
        const categories = Object.keys(jsonData);
        const data = {};
        let labels = Array.from({
            length: jsonData[categories[0]].length
        }, (_, i) => i);
        if (keyOfX) {
            labels = jsonData[keyOfX];
        }
        for (const category of categories) {
            if (category !== keyOfX) {
                data[category] = jsonData[category];
            }
        }
        createLineChart('cvs', labels, data);
    }

    function createLineChart(chartId, labels, data) {
        const ctx = document.getElementById(chartId).getContext('2d');
        const datasets = Object.keys(data).map((label, index) => ({
            label,
            data: data[label],
            borderColor: getRandomColor(),
            fill: false
        }));
        const chartData = {
            labels,
            datasets
        };
        new Chart(ctx, {
            type: 'line',
            data: chartData
        })
    }

    function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; ++i) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
</script>

</html>